---
layout: '[default_layout]'   
title: python使用中解决技巧
date: 2018-08-21 19:48:41  
updated: 
permalink: 
render_drafts: true
copyright: true
password: 
comments: true
toc: true                  
tags:                        
- ML
- Python
- Groupby
- Replace
- stack
- vstack
- hstack

categories:                  
- ML

---
# 1、格式化输出
[【Python笔记】1、格式化输出（%用法和format用法）](https://www.cnblogs.com/fat39/p/7159881.html)

```
print('%d + %d = %d' % (a, b, c))
```

# 2、Pandas的DataFrame输出截断和省略问题
```
pd.set_option('display.width',200)
pd.set_option('display.max_colwidth',100)
```
同样，我们还可以控制max_row，max_column等参数，使得我们根据实际数据的显示要求进行设置。更多的设置项详见： 
https://pandas.pydata.org/pandas-docs/stable/generated/pandas.set_option.html

# 3、jupyter notebook中美化pandas中DataFrame的输出
https://blog.csdn.net/xiaodongxiexie/article/details/71202279


# 4、Python Jupyter Notebook显示行号
Jupyter Notebook默认不显示行号，不方便我们调试排错。操作如下：
找到菜单View找到Toggle Line Numbers
好了，那我继续调错了……/(ㄒoㄒ)/~~

# 5、保留三位小数
print(round(3.1415926, 3))   # 四舍五入保留3位小数
print( format(x*0.4463,'0.1f'))

# 6、文件传入参数
```python
import sys
print(sys.argv[0]) # 当前文件的绝对路径
# print(sys.argv[1]) # 空参数
```
# 7、取整操作
https://www.jb51.net/article/102248.htm
双斜杠：53 // 8

# 8、输入操作
学到了：h1, m1, h2, m2 = map(int, input().split())
datetime.timedelta似乎
```
import datetime

s = input().split()

t1 = datetime.datetime(2018, 10, 2, int(s[0]), int(s[1]))
t2 = datetime.datetime(2018, 10, 2, int(s[2]), int(s[3]))
seconds = (t2 - t1).seconds
print(seconds // 3600, seconds % 3600 // 60)
```

# 1、sklearn的train_test_split函数用法 
https://blog.csdn.net/sinat_23338865/article/details/80248599
用于将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签。

# 2、工欲善其事必先利其器（sublime）
使用sublime运行python：
- 1、添加python环境变量，即可ctrl+B运行python
- 2、sublime无法解决输入问题，方法有二：
	- cmd窗口输入设置
	- 安装sublimeREPL
- 3、添加快捷键（f5键）

有时候ctrl+B后会出现控制台，但是关闭有些麻烦，快捷键ctrl+\`。

# 3、Python zip() 函数
```
>>>a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
>>> zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
>>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
```

# 4、范数
[范数&距离](https://blog.csdn.net/Yaphat/article/details/53304255)
[几种范数的简单介绍](https://blog.csdn.net/shijing_0214/article/details/51757564)

### 范数
范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。

说白了：常用欧式距离，即平方差（方差）就是L2范数。
- L1范数:  ||x|| 为x向量各个元素绝对值之和。 
- L2范数:  ||x||为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或者Frobenius范数 
- Lp范数:  ||x||为x向量各个元素绝对值p次方和的1/p次方 
- L∞范数:  ||x||为x向量各个元素绝对值最大那个元素的绝对值


# 5、支持度、置信度、提升度
[数据挖掘关联分析中的支持度、置信度和提升度](https://www.jianshu.com/p/dc053deb94f2)

- 联系：关联规则或频繁项集
- 关联分析：两个变量之间A、B
- 项在事务中出现比不出现更重要，因此项是非对称的的二元变量。
- 事务的宽度：事务中出现的项的个数
- A对B的置信度：做了A事务的人有多少概率也会做B事务。
- 为啥有提升度：查看A、B是否联系-相关、排斥、无关
- 提升度受零事务影响大
- KULC度量+不平衡比（IR） 。它们可以有效的降低零事务造成的影响。
- KULC = 两个置信度的均值
- IR = 两个置信度的比值
- 置信度就是贝叶斯公式啊


Support（支持度）：表示同时包含A和B的事务占所有事务的比例。如果用P(A)表示使用A事务的比例，那么Support=P(A&B)

Confidence（置信度）：表示使用包含A的事务中同时包含B事务的比例，即同时包含A和B的事务占包含A事务的比例。公式表达：Confidence=P(A&B)/P(A)=P(B|A)

Lift（提升度）：表示“包含A的事务中同时包含B事务的比例”与“包含B事务的比例”的比值。公式表达：Lift=( P(A&B)/P(A))/P(B)=P(A&B)/P(A)/P(B)。

提升度反映了关联规则中的A与B的相关性，提升度>1且越高表明正相关性越高，提升度<1且越低表明负相关性越高，提升度=1表明没有相关性。

## 例子

## 置信区间
获得一个区间，例如，对这个问题的一个可能的答案是：「我 95％ 相信在美国足球爱好者的比例是 58％ 至 62％」。这就是置信区间名字的来源，我们有一个区间，并且我们对它此一定的信心。

# 贝叶斯公式
贝叶斯定理由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。按照乘法法则，可以立刻导出：P(A∩B) = P(A)*P(B|A)=P(B)*P(A|B)。如上公式也可变形为：P(B|A) = P(A|B)*P(B) / P(A)。



# 技巧
 - pd.set_option('display.max_columns', None)   强制显示所有属性值
 - label = df['TARGET']    dataframe对大小写非常敏感，写成TARGeT就会报错
 - axis = 1是对列进行操作
 - drop函数删除相应的行和列
 - iloc表示下标访问，loc是条件访问
df.loc[df['a']>3, 'a'] = df['a'] / 3
print(df)
 - apply函数和lambda函数常常一起使用
 - reset_index()重构索引，重构索引后会自动增加一列index(原始)，需要删除

# 

# 6、数据诊断
数量（样本）、值数量（范围）、是否有零值、数据类型、mean平均数值、median中位数、mode众数、mode_percent众数比例

零值、异常值

了解特征的分布、缺失和异常的情况。
缺失值填充：-1、0、1、中位数、众数、平均值

numpy:数组、列表
pandas:把数据读成dataframe形式，读写
scipy:计算，函数，众数等计算

导入division确保一个数除以另外一个数不等于0，返回值是一个浮点型的数
导入pd，np，scipy中的stats函数

```
依赖包的导入
# coding:utf-8
from __future__ import division
import numpy as np
import pandas as pd
from scipy import stats
```

统计指标介绍：
- 均值/中位数/最大值/最小值等
- 计数类：多少0值，多少1值，多少缺失值.....
- 缺失值/方差等：当某个特征的方差为0，则这个特征无效基本相同；缺失值过多可删除
- 分位点/值的频数等：

##1.Basic Analysis##
#(1)Missing Value#
missSet = [np.nan, 9999999999, -999999]

#(2)Count distinct#
len(df.iloc[:, 0].unique())
count_un = df.iloc[:,0:3].apply(lambda x:len(x.unique()))

#(3)Zero Values#
np.sum(df.iloc[:0] == 0)
count_zero = df.iloc[:, 0:3].apply(lambda x:np.sum(x == 0))


# describe()函数
https://blog.csdn.net/g_66_hero/article/details/72899377
生成描述性统计，总结数据集分布的中心趋势，分散和形状，不包括NaN值。
对于数值数据，结果的索引将包括计数，平均值，标准差，最小值，最大值以及较低的百分位数和50。默认情况下，较低的百分位数为25，较高的百分位数为75.50百分位数与中位数相同。
       
对于对象数据（例如字符串或时间戳），结果的索引将包括count，unique，top和freq。顶部是最常见的价值。频率是最常见的频率。时间戳还包括第一个和最后一个项目。

可以使用include和exclude参数来限制DataFrame中哪些列被分析输出。分析系列时，参数将被忽略。

describe()函数自动计算的字段有count（非空值数）、unique（唯一值数）、top（频数最高者）、freq（最高频数）、mean（平均值）、std（方差）、min（最小值）、50%（中位数）、max（最大值

# Series和Dataframe的区别
https://geektutu.com/post/pandas-dataframe-series.html
DataFrame和Series是pandas中最常见的2种数据结构。DataFrame可以理解为Excel中的一张表，Series可以理解为一张Excel表的一行或一列数据。
Series可以理解为一维数组numpy.array，它和一维数组的区别，在于Series具有索引。
```
s1=pd.Series([1,2,4,6,7,2])
s2=pd.Series([4,3,1,57,8],index=['a','b','c','d','e'])
```
定长的字典。
DataFrame相当于表格，有行表头和列表头。
series可以看做一个一维的字典，而dataframe可以看作是一个多维的字典。
# astype、dtype
- ndim返回的是数组的维度，返回的只有一个数，该数即表示数组的维度。
- shape：表示各位维度大小的元组。返回的是一个元组。
- dtype：一个用于说明数组数据类型的对象。返回的是该数组的数据类型。由于图中的数据都为整型，所以返回的都是int32。如果数组中有数据带有小数点，那么就会返回float64。
- astype：转换数组的数据类型。

# factorize()函数
factorize函数可以将Series中的标称型数据映射称为一组数字，相同的标称型映射为相同的数字。
factorize函数的返回值是一个tuple（元组），元组中包含两个元素。
第一个元素是一个array，其中的元素是标称型元素映射为的数字(从0开始)；
第二个元素是Index类型，其中的元素是所有标称型元素，没有重复。

# 标称型数据和数值型数据
在学习机器学习的工程中，发现有一种名为标称型的数据，具体如下：

标称型：一般在有限的数据中取，而且只存在‘是’和‘否’两种不同的结果（一般用于分类）

数值型：可以在无限的数据中取，而且数值比较具体化，例如4.02,6.23这种值（一般用于回归分析）

# 判断两个数是否相等用异或运算啊
# 判断一个数是否为奇数&1
# 一个数乘以或者除以2则左移右移

# __future__模块
从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用'xxx'表示str，Unicode字符串用u'xxx'表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u'xxx'和'xxx'是完全一致的，而在2.x中以'xxx'表示的str就必须写成b'xxx'，以此表示“二进制字符串”。

要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。

Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。

# 混淆矩阵
混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。 在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类相比较计算的。

# 范数 
范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。

# 凡是出现-1.#IND00.基本可以肯定是发生了除0错误。



# groupby
```
import pandas as pd
import numpy as np

df = pd.DataFrame({'key1' : ['a', 'a', 'b', 'b', 'a'],
    'key2' : ['one', 'two', 'one', 'two', 'one'],
    'data1' : np.random.randint(0, 9),
    'data2' : np.random.randint(0, 9)})
df


# 使数据data1列按照key1进行分组
grouped = df['data1'].groupby(df['key1'])  # 需要注意grouped的数据类型，它不在是一个数据框，而是一个GroupBy对象。
grouped

# 遍历
for name, group in grouped:
    print(name)
    print(group)

# 做其他计算
grouped.mean()
```
看一个大佬的代码语句：
>train_df.groupby('pred_len')['label'].agg({'mean','count'}).reset_index().sort_values(by='mean', ascending=False)

```
import pandas as pd
import numpy as np

df = pd.DataFrame({'key1' : ['a', 'a', 'b', 'b', 'a'],
    'key2' : ['one', 'two', 'one', 'two', 'one'],
    'data1' : np.random.randint(0, 9),
    'data2' : np.random.randint(0, 9)})
df
```



# nunique
nuinque()是查看该序列(axis=0/1对应着列或行)的不同值的数量。用这个函数可以查看数据有多少个不同值。


# stack()、hstack()、vstack()
## stack()
stack的意思是堆叠，堆积，unstack即“不要堆叠”，我对两个函数是这样理解和区分的。
https://www.cnblogs.com/bambipai/p/7658311.html

## hstack()
水平(按列顺序)把数组给堆叠起来，vstack()函数正好和它相反。

## vstack()
垂直（按照行顺序）的把数组给堆叠起来。

# replace
str.replace(old, new[, max])
参数
old -- 将被替换的子字符串。
new -- 新字符串，用于替换old子字符串。
max -- 可选字符串, 替换不超过 max 次

# This is beacause...
 It/This/That is because……，该句型是because 引导的表语从句。
 
 通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。
 
 # first和firstly的区别是什么?
first：可以做名词，副词，形容词，第一，首先。除了用于开场白，还有第一的意思 。firstly ：形容词，强调第一个（做完的），最先的。

注意事项：
当first和firstly作副词用的时侯，如果“用于分开并依次列举所述各点”时，是没有什么区别的，可以替换。


一句话解释numpy.meshgrid()——生成网格点坐标矩阵。
关键词：网格点，坐标矩阵
