---
layout: '[default_layout]'   
title: 菜鸟教程之C++基础（上）
date: 2018-03-20 10:02:41  
updated: 
permalink: 
render_drafts: true
copyright: true
password: 
comments: true
toc: true                  
tags:                        
- C/C++

categories:                  
- C/C++

---
# 1、前言
- 中级语言(综合了高级语言和低级语言的特点。)
 - Bjarne Stroustrup(本贾尼·斯特劳斯特卢普)
 - AT&T公司1979 年在贝尔实验室
 - 面向对象运行于多种平台上
 - 编译式、大小写敏感
 - 带类的C超集
 - 支持过程化编程、面向对象编程和泛型编程
注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。
<!--more-->

# 2、C++中"\n"与endl的区别是什么?
```
"\n" 表示内容为一个回车符的字符串。std::endl 是流操作子，输出的作用和输出 "\n" 类似，但可能略有区别。

std::endl 输出一个换行符，并立即刷新缓冲区。

例如:

std::cout << std::endl;
相当于:

std::cout << '\n' << std::flush;
或者
std::cout << '\n'; std::fflush(stdout);
由于流操作符 << 的重载，对于 '\n' 和 "\n"，输出效果相同。

对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于 cout 来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用 endl 代替 '\n' 一般是个好习惯。

对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用 '\n'。
```

# 3、面向对象开发的四大特性（我希望学完后懂得）
封装、抽象、继承、多态
>gcc main.cpp -lstdc++ -o main

g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：
>g++ -g -Wall -std=c++11 main.cpp

[g++ 常用命令选项](http://www.runoob.com/cplusplus/cpp-environment-setup.html)

# 4、什么是类、对象、方法、即时变量
- 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- 类 - 类可以定义为描述对象行为/状态(属性)的模板/蓝图。
- 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。(似乎不和临时变量对应)

# 5、C++ 标识符
C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C++ 标识符内不允许出现标点字符，比如 @、& 和 %。C++ 是区分大小写的编程语言。

C/C++可以使用带有 $ 的标识符，$ 可以放在前面，即开头。

# 6、C++关键字
## asm
## enum
## operator
## throw、catch、export、try异常示例
## explicit
## extern
变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。
```
//变量在头部就已经被声明，但它们是在主函数内被定义和初始化的
#include <iostream>
using namespace std;
 
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0;
}
```
## register
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
```
{
   register int  miles;
}
```
寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。
## typeid
## reinterpret_cast
## typrname
## union
## friend
友元函数是指某些虽然不是类成员却能够访问类的所有成员的函数。类授予它的友元特别的访问权。通常同一个开发者会出于技术和非技术的原因，控制类的友元和成员函数（否则当你想更新你的类时，还要征得其它部分的拥有者的同意）。
1）必须在类的说明中说明友元函数，说明时以关键字friend开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括在private和public部分；
2）注意友元函数不是类的成员函数，所以友元函数的实现和普通函数一样，在实现时不用"::"指示属于哪个类，只有成员函数才使用"::"作用域符号；
3）友元函数不能直接访问类的成员，只能访问对象成员，
4）友元函数可以访问对象的私有成员，但普通函数不行；
5）调用友元函数时，在实际参数中需要指出要访问的对象，
6）类与类之间的友元关系不能继承。
7）一个类的成员函数也可以作为另一个类的友元，但必须先定义这个类。

## const_cast、const
## virtual
## thread_local 
使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

thread_local 说明符可以与 static 或 extern 合并。

可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。
## static、static_cast
static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

静态局部变量
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 我们先举一个静态局部变量的例子，如下：
```
#include <iostream>

void fn();
int main()
{
    fn();
    fn();
    fn();
}
void fn()
{
    static int  n=10;
    std::cout<<n<<std::endl;
    n++;
}
```
通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。

通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。

静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

静态局部变量有以下特点：

该变量在全局数据区分配内存；
静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
## volatile
限定符
## wchar_t
宽字符
## mutable
mutable 说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。
## dynamic_cast

# 7、代码太长了，一行写不下，用什么连接符号？
- C/C++中可以用 \
- 在VB中用 _
- python里用\和()两种方法

# 8、[三字符组（过时）](http://www.runoob.com/cplusplus/cpp-basic-syntax.html)
三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。

三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。

三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。

# 9、在 c++ 中 main 函数前面为什么要加上数据类型比如 int void ?

main函数的返回值是返回给主调进程，使主调进程得知被调用程序的运行结果。

标准规范中规定main函数的返回值为int，一般约定返回0值时代表程序运行无错误，其它值均为错误号，但该约定并非强制。

如果程序的运行结果不需要返回给主调进程，或程序开发人员确认该状态并不重要，比如所有出错信息均在程序中有明确提示的情况下，可以不写main函数的返回值。在一些检查不是很严格的编译器中，比如VC, VS等，void类型的main是允许的。不过在一些检查严格的编译器下，比如g++, 则要求main函数的返回值必须为int型。

所以在编程时，区分程序运行结果并以int型返回，是一个良好的编程习惯。

# 10、块注释符（/*...*/）是不可以嵌套使用的。

此外，我们还可以使用 #if 0 ... #endif 来实现注释，且可以实现嵌套，格式为：
```
#if 0
   code
#endif 
```
你可以把 #if 0 改成 #if 1 来执行 code 的代码。

这种形式对程序调试也可以帮助，测试时使用 #if 1 来执行测试代码，发布后使用 #if 0 来屏蔽测试代码。

#if 后可以是任意的条件语句。

这个比#ifdef好用。

# 11、[宽字符](https://www.cnblogs.com/limera/p/wchar.html)
用多个字节来代表的字符称之为宽字符。

不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。

变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。

变量左值可以出现在等式的左边或者右边。出现在左边可以用来判锻NULL，以防出现逻辑错误.在实际项目中，为了防止将“==”误写作“=”推荐讲变量名写在右侧，编译器可以帮助寻找错误.

# 12、变量作用域
当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化。
在程序中，局部变量和全局变量的名称可以相同。
但是在函数内的局部变量与全局变量是两个独立的变量，互不影响。

若要想让 main 函数也使用全局变量 a，可以用 extern 对全局变量进行声明，就可以合法使用了。
```
include<iostream>
using namespace std;

int main()
{
     extern int a;
     cout<<"a= "<<a<<endl; //合法，输出10
     return 0;
}
int a=10; //全局变量从此处定义
```

# 13、整数常量
整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

下面列举几个整数常量的实例：
```
212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀
```
# 14、字符常量
字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 char 类型的简单变量中。

# 15、 C++ 修饰符类型
C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。

修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。

修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。

C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。
```
unsigned x;
unsigned int y;
```

# 16、C++ 中的类型限定符
类型限定符提供了变量的额外信息。

|限定符| 含义|
|:----:|:----:|
|const |const 类型的对象在程序执行期间不能被修改改变。|
|volatile |   修饰符 volatile 告诉编译器，变量的值可能以程序未明确指定的方式被改变。|
|restrict |   由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。|

C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 1 是个构造器 ，2 是个默认且隐含的类型转换操作符。

所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。

这样看起来好象很酷， 很方便。 但在某些情况下（见下面权威的例子）， 却违背了我们（程序员）的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。

## explicit构造函数的作用

解析：

explicit构造函数是用来防止隐式转换的。请看下面的代码：
```
class Test1
{
public:
    Test1(int n)
    {
        num=n;
    }//普通构造函数
private:
    int num;
};
class Test2
{
public:
    explicit Test2(int n)
    {
        num=n;
    }//explicit(显式)构造函数
private:
    int num;
};
int main()
{
    Test1 t1=12;//隐式调用其构造函数,成功
    Test2 t2=12;//编译错误,不能隐式调用其构造函数
    Test2 t2(12);//显式调用成功
    return 0;
}
```
Test1的构造函数带一个int型的参数，代码23行会隐式转换成调用Test1的这个构造函数。而Test2的构造函数被声明为explicit（显式），这表示不能通过隐式转换来调用这个构造函数，因此代码24行会出现编译错误。

普通构造函数能够被隐式调用。而explicit构造函数只能被显式调用。

## volatile 往往会用于多线程的修饰，比如：
```
volatile boolean isNext = false;

Thread A（） {
    // 第一个工作
    // isNext = true;
}

Thread B （）{
    if (isNext) {
        // 第二个工作
    }
}
```
这里volatile 就是从来标记isNext， 以确保线程B每次都重新从内存中读取isNext的值，第二个工作一定在第一个工作之后进行。

但是要注意，这里无法保证顺序性，应该编译器编译的时候会重新打乱两个语句的先后顺序，因此做第一个工作和赋值给isNext不一定会按照你代码顺序正常执行。

# 17、三目运算符
```
#include<iostream>
using namespace std;

int main(){
    int a,b,c,d,max;
    cout<<"请输入三个数字：";
    cin>>a>>b>>c;
    max=(d=a>=b?a:b)>=c?d:c;
    cout<<"最大值为："<<max<<endl;
    return 0;
}
```

# 18、[Lambda 函数与表达式](http://www.runoob.com/cplusplus/cpp-functions.html)
C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。

Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:

[capture](parameters)->return-type{body}
例如：

[](int x, int y){ return x < y ; }
如果没有返回值可以表示为：

[capture](parameters){body}
例如：

[]{ ++global_x; } 
在一个更为复杂的例子中，返回类型可以被明确的指定如下：

[](int x, int y) -> int { int z = x + y; return z + x; }
本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。

如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

[this]() { this->someFunc(); }();

# 数字运算
```
double hypot(double, double);
该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。

int abs(int);
该函数返回整数的绝对值。

double fabs(double);
该函数返回任意一个十进制数的绝对值。

int floor(double);
该函数返回一个小于或等于传入参数的最大整数。

int ceil(double);
该函数返回一个大于或等于传入参数的最小整数。

使用了 setw() 函数来格式化输出。
```

# 19、字符串与vector
字符串字面值与标准库string不是同一种类型
```
string s("hello");
cout<<s.size()<<endl;        //OK
cout<<"hello".size()<<endl;  //ERROR
cout<<s+"world"<<endl;       //OK
cout<<"hello"+"world"<<endl; //ERROR
strlen、sizeof与size()求字符串长度的区别
cout<<strlen("123")<<endl;   //返回 3
cout<<sizeof("123")<<endl;   //返回 4
string s = "123";
cout<<s.size()<<endl;        //返回 3
```
标准string库中的getline函数返回时会丢弃换行符
## const iterator与const_iterator的区别
```
vector<int>::const_iterator //不能改变指向的值，自身的值可以改变
const vector<int>::iterator //可以改变指向的值，自身的值不能改变
const vector<int>::const_iterator //自身的值和指向的值都是只读的
```
任何改变vector长度的操作都会使已存在的迭代器失效。如：在调用push_back之后，就不能再信赖指向vector的迭代器了
```
vector<int> ivec;
ivec.push_back(10);
vector<int>::iterator it = ivec.begin();
cout<<*it<<endl;
ivec.push_back(9);
cout<<*it<<endl;      //迭代器已经失效
```

序号  函数 & 目的
1   strcpy(s1, s2);复制字符串 s2 到字符串 s1。
2   strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。
3   strlen(s1);返回字符串 s1 的长度。
4   strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。
5   strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
6   strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

# 20、C++ 引用 vs 指针
引用很容易与指针混淆，它们之间有三个主要的不同：

不存在空引用。引用必须连接到一块合法的内存。
一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
引用必须在创建时被初始化。指针可以在任何时间被初始化。

# 21、日期和时间
有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。

结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：

struct tm {
  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
  int tm_min;   // 分，范围从 0 到 59
  int tm_hour;  // 小时，范围从 0 到 23
  int tm_mday;  // 一月中的第几天，范围从 1 到 31
  int tm_mon;   // 月，范围从 0 到 11
  int tm_year;  // 自 1900 年起的年数
  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
  int tm_isdst; // 夏令时
}

序号  函数 & 描述
1   time_t time(time_t *time);
该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。
2   char *ctime(const time_t *time);
该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。
3   struct tm *localtime(const time_t *time);
该函数返回一个指向表示本地时间的 tm 结构的指针。
4   clock_t clock(void);
该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。
5   char * asctime ( const struct tm * time );
该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。
6   struct tm *gmtime(const time_t *time);
该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。
7   time_t mktime(struct tm *time);
该函数返回日历时间，相当于 time 所指向结构中存储的时间。
8   double difftime ( time_t time2, time_t time1 );
该函数返回 time1 和 time2 之间相差的秒数。
9   size_t strftime();
该函数可用于格式化日期和时间为指定的格式。

```
#include <iostream>
#include <ctime>
 
using namespace std;
 
int main( )
{
   // 基于当前系统的当前日期/时间
   time_t now = time(0);
   
   // 把 now 转换为字符串形式
   char* dt = ctime(&now);
 
   cout << "本地日期和时间：" << dt << endl;
 
   // 把 now 转换为 tm 结构
   tm *gmtm = gmtime(&now);
   dt = asctime(gmtm);
   cout << "UTC 日期和时间："<< dt << endl;
}
```

# 22、标准输入输出
cin、cout、cerr、clog
每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。

# 23、结构体
C 语言的 struct 定义了一组变量的集合，C 编译器并不认为这是一种新的类型。

C++ 中的 struct 是一个新类型的定义声明, 所以可以省略 typedef, 定义变量的时候也可以省略 struct, 而不用向c语言那样没用 typedef 取新名字, 就需要用 struct 结构体名 这种形式定义变量。

## 类与结构体在C++中只有两点区别，除此这外无任何区别。　
（1）class中默认的成员访问权限是private的，而struct中则是public的。　　
（2）从class继承默认是private继承，而从struct继承默认是public继承。

