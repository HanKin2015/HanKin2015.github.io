---
layout: '[default_layout]'   
title: 问题技巧汇总           
date: 2018-07-06 10:47:41  
updated: 
permalink: 
render_drafts: true
copyright: true
password: 
comments: true
toc: true                  
tags:                        
- C
- C++
- Python

categories:                  
- OTHER

---
# 1、vector数组的初始化和清零
clear不能清除干净
is_meet.assign(max_memory, 0); //改成全局变量了，记得清理，clear()并没有什么卵用，这个应该当作初始化
<!--more-->


# 2、python代码报错：ParserError: Error tokenizing data. C error: Expected 1 fields in line 122, saw 2

解决方法：
加入参数error_bad_lines=False

# 3、利用Pandas读取文件路径或文件名称包含中文的csv文件
f=open('E:/学习相关/Python/数据样例/用户侧数据/账单.csv')
df=pd.read_csv(f)


# 4、vector空间的动态增长
```
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> a;
    cout << "a.size(): " << a.size() << "       a.capacity(): " << a.capacity() << endl;
    for (int i = 0; i < 10; i++)
    {
        a.push_back(i);
        cout << "a.size(): " << a.size() << "   a.capacity(): " << a.capacity() << endl;
    }
    cout << endl;
    vector<int> b;
    b.reserve(10);
    for (int i = 0; i < 10; i++)
    {
        b.push_back(i);
        cout << "b.size(): " << b.size() << "   b.capacity(): " << b.capacity() << endl;
    }
    b.push_back(11);
    cout << "b.size(): " << b.size() << "       b.capacity(): " << b.capacity() << endl;
    cout << endl;
    b.reserve(15);
    cout << "after b.reserve(15):" << endl;
    cout << "b.size(): " << b.size() << "       b.capacity(): " << b.capacity() << endl;
    b.resize(5);
    cout << "after b.resize(5):" << endl;
    cout << "b.size(): " << b.size() << "       b.capacity(): " << b.capacity() << endl;
    return 0;
}
```
为啥在vs中的增长是1.5倍[STL vector(四) vector 扩容为什么要以1.5倍或者2倍扩容](https://blog.csdn.net/dengheCSDN/article/details/78985684)

# 5、size_type和size_t的的区别
由string类类型和vector类类型定义的类型，用以保存任意string对象或vector对象的长度，标准库类型将size_type定义为unsigned类型，string抽象意义是字符串， size()的抽象意义是字符串的尺寸， string::size_type抽象意义是尺寸单位类型。

string::size_type从本质上来说，是一个整型数。关键是由于机器的环境，它的长度有可能不同。 例如：我们在使用 string::find的函数的时候，它返回的类型就是 string::size_type类型。而当find找不到所要找的字符的时候，它返回的是 npos的值，这个值是与size_type相关的。假如，你是用 string s; int rc = s.find(.....); 然后判断，if ( rc == string::npos ) 这样在不同的机器平台上表现就不一样了。如果，你的平台的string::size_type的长度正好和int相匹配，那么这个判断会侥幸正确。但换成另外的平台，有可能 string::size_type的类型是64位长度的，那么判断就完全不正确了。 所以，正确的应该是： string::size_type rc = s.find(.....); 这个时候使用 if ( rc == string::npos )就回正确了。

st.size()表示st中的字符数量，字符数量的统计是由 1 开始累计计算的，所以字符数量正好比字符串的下标索引数（由 0 开始累计计算）大 1 ，这里的index != st.size();的效果等同于index < st.size();
 
size_t不是容器概念。
size_type是容器概念，没有容器不能使用。
见例程：
```
#include<iostream>  
#include<vector>  
using namespace std;  
int main()  
{  
 cout<<" typeid(size_t).name() = "<<typeid(size_t).name()<<endl;  
 cout<<" typeid(vector<int>::size_type).name() = "<<typeid(vector<int>::size_type).name()<<endl;  
  
 return 0;  
}   
```

from:http://blog.sina.com.cn/s/blog_5ff6e6ed0100da4j.html
 
先是看到了在看标准库string时size_type，后来在学习标准库bitset的时候有碰到了size_t，晕啊
标准库string里面有个函数size，用来返回字符串中的字符个数，具体用法如下：
```
string st("The expense of spirit/n");
cout << "The size of "<<st<<"is"<<st.size() << "characters, including the newline"<<endl;
```

size_type被定义为与unsigned型（unsigned int, unsigned long）具有相同的含义，而且可以保证足够大能够存储任意string对象的长度。为而来使用由string类型定义的size_type类型。程序员必须加上作用于操作符来说明所使用的size_type类型是由string类定义的。

## 我们为什么不适用int变量来保存string的size呢？
使用int变量的问题是：有些机器上的int变量的表示范围太小，甚至无法存储实际并不长的string对象。如在有16位int型的机器上，int类型变量最大只能表示32767个字符的string对象。而能容纳一个文件内容的string对象轻易就能超过这个数字，因此，为了避免溢出，保存一个string对象的size的最安全的方法就是使用标准库类型string：：size_type().
一点注意：虽然是在学习标准库string的时候巧遇了size_type类型，但是，其实vector库也可以定义size_type类型，在vector库中还有一个difference_type类型，该类型用来存储任何两个迭代器对象间的距离，所以是signed类型的。

## 什么是size_t类型呢？其实本质上和size_type没有多大区别
其实size_t和size_type类似，size_t 类型定义在cstddef头文件中,该文件是C标准库的头文件stddef.h的C++版本.它是一个与机器相关的unsigned类型,其大小足以保证存储内存中对象的大小。用法如下：
```
bitset<32> bitvec;
size_t sz=bitvec.size();
```
另外sizeof操作符的返回值的类型也为size_t哦

# 6、BitSet
C++语言的一个类库，用来方便地管理一系列的bit位而不用程序员自己来写代码。
bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计。

可以如下声明一个该类型变量：
```
bitset<N>varm (M)
其中varm为变量名。
N表示该类型在内存中占的位数，是二进制。
M表示变量varm的初始值。
```

用整值类型表示位向量的问题在于：使用位操作符来设置复位和测试单独的位层次比较低也比较复杂.
例如：用整值类型将第27 位设置为1, 我们这样写
quizl |= 1<<27;
而用bitset 来做我们可以写
quizl[ 27 ] = 1;
或
quizl.set( 27 );
要使用bitset 类我们必须包含相关的头文件
#include <bitset>

# 7、Bitmap
# 8、map的遍历
```C++
map<string, int> m;
for (auto it = m.begin(); it != m.end(); it++) {
	it->first;
	it->second;
}
```

# 9、C/C++库函数（tolower/toupper）实现字母的大小写转换
```c++
char str[] = "THIS IS A STRING";
for (i = 0; i < strlen(str); i++) {
        str[i] = tolower(str[i]);
}
```
```c++
#include <sstream>
stringstream ss;
int i = 10;
ss << i;
string str = ss.str();

itoa(i, str, 10);
```
# 10、swtich和case语句中，定义变量要加花括号
报错：hankin.cpp:14:8: 错误： 跳转至 case 标号 [-fpermissive]
原因：系统不允许我们在case中定义一个变量，原因是我们在一个case中定义的变量，假如在另一个case中被使用就会出现错误，因为一般来说switch语句中的case只能被执行一个。
但是我们假如是想要定义一个在case中使用的临时变量，那该怎么办呢。当然是有办法的其实也很简单就是我们在写case语句时给每一个case加一个大括号就行了。

# 11、输入字符串中有空格的时候(gets and getline)
```c++
const int maxn = 1e5 + 5;
char s1[maxn];
string s2;
cin.getline(s1, maxn);
getline(cin, s2);
gets(s1);
```