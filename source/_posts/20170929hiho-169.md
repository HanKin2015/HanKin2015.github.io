---
layout: '[default_layout]'   
title:  hiho一下 第169周 简单计算器               
date: 2017-09-29 21:30:41  
toc: true                  
tags:                        
- hihoCoder

categories:                  
- 

---

[TOC]

## 题目1 : 简单计算器
时间限制:10000ms
单点时限:1000ms
内存限制:256MB

## 描述
编写一个程序可以完成基本的带括号的四则运算。其中除法(/)是整除，并且在负数除法时向0取整。(C/C++/Java默认的除法就是向0取整，python默认的是向负无穷取整。)

例如计算 100 * ( 2 + 12 ) - (20 / 3) * 2, 结果是1388。

<!-- more  -->

## 输入
一个长度不超过100的字符串，代表要计算的算式。包含数字0-9以及+-*/()。

输入保证计算过程不会超过32位有符号整数，并且其中的'-'都是减号没有负号。

## 输出
计算的结果。

## 样例输入
    100*(2+12)-(20/3)*2

## 样例输出
    1388

## 思路
输入的是中缀表达式，计算机计算需要将中缀表达式转换成前缀或后缀表达式，即波兰式或逆波兰式。

## CODE:中缀表达式、逆波兰式、栈、队列
{% codeblock hiho-169.cpp %}
#include <iostream>
#include <queue>
#include <stack>
#include <cstring>
#include <bits/stdc++.h>
using namespace std;

string operators[4] = {"+", "-", "*", "/"}; // 四则运算符

// 比较两个操作符的优先级
int judge(string op1, string op2) {
    if(op1 == "(") return -1;
    else if(op1 == "+" || op1 == "-") {
        if(op2 == "*" || op2 == "/")  return -1;
        else return 0;
    }
    if(op1 == "*" || op1 == "/") {
        if(op2 == "+" || op2 == "-") return 1;
        else return 0;
    }
}

bool IsOperator(string str) {
    for(int i = 0; i < 4; i++) {
        if(str == operators[i])
            return true;
    }
    return false;
}

// 后缀表达式求值程序
int Calculate(queue<string> postFix) {
    stack<string> S;

    while(!postFix.empty()) {
        string tmp = postFix.front();
        if(!IsOperator(tmp)) {  // 如果是数字就进栈
            S.push(tmp);
        }
        else {
            string strA, strB;
            int intA, intB;
            int ans;
            char* end;

            strB = S.top();
            intB = static_cast<int>(strtol(strB.c_str(),&end,10));
            S.pop();
            strA = S.top();
            intA = static_cast<int>(strtol(strA.c_str(),&end,10));
            S.pop();

            if(tmp == "+") ans = intA + intB;
            else if(tmp == "-") ans = intA - intB;
            else if(tmp == "*") ans = intA * intB;
            else ans = intA / intB;

            stringstream ss;
            int t = ans;
//            cout << t << endl;
            ss << ans;
            S.push(ss.str());
            ss.str("");
        }
        postFix.pop();
    }
    cout << S.top() << endl;
    return 0;
}

// 中缀表达式转换成后缀表达式
void Infix_to_Postfix(queue<string> inFix) {
    queue<string> Q;
    stack<string> S;

    while(!inFix.empty()) {
        string  str = inFix.front();
        if(str == "(") S.push(str);
        else if(str == ")") {
            while(S.top() != "(") {
                Q.push(S.top());
                S.pop();
            }
            S.pop();
        }
        else {
            if(!IsOperator(str))
                S.push(str);
            else {
                while(!S.empty() && judge(S.top(), str) >= 0) {
                    Q.push(S.top());
                    S.pop();
                }
                S.push(str);
            }
        }
        inFix.pop();
    }

    while(!S.empty()) {
        Q.push(S.top());
        S.pop();
    }
    Calculate(Q);

//    cout << "后缀表达式：" << endl;
//    while(!Q.empty()) {
//        cout << Q.front() << " ";
//        Q.pop();
//    }
//    cout << endl;
    return ;
}

void Infix_to_Queue(char formula[]) {
    queue<string> inFix;
    int len = strlen(formula);
    string str = "";
    for(int i = 0; i < len; i++) {
        if(formula[i] > '9' || formula[i] < '0') {
            if(str != "") {
                inFix.push(str);
                str = "";
            }
            str += formula[i];
            inFix.push(str);
            str = "";
            continue;
        }
        str += formula[i];
    }
    if(str != "") inFix.push(str);

    Infix_to_Postfix(inFix);

//    while(!inFix.empty()) {
//        str = inFix.front();
//        cout << str << " ";
//        inFix.pop();
//    }
    return ;
}

int main()
{
    char formula[105];
    cin >> formula;
    Infix_to_Queue(formula);
    return 0;
}
{% endcodeblock %}

