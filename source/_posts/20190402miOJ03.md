---
layout: '[default_layout]'   
title: 小米 OJ 编程比赛 03 月常规赛
date: 2019-04-02 10:47:41  
updated: 
permalink: 
render_drafts: true
copyright: true
password: 
comments: true
toc: true
mathjax: true        
tags:                        
- C
- C++

categories:                  
- C/C++

---
[小米 OJ 编程比赛 03 月常规赛](https://code.mi.com/contest/list/view?id=9)

<--more-->


# 1、数学等式	
给出5个系数，求等式的另外5个未知数，问有多少解？
巧枚举。
```
#include <bits/stdc++.h>
//#include <unordered_map>
using namespace std;

int cal(int n)
{
	return n * n * n;
}

int main()
{
	int a, b, c, d, e;
	cin >> a >> b >> c >> d >> e;
	map<int, int> cnt;
	for (int i = -50; i <= 50; i++) {
		for (int j = -50; j <= 50; j++) {
			for (int k = -50; k <= 50; k++) {
				if (i * k * j != 0) {
					int tmp = cal(i) * a + cal(j) * b + cal(k) * c;
					cnt[tmp]++;
				}
			}
		}
	}
	long long ans = 0;
	for (int i = -50; i <= 50; i++) {
		for (int j = -50; j <= 50; j++) {
			if (i * j != 0) {
				int tmp = cal(i) * d + cal(j) * e;
				ans += cnt[tmp];
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```


# 2、贪吃的细胞		
多点宽搜BFS，但是不明白哪里错了，自己感觉没有问题，错的也莫名其妙（后来终于有解答了）。
下面是别人AC的代码，感觉小米这个oj能看别人的代码这个功能不错。


针对 03 月 29 日晚「三月常规赛」第二题“贪吃的细胞”出错的情况，现给出如下说明：

由于题目“贪吃的细胞”出题、审题人及我们团队的疏忽，此题的数据及标程出现问题却未被发现，导致「三月常规赛」中第二题无法 AC，严重影响比赛体验。

在此，我们向所有参赛同学真诚道歉。我们深知，本次事件的原因在于尚不完善的志愿者机制及录题流程；我们将重新审视此机制，并尽我们最大努力保证题目的正确性及质量。

作为补偿，对于比赛期间已提交过第二题的同学，我们将补偿一定数量的 OJ 币，同时比赛奖品将正常发出，锦鲤奖也将按流程抽取。

最后，再次向同学们表示歉意。

小米 Online Judge 团队
2019 年 04 月 09 日
```
 输入、输出结果中的换行符，已使用 ";" 代替

用例输入: "40;7 31;5.#s#.6..#1.#.#..85#1#..17#4##8;9##.76##8.#.5.2##9.##3###.67.9.;#14.#1.##...8#8...8.###.#.#...."
期望输出: "-1;-1;3476;-1;-1;-1;-1;-1;-1;-1;-1;763;-1;-1;-1;-1;-1;-1;-1;-1;-1;405;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;..."
你的输出: "-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-..."
```

```
#include <bits/stdc++.h>
using namespace std;
/*
struct Node {
	int x, y;
	Node(int a=0, int b=0) : x(a), y(b) {}
};
第三题打个表输出 第n个数对应的斐波那契数列的下标 2 3 5 13 89 分别对应3 4 5 7 11 除了4 后面都是连续的素数 然后矩阵快速幂就可以了

https://www.flyai.com/?s=pmgO8ng7J
http://latex.91maths.com/
*/
typedef pair<int, int> Node;
int maxn = 1e8;
bool visited[105][105];
map<Node, Node> befor;
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
int n, m;
char mat[105][105];
int dis[105][105];
int cell[105][105];
int ans;
queue<Node> Q;

bool bfs()
{
	while (!Q.empty()) {
		Node cur = Q.front();
		Q.pop();
		for (int i = 0; i < 4; i++) {
			int next_x = cur.first + dir[i][0], next_y = cur.second + dir[i][1];
			if (next_x >= 0 && next_y >= 0 && next_y < m && next_x < n && !visited[next_x][next_y] && mat[next_x][next_y] != '#') {
				Q.push(make_pair(next_x, next_y));
				visited[next_x][next_y] = 1;
				if (dis[next_x][next_y] > dis[cur.first][cur.second] + 1) {
					dis[next_x][next_y] = dis[cur.first][cur.second] + 1;
					befor[make_pair(next_x, next_y)] = befor[cur];
				}
			}
		}
	}
	int x, y, d = maxn;
	//cout << "--------------------" << endl;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
            //cout << mat[i][j];
			if (mat[i][j] >= '0' && mat[i][j] <= '9') {   // 当前有培养液
				if (dis[i][j] < d) {
					d = dis[i][j];
					x = i;
					y = j;
				}
 			}
		}
		//cout << endl;
	}
	/*
	for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << cell[i][j];
        }
        cout << endl;
	}
	cout << d << ' ' << ans << endl;
	*/
	if (d == maxn) return false;
	ans += d;
	int xx = befor[Node(x, y)].first, yy = befor[Node(x, y)].second;
	cell[xx][yy]--;
	cell[x][y] += mat[x][y] - '0' + 1;
	mat[x][y] = '.';
	return true;
}

int main()
{
	int T;
	cin >> T;
	while (T--) {
		cin >> n >> m;
		ans = 0;
		int liquid_cnt = 0;
		memset(cell, 0, sizeof(cell));
		memset(mat, 0, sizeof(mat));
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				cin >> mat[i][j];
				if (mat[i][j] >= '0' && mat[i][j] <= '9') liquid_cnt++;
				if (mat[i][j] == 'S') {
					cell[i][j]++;
				}
			}
		}

		for (int i = 0; i < liquid_cnt; i++) {
			memset(visited, 0, sizeof(visited));
			befor.clear();
			for (int j = 0; j < n; j++) {
				for (int k = 0; k < m; k++) {
                    dis[j][k] = maxn;
					if (cell[j][k] > 0) {
						Q.push(Node(j, k));
						visited[j][k] = 1;
						dis[j][k] = 0;
						befor[Node(j, k)] = Node(j, k);
					}
				}
			}

			bool flag = bfs();
			if (!flag) {
				ans = -1;
				break;
			}
		}
		cout << ans << endl;
	}
	//pair<int, int>(2, 3) == make_pair(2, 3);
	return 0;
}
/*
1
7 10
2342312323
..........
S#########
..........
123.......
..........
123.......


1 
5 3 
#1# 
1S1 
#.# 
#.# 
#1#
*/












#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <queue>
#define max(a,b) (a>b?a:b)
using namespace std;
const int maxn=250005;
struct node {
    int x,y,l;
}k[maxn];
int t,m,n,lm,d[4][2]={1,0,-1,0,0,1,0,-1};
char mm[105][105];
void add(int u,int v,int w){
    k[lm].x=u;
    k[lm].y=v;
    k[lm].l=w;
    lm++;
}
void bfs(int s,int x,int y){
    node a,b;
    a.x=x,a.y=y,a.l=0;
    int vis[105][105]={0};
    vis[a.x][a.y]=1;
    queue<node>qu;
    qu.push(a);
    while(!qu.empty()){
        a=qu.front();
        qu.pop();
        if((mm[a.x][a.y]>='1'&&mm[a.x][a.y]<='9')||mm[a.x][a.y]=='S'){
            if(a.l)add(s,a.x*100+a.y,a.l);
        }
        b.l=a.l+1;
        for(int i=0;i<4;i++){
            b.x=a.x+d[i][0];
            b.y=a.y+d[i][1];
            if(b.x>=0&&b.x<n&&b.y>=0&&b.y<m&&!vis[b.x][b.y]&&mm[b.x][b.y]!='#'){
                vis[b.x][b.y]=1;
                qu.push(b);
            }
        }
    }
}
void make_adge(){
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            if(mm[i][j]!='#'&&mm[i][j]!='.')
                bfs(i*100+j,i,j);
}

int r[10005];
int fi(int n){
    return r[n]=r[n]==n?n:fi(r[n]);
}
int cmp(node x,node y){
    return x.l<y.l;
}
void solve(){
    int vis[10005];
    for(int i=0;i<10000;i++){
        r[i]=i;
        vis[i]=0;
		if(mm[i / 100][i % 100] == 'S') mm[i / 100][i % 100] = 47;
    }
    sort(k,k+lm,cmp);
    int out=0;
    for(int i=0;i<lm;i++){
        int fx=fi(k[i].x);
        int fy=fi(k[i].y);
        if((mm[k[i].x/100][k[i].x%100]-'0')+2==vis[k[i].x])continue ;
        if((mm[k[i].y/100][k[i].y%100]-'0')+2==vis[k[i].y])continue ;
        if(fx!=fy){
            r[fx]=fy;
            vis[k[i].x]++;
            vis[k[i].y]++;
			//printf("[%d,%d] -> [%d,%d]\n", k[i].x / 100, k[i].x % 100, k[i].y / 100, k[i].y % 100);
            out+=k[i].l;
        }
    }
    int ans=0;
    for(int i=0;i<10000;i++){
        if((mm[i/100][i%100]>='1'&&mm[i/100][i%100]<='9')||mm[i/100][i%100]==47){
            if(fi(i)==i){
                ans++;
            }
        }
    }
    if(ans!=1)out=-1;
    cout<<out<<endl;
}
int main(){
//    freopen("test0.in","r",stdin);
  //  freopen("test0.out","w",stdout);
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&m);
        memset(mm,0,sizeof(mm));
        for(int i=0;i<n;i++){
            scanf("%s",mm[i]);
        }
        lm=0;
        make_adge();
        solve();
    }
    return 0;
}
```


# 3、小爱密码 2.0
不明白什么斐波那契质数应该做不出来。
还需要求出第n个质数，需要埃拉托斯特尼筛法。
```
Fibonacci质数的定义：

若某Fibonacci数与任何比它小的Fibonacci数互质，那么它就是Fibonacci质数。
1
这里有一个结论是：
1.F(3)和F(4)是Fibonacci质数；从F(5)开始，某项为Fibonacci质数当且仅当它的项数为质数
2.第k小的Fibonacci质数是以质数数列中的第k个数为项数的Fibonacci数( 除F(3)和F(4)之外 )
证明戳这里：https://www.cnblogs.com/allensun/archive/2011/01/27/1946282.html
问题就变成了求第n个质数p，然后求F( p )/3 模m的结果，因为3和m互质，所以可以扩展欧几里得求出3的逆元，矩阵快速幂求出F( p )，就得到答案了。
--------------------- 
作者：_ 泛白 
来源：CSDN 
原文：https://blog.csdn.net/qq_43202683/article/details/88903027 
版权声明：本文为博主原创文章，转载请附上博文链接！
```














