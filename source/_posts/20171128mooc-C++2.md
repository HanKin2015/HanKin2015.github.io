---
layout: '[default_layout]'   
title: C++远征之离港篇(imooc)           
date: 2017-11-28 10:47:41  
toc: true                  
tags:          
- C++

categories:                  
- C/C++

---
简介：本课程是C++起航篇的延伸，讲述了引用、const、函数默认值、函数重载、内存管理等内容，最后通过一个通俗易懂的例子将所述知识点融会贯通，以达到知识灵活运用，最终得以升华的目的。

# 第1章 离港总动员
## 1-1 离港总动员(02:11)
- 引用VS指针
- `#define VS const`
- 函数默认值&函数重载
- 内存管理（在堆中的内存管理都是由程序员来管理，出来混总是要还的。）
- 封装 继承 多态
<!--more-->
# 第2章 C++语言引用
## 2-1 C++语言引用(08:12)
![](https://img3.mukewang.com/5a0b7c8000012c1912800720.jpg)
&符号就是取地址符号, 含义只这么一个; *符号就是创建一个指针, 或者做一次地址跳转;
在任何编程语言中, 其实一个变量都代表了一个内存上的地址.
int a = 10, 给a分配一个内存逻辑地址0x1001ff, 这个地址存放了值10;
int &b = a, 给b分配和a一样的逻辑地址0x1001ff. 因此b就是a的别名;

好了, 最难的来了. 
int a = 10;   // 给a分配一个内存逻辑地址0x100001, 这个地址存放了值10;
int *p = &a;  //创建变量p, 给p分配地址0x100002, 这个地址存放的值是"0x100001"(a的逻辑地址值);
int *&q = p;  //创建变量q, 给q分配地址也是0x100002, 因此这个地址存放的值还是a的逻辑地址值;
*q = 20;  //访问存放在q变量地址下的值, 获得了a的地址值, 再访问一下a的地址值, 修改上面的内容为20;

至此, 我觉得我基本解释清楚了&的作用机理, 它就是取地址; 而*的含义是做一次地址跳转;
### 【基本数据类型的引用】
![](https://img2.mukewang.com/59ff2f4b0001660612800720.jpg)
[类型名] &[引用名]=[目标变量名];
/*
例：
int a=3;
int &b=a;   //引用必须初始化
*/

### 变量的引用
引用是变量的别名
1 基本数据类型的引用
2 结构体类型的引用
3 指针类型的引用 （ 类型 *&指针引用名=指针）（例：int a=10;int *p=&a;int *&q=p;）
4 引用作函数参数
（例：
void fun(int &a,int &b）
{
    int c=0;
    c=a;
    a=b;
    b=c;
}

int x=10,y=20;
fun(x,y);

![](https://img3.mukewang.com/59eacde10001e37412800720.jpg)
![](https://img.mukewang.com/59bddebb0001d7fd12800720.jpg)
![](https://img4.mukewang.com/59f1b7be00017b0912800720.jpg)
![](https://img1.mukewang.com/59fad7cb0001186a12800720.jpg)

## [指针和引用的区别](http://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html)
指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；
而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。
简单点说：一个是存地址，一个是变量别名。

第3章 C++语言const关键字
3-1 C++语言-const(08:39)
![](https://img4.mukewang.com/5a1a17550001784512800720.jpg)
![](https://img2.mukewang.com/5a1a17b5000122a512800720.jpg)
![](https://img1.mukewang.com/5a1b528500012fa612800720.jpg)
![](https://img.mukewang.com/59d9ed150001ee4e12800720.jpg)
![](https://img4.mukewang.com/59cb7e51000150f112800720.jpg)
一个比较好记的方法来区分 int const *p与 int* const p，把*读作pointer to然后从后往前读.
第一个int const *p就可以读作 p is a pointer to const int，p是指向常量的指针
第二个int* const p就可以读作 p is a const pointer to int，p是指向int型的常指针

const指针主要看const修饰p还是*p，修饰p不能改变p的指向（不能使p指向其他变量），修饰*p不能改变*p的值（即p指向的变量的值）。
int* const p;int const* p; 一种限制指针指向，一种限制指向的值。

编译器不允许一个非const指针指向一个const变量（否则可以通过指针对const变量的值进行修改，存在风险）

# 第4章 C++函数新亮点
## 4-1 [C++]函数特性(11:32)
- 无实参则用默认值，否则实参覆盖默认值
- 函数中有默认值的参数必须写在参数表的最右端
- 函数重载（在相同作用域内），可以通过参数的个数和类型来把多个名字相同的函数区分开（一个函数是没有办法重载的）
- 在声明函数的时候可以添加默认值，在函数实现的时候最好不要添加默认值，有些编译器无法通过。
- 内联函数 inline 效率高 有条件（1.逻辑要简单【比如for,while循环就不行】2.不能是递归函数）

函数重载：在相同作用域内，用同一函数名定义的多个函数，参数个数和参数类型不同。
函数的重载(overload)和Java语言的函数重载一样, 函数名一致, 但是函数签名中的 返回值类型和参数是不一样的.
计算机对函数重载的区分法:
![](https://img1.mukewang.com/598fb1f400016aa012800720.jpg)

![](https://img.mukewang.com/598999760001b04b12800720.jpg)
![](https://img.mukewang.com/59a6c9670001d3ff12800720.jpg)
内联函数, 在函数签名之前要加上inline, 这样函数代码块会替换掉调用出的那行函数名, 这样减少了函数调用栈push和pop stack的开销. 

为啥不什么地方都用inline呢? 首先, inline是建议性的, 由编译器决定具体是否替换代码(递归是坚决不会进行替换的); 其次, 内联函数只适合逻辑简单, 且调用频繁(不停的call这个函数), 如果内联函数中有for, while循环的话, 往往效果不好, 不如单独给其一个函数栈来使用. 最后, 递归函数是无法使用内联方式的.

# 第5章 C++内存管理
## 5-1 [C++]内存管理(06:31)
![](https://img.mukewang.com/59e48fda000161f212800720.jpg)
C语言和c++申请和释放内存
c 是malloc free
c++是new   delete
申请内存 new运算符
释放内存 delete运算符
![](https://img.mukewang.com/59eae03300011f7812800720.jpg)
![](https://img.mukewang.com/59e34a620001e1e812800720.jpg)
![](https://img1.mukewang.com/59e34a040001865e12800720.jpg)
![](https://img3.mukewang.com/59f2e3080001480a12800720.jpg)

使用new申请内存，使用delete释放内存；
new与delete要配套使用;
申请内存需要判断是否成功，释放内存需要设空指针.

int *p = new int[1000];
delete []p;
p = NULL;

