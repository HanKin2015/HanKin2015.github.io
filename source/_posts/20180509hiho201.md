---
layout: '[default_layout]'   
title: hiho一下第201周Composition         
date: 2018-05-09 11:47:41  
updated: 
permalink: 
render_drafts: true
copyright: true
password: 
comments: true
toc: true                  
tags:                        
- Dp

categories:                  
- hihoCoder

---
# 描述
Alice writes an English composition with a length of N characters. However, her teacher requires that M illegal pairs of characters cannot be adjacent, and if 'ab' cannot be adjacent, 'ba' cannot be adjacent either.

In order to meet the requirements, Alice needs to delete some characters.

Please work out the minimum number of characters that need to be deleted.
<!--more-->
# 输入
The first line contains the length of the composition N.

The second line contains N characters, which make up the composition. Each character belongs to 'a'..'z'.

The third line contains the number of illegal pairs M.

Each of the next M lines contains two characters ch1 and ch2,which cannot be adjacent.  

For 20% of the data: 1 ≤ N ≤ 10

For 50% of the data: 1 ≤ N ≤ 1000  

For 100% of the data: 1 ≤ N ≤ 100000, M ≤ 200.

# 输出
One line with an integer indicating the minimum number of characters that need to be deleted.

# 样例提示
Delete 'a' and 'd'.

# 样例输入
>5
abcde
3
ac
ab
de

# 样例输出
> 2

## 官方分析
本题最暴力的解法就是枚举哪些字符被删掉。枚举的复杂度是O(2^N)，再加上O(N)的判断，总复杂度是O(N2^N)。

比较容易想到的是O(N^2)的DP。

由于删掉最少等价于留下最多，所以我们可以用f[i]表示最后留下一个字符是S[i]时，最多留下多少个字符。

要求f[i]，我们只需要枚举S[i]之前的一个字符是哪个，并且从中选择合法并且最优的解：

f[i] = max{f[j]} + 1, for j = 1 .. i-1且S[j]S[i]不是"illegal pair"。

以上的DP解法是O(N^2)的，仍有优化的空间。

我们求f[i]时，需要枚举之前所有的位置j，但实际上之前的字符只有'a'~'z'26种可能。对于相同的字符，我们只用考虑最后一次它出现的位置，之前的位置一定不是最优。

例如，假设s[2] = s[5] = s[8] = 'h'，那么当i>8时，我们求f[i]根本不用考虑j=2和j=5的情况，这两种情况即便合法也不会比j=8更优。

于是我们每次求f[i]只需要考虑'a'~'z'最后一次出现的位置。复杂度可以优化到O(26N)。

## CODE
```
#include <iostream>
#include <cstring>
#include <map>
#include <cmath>
#include <algorithm>
using namespace std;

int main()
{
    int N, M;
    char str[100005], str_pair[3];
    map<string, bool> illegal;
    cin >> N;
    cin >> str;
    cin >> M;
    while(M--) {
        cin >> str_pair;
        illegal[str_pair] = 1;
        string temp = "";
        temp += str_pair[1];
        temp += str_pair[0];
        illegal[temp] = 1;
    }

    int dp[100005], pos[26];
    for(int i = 0; i < 26; i++) pos[i] = -1;
    dp[0] = 1;
    pos[str[0] - 'a'] = 0;
    for(int i = 1; i < N; i++) {
        dp[i] = 1;
        for(int j = 0; j < 26; j++) {
            if(pos[j] != -1) {
                string temp = "";
                temp += str[i];
                temp += str[pos[j]];
                if(illegal[temp] != 1) {
                    dp[i] = max(dp[i], dp[pos[j]] + 1);
                }
                //else dp[i] = max(dp[i], dp[j]);  //这步有问题
                //用dp[i]表示最后留下一个字符是str[i]时，最多留下多少个字符。不留str[i]答案不就是p[i - 1]嘛
                /*基于上一行的分析，所以答案要是dp中的最大值*/
            }
        }
        pos[str[i] - 'a'] = i;   //存储字母最后出现的位置
    }
    //for(int i = 0; i < N; i++) cout << dp[i] << ' ';
    int maxn = *max_element(dp, dp + N);
    cout << N - maxn << endl;
    return 0;
}

/*
4 abcd 3
ab
dc
bc

好奇怪，错在哪里了？先优化
aabb
aaaa

4 abcd 3
ad
bd
cd
答案应该是1，dp中应该取最大值而不是最后一个值
*/
```




