<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HanKin的博客</title>
  
  <subtitle>聪明出于勤奋，天才在于积累。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hankin2015.github.io/"/>
  <updated>2018-09-29T11:31:23.414Z</updated>
  <id>https://hankin2015.github.io/</id>
  
  <author>
    <name>HanKin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据处理常用基础操作(清洗、可视化、特征工程)[置顶]</title>
    <link href="https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/"/>
    <id>https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/</id>
    <published>2222-11-10T13:47:41.000Z</published>
    <updated>2018-09-29T11:31:23.414Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h1 id="一、数据挖掘之pandas-DataFrame"><a href="#一、数据挖掘之pandas-DataFrame" class="headerlink" title="一、数据挖掘之pandas.DataFrame"></a>一、数据挖掘之pandas.DataFrame</h1><p><a href="http://www.jianshu.com/p/682c24aef525" target="_blank" rel="noopener">用python做数据分析4|pandas库介绍之DataFrame基本操作</a><br><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://old.sebug.net/paper/books/scipydoc/index.html#" target="_blank" rel="noopener">用Python做科学计算</a></p><p>数据地址：github.com<br>源代码地址：github.com</p><h2 id="1、jupyter-notebook显示plot图像"><a href="#1、jupyter-notebook显示plot图像" class="headerlink" title="1、jupyter notebook显示plot图像"></a>1、jupyter notebook显示plot图像</h2><blockquote><p>%matplotlib inline</p></blockquote><h2 id="2、处理excel数据"><a href="#2、处理excel数据" class="headerlink" title="2、处理excel数据"></a>2、处理excel数据</h2><p>后缀为xls或者xlsx</p><blockquote><p>import pandas as pd<br>data.to_excel(‘data.xlsx’, index=False)</p></blockquote><h2 id="3、处理csv数据"><a href="#3、处理csv数据" class="headerlink" title="3、处理csv数据"></a>3、处理csv数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_csv(‘./data.csv’, sep=’\t’)  #按照相应的间隔符读取数据，默认空格或者tab符</p></blockquote><h2 id="4、处理txt数据"><a href="#4、处理txt数据" class="headerlink" title="4、处理txt数据"></a>4、处理txt数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_table(‘./data.txt’)<br>data.to_csv(‘data.txt’, sep=’\t’, index=False)</p></blockquote><h2 id="5、数据可视化"><a href="#5、数据可视化" class="headerlink" title="5、数据可视化"></a>5、数据可视化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#marker为形状、s为形状大小，线条没有，c为颜色，也可以写全称size、color</span></span><br><span class="line"><span class="comment">#scatter为散点图、plot为折线图</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x轴数据, y轴数据, marker = <span class="string">'o'</span>, s=<span class="number">200</span>, c=<span class="string">'red'</span>, label=标签名) </span><br><span class="line">plt.plot(x轴数据, y轴数据, marker = <span class="string">'x'</span>, c=<span class="string">'black'</span>, label=<span class="string">'Comprehensive'</span>)</span><br><span class="line">plt.legend()  <span class="comment"># 让图例生效</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(x轴名称)</span><br><span class="line">plt.ylabel(y轴名称)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def scatter(X, Y):</span><br><span class="line">    #产生测试数据  </span><br><span class="line">    x = np.arange(1,10)  </span><br><span class="line">    y = x  </span><br><span class="line">    fig = plt.figure()  </span><br><span class="line">    ax = fig.add_subplot(111)   # 设置子图</span><br><span class="line">    #设置标题  </span><br><span class="line">    ax.set_title(&apos;Scatter Plot&apos;)  </span><br><span class="line">    #设置X轴标签  </span><br><span class="line">    plt.xlabel(&apos;X&apos;)  </span><br><span class="line">    #设置Y轴标签  </span><br><span class="line">    plt.ylabel(&apos;Y&apos;)  </span><br><span class="line">    #添加批注</span><br><span class="line">    for i in range(4):    # xy表示批注点位置，xxtext表示批注文字位置，arrowprops加箭头</span><br><span class="line">        ax.annotate(Y[i],xy=(X[i,0],X[i,1]), xytext=(X[i,0],X[i,1]), arrowprops=dict(facecolor=&apos;black&apos;, shrink=0.05))</span><br><span class="line">    #画散点图  </span><br><span class="line">    ax.scatter(X[:,0],X[:,1],s = 75,c = &apos;r&apos;,marker = &apos;o&apos;,alpha=.5)  </span><br><span class="line">    #设置图标  </span><br><span class="line">    plt.legend(&apos;X&apos;)  </span><br><span class="line">    #显示所画的图  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="画函数曲线"><a href="#画函数曲线" class="headerlink" title="画函数曲线"></a>画函数曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(0, 12)</span><br><span class="line">y1 = 2 * x + 5   #直线函数</span><br><span class="line">y2 = x ** 2 + 5  #曲线函数</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1, c=&apos;yellow&apos;)</span><br><span class="line">plt.plot(x, y2, c=&apos;red&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="6、dataframe增加一行数据或者一列数据"><a href="#6、dataframe增加一行数据或者一列数据" class="headerlink" title="6、dataframe增加一行数据或者一列数据"></a>6、dataframe增加一行数据或者一列数据</h2><h3 id="增加一行"><a href="#增加一行" class="headerlink" title="增加一行"></a>增加一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(columns=[&apos;name&apos;,&apos;sex&apos;,&apos;age&apos;, &apos;other&apos;])</span><br><span class="line"># 方法1(必须加列名)</span><br><span class="line">df.append(&#123;&apos;name&apos;: &apos;hejian&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;age&apos;: 24, &apos;other&apos;: &apos;handsome&apos;&#125;, ignore_index=True, verify_integrity=False)</span><br><span class="line"></span><br><span class="line">#方法2</span><br><span class="line">df.loc[2] = [&apos;hejian&apos;,  &apos;man&apos;,  24, &apos;handsome&apos;]</span><br></pre></td></tr></table></figure><h2 id="7、排序"><a href="#7、排序" class="headerlink" title="7、排序"></a>7、排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sorted([5, 2, 3, 1, 4])</span><br><span class="line">a = [5, 2, 3, 1, 4]</span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line">sorted(res, key = lambda x:x[0])</span><br><span class="line">df.sort_values(by=)</span><br></pre></td></tr></table></figure><h2 id="8、输出格式"><a href="#8、输出格式" class="headerlink" title="8、输出格式"></a>8、输出格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = [1, 2, 3, 4]</span><br><span class="line">res = []</span><br><span class="line">for elem in ans:</span><br><span class="line">    res.append(str(elem))</span><br><span class="line">print(&apos; &apos;.join(res))  #按照空格间隔输出</span><br><span class="line">print(&apos;*&apos;.join(res))  #按照星号间隔输出</span><br></pre></td></tr></table></figure><h2 id="9、基本操作"><a href="#9、基本操作" class="headerlink" title="9、基本操作"></a>9、基本操作</h2><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><blockquote><p>df = pd.DataFrame([1, 2, 3, 4, 5], columns=[‘cols’], index=[‘a’,’b’,’c’,’d’,’e’])<br>df.index<br>df.columns<br>df = pd.DataFrame(np.random.randint(low=0, high=10, size=(5, 5)), columns=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’])<br>df = pd.DataFrame(data=d, dtype=np.int8)<br>df = pd.DataFrame({‘x’:x, ‘y’:y}, columns=[‘x’, ‘y’])</p></blockquote><h3 id="根据索引查看数据"><a href="#根据索引查看数据" class="headerlink" title="根据索引查看数据"></a>根据索引查看数据</h3><blockquote><p>df.loc[‘a’]   # 索引为ａ这一行的数据<br>df.iloc[0]      #跟上面的操作等价，一个是根据索引名，一个是根据数字索引访问数据</p></blockquote><h3 id="对每个元素乘以２"><a href="#对每个元素乘以２" class="headerlink" title="对每个元素乘以２"></a>对每个元素乘以２</h3><blockquote><p>print df.apply(lambda x:x*2)</p></blockquote><h3 id="对每个元素求平方-支持ndarray一样的向量化操作"><a href="#对每个元素求平方-支持ndarray一样的向量化操作" class="headerlink" title="对每个元素求平方(支持ndarray一样的向量化操作)"></a>对每个元素求平方(支持ndarray一样的向量化操作)</h3><blockquote><p>print df**2</p></blockquote><h3 id="默认合并之接受索引已经存在的值"><a href="#默认合并之接受索引已经存在的值" class="headerlink" title="默认合并之接受索引已经存在的值"></a>默认合并之接受索引已经存在的值</h3><p>通过指定参数 how，指定合并的方式：inner(交集)、outer(并集)</p><blockquote><p>print dfb.join(df_a,how=’inner’)   # 合并两个DataFrame对象的交集</p></blockquote><h3 id="对DataFrame对象进行列扩充"><a href="#对DataFrame对象进行列扩充" class="headerlink" title="对DataFrame对象进行列扩充"></a>对DataFrame对象进行列扩充</h3><blockquote><p>df[‘col4’] = [‘cnn’,’rnn’]      #直接添加一列数据</p></blockquote><h3 id="字段类型转换"><a href="#字段类型转换" class="headerlink" title="字段类型转换"></a>字段类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">arr = np.array([1, 2, 3])</span><br><span class="line">print(type(arr))</span><br><span class="line">print(arr.dtype)</span><br><span class="line">brr = arr.astype(np.float64)</span><br><span class="line">print(type(brr))</span><br><span class="line">print(brr.dtype)</span><br><span class="line">print(arr)</span><br><span class="line">print(brr)</span><br><span class="line">crr = arr.astype(str)</span><br><span class="line">print(type(crr))</span><br><span class="line">print(crr.dtype)</span><br><span class="line">crr</span><br></pre></td></tr></table></figure><h1 id="二、基础的特征工程"><a href="#二、基础的特征工程" class="headerlink" title="二、基础的特征工程"></a>二、基础的特征工程</h1><h2 id="1、查看数据类型和一些值"><a href="#1、查看数据类型和一些值" class="headerlink" title="1、查看数据类型和一些值"></a>1、查看数据类型和一些值</h2><blockquote><p>df.info()<br>df.describe()</p><h2 id="2、查看是否有缺失值"><a href="#2、查看是否有缺失值" class="headerlink" title="2、查看是否有缺失值"></a>2、查看是否有缺失值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isnull</span><br><span class="line">isna</span><br><span class="line">isin(values)</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、良-恶性乳腺癌肿瘤预测实例"><a href="#3、良-恶性乳腺癌肿瘤预测实例" class="headerlink" title="3、良/恶性乳腺癌肿瘤预测实例"></a>3、良/恶性乳腺癌肿瘤预测实例</h2><p><a href="">ipython notebook分析</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 创建特征列表。</span><br><span class="line">column_names = [&apos;Sample code number&apos;, &apos;Clump Thickness&apos;, &apos;Uniformity of Cell Size&apos;, &apos;Uniformity of Cell Shape&apos;, &apos;Marginal Adhesion&apos;, &apos;Single Epithelial Cell Size&apos;, &apos;Bare Nuclei&apos;, &apos;Bland Chromatin&apos;, &apos;Normal Nucleoli&apos;, &apos;Mitoses&apos;, &apos;Class&apos;]</span><br><span class="line"></span><br><span class="line"># 使用pandas.read_csv函数从互联网读取指定数据。</span><br><span class="line">data = pd.read_csv(&apos;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&apos;, names = column_names )</span><br><span class="line"></span><br><span class="line"># 将?替换为标准缺失值表示。</span><br><span class="line">data = data.replace(to_replace=&apos;?&apos;, value=np.nan)</span><br><span class="line"># 丢弃带有缺失值的数据（只要有一个维度有缺失）。</span><br><span class="line">data = data.dropna(how=&apos;any&apos;)</span><br><span class="line"></span><br><span class="line"># 输出data的数据量和维度。</span><br><span class="line">data.shape</span><br><span class="line"></span><br><span class="line"># 使用sklearn.cross_valiation里的train_test_split模块用于分割数据。</span><br><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line"></span><br><span class="line"># 随机采样25%的数据用于测试，剩下的75%用于构建训练集合。</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data[column_names[1:10]], data[column_names[10]], test_size=0.25, random_state=33)</span><br><span class="line"></span><br><span class="line"># 查验训练样本的数量和类别分布。</span><br><span class="line">y_train.value_counts()</span><br><span class="line"></span><br><span class="line"># 查验测试样本的数量和类别分布。</span><br><span class="line">y_test.value_counts()</span><br><span class="line"></span><br><span class="line"># 从sklearn.preprocessing里导入StandardScaler。</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"># 从sklearn.linear_model里导入LogisticRegression与SGDClassifier。</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.linear_model import SGDClassifier</span><br><span class="line"></span><br><span class="line"># 标准化数据，保证每个维度的特征数据方差为1，均值为0。使得预测结果不会被某些维度过大的特征值而主导。</span><br><span class="line">ss = StandardScaler()</span><br><span class="line">X_train = ss.fit_transform(X_train)</span><br><span class="line">X_test = ss.transform(X_test)</span><br><span class="line"></span><br><span class="line"># 初始化LogisticRegression与SGDClassifier。</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">sgdc = SGDClassifier()</span><br><span class="line"></span><br><span class="line"># 调用LogisticRegression中的fit函数/模块用来训练模型参数。</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型lr对X_test进行预测，结果储存在变量lr_y_predict中。</span><br><span class="line">lr_y_predict = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 调用SGDClassifier中的fit函数/模块用来训练模型参数。</span><br><span class="line">sgdc.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型sgdc对X_test进行预测，结果储存在变量sgdc_y_predict中。</span><br><span class="line">sgdc_y_predict = sgdc.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 从sklearn.metrics里导入classification_report模块。</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line"># 使用逻辑斯蒂回归模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuracy of LR Classifier:&apos;, lr.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得LogisticRegression其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, lr_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br><span class="line"></span><br><span class="line"> # 使用随机梯度下降模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuarcy of SGD Classifier:&apos;, sgdc.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得SGDClassifier其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, sgdc_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br></pre></td></tr></table></figure></p><h2 id="4、召回率、精确率和F1值"><a href="#4、召回率、精确率和F1值" class="headerlink" title="4、召回率、精确率和F1值"></a>4、召回率、精确率和F1值</h2><p>假设我们手上有60个正样本，40个负样本，我们要找出所有的正样本，系统查找出50个，其中只有40个是真正的正样本，计算上述各指标。</p><p>TP: 将正类预测为正类数  40<br>FN: 将正类预测为负类数  20<br>FP: 将负类预测为正类数  10<br>TN: 将负类预测为负类数  30</p><p>准确率(accuracy) = 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN) = 70%<br>精确率(precision) = TP/(TP+FP) = 80%<br>召回率(recall) = TP/(TP+FN) = 2/3<br>F值  = 正确率 <em> 召回率 </em> 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）<br>白话：精确率就是在所有预测为正例中有多少是预测正确的，召回率就是在全部本身就是正样本中有多少预测正确。</p><h2 id="5、sklearn-model-selection-train-test-split随机划分训练集和测试集"><a href="#5、sklearn-model-selection-train-test-split随机划分训练集和测试集" class="headerlink" title="5、sklearn.model_selection.train_test_split随机划分训练集和测试集"></a>5、sklearn.model_selection.train_test_split随机划分训练集和测试集</h2><p>train_test_split是交叉验证中常用的函数，功能是从样本中随机的按比例选取train data和testdata，形式为：</p><blockquote><p>X_train,X_test, y_train, y_test =<br>cross_validation.train_test_split(train_data,train_target,test_size=0.4, random_state=0)</p></blockquote><p>参数解释：<br>train_data：所要划分的样本特征集<br>train_target：所要划分的样本结果<br>test_size：样本占比，如果是整数的话就是样本的数量<br>random_state：是随机数的种子。</p><p>随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。<br>随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：<br>种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><h1 id="三、实例篇"><a href="#三、实例篇" class="headerlink" title="三、实例篇"></a>三、实例篇</h1><p>数据文件：data.csv   data.txt  data.xlsx<br>数据内容(高中成绩)：</p><table><thead><tr><th style="text-align:center">Date</th><th style="text-align:center">Chinese</th><th style="text-align:center">Math</th><th style="text-align:center">English</th><th style="text-align:center">Comprehensive </th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">111</td><td style="text-align:center">130</td><td style="text-align:center">127</td><td style="text-align:center">269    </td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td style="text-align:center">159</td><td style="text-align:center">ok</td><td style="text-align:center">191</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">137</td><td style="text-align:center">119</td><td style="text-align:center">99</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">97</td><td style="text-align:center">149</td><td style="text-align:center">89</td><td style="text-align:center">235</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">120</td><td style="text-align:center">135</td><td style="text-align:center">116</td><td style="text-align:center">282 </td></tr></tbody></table><h2 id="1、生成数据并保存读取"><a href="#1、生成数据并保存读取" class="headerlink" title="1、生成数据并保存读取"></a>1、生成数据并保存读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    data = pd.DataFrame(columns=[&apos;Date&apos;,&apos;Chinese&apos;,&apos;Math&apos;, &apos;English&apos;, &apos;Comprehensive&apos;])</span><br><span class="line">    data.loc[0] = [7,  111, 130, 127, 269]</span><br><span class="line">    data.loc[1] = [8,  &apos;&apos;, 159, &apos;ok&apos;, 191]</span><br><span class="line">    data.loc[2] = [9, 137, 119, 99, 250]</span><br><span class="line">    data.loc[3] = [10, 97, 149, 89, 235]</span><br><span class="line">    data.loc[4] = [11, 120, 135, 116, 282]</span><br><span class="line"></span><br><span class="line">    data.to_csv(&apos;&apos;)</span><br></pre></td></tr></table></figure><h1 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h1><h2 id="去除警告"><a href="#去除警告" class="headerlink" title="去除警告"></a>去除警告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line"></span><br><span class="line">def ignore_warn(*arg, *swarg):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">warning.warn = ignore_warn</span><br></pre></td></tr></table></figure><h3 id="忽略命令行下警告错误的输出"><a href="#忽略命令行下警告错误的输出" class="headerlink" title="忽略命令行下警告错误的输出"></a>忽略命令行下警告错误的输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -W ignore yourscript.py</span><br><span class="line">with open as [for   ]</span><br></pre></td></tr></table></figure><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for i in range (len(list1)):</span><br><span class="line">    print i ,list1[i]</span><br><span class="line"></span><br><span class="line">上述方法有些累赘，利用enumerate()会更加直接和优美：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0 这</span><br><span class="line">1 是</span><br><span class="line">2 一个</span><br><span class="line">3 测试</span><br><span class="line"></span><br><span class="line">enumerate还可以接收第二个参数，用于指定索引起始值，如：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1, 1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">1 这</span><br><span class="line">2 是</span><br><span class="line">3 一个</span><br><span class="line">4 测试</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如果要统计文件的行数，可以这样写：</p><blockquote><p>count = len(open(filepath, ‘r’).readlines())<br>这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。</p></blockquote><p>可以利用enumerate()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">for index, line in enumerate(open(filepath,&apos;r&apos;))： </span><br><span class="line">    count += 1</span><br></pre></td></tr></table></figure></p><h2 id="python-字符串查找的4个方法"><a href="#python-字符串查找的4个方法" class="headerlink" title="python 字符串查找的4个方法"></a>python 字符串查找的4个方法</h2><h3 id="1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"><a href="#1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1" class="headerlink" title="1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"></a>1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1</h3><p>info = ‘abca’<br>print info.find(‘a’)##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</p><p>info = ‘abca’<br>print info.find(‘a’,1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3</p><p>info = ‘abca’<br>print info.find(‘333’)##返回-1,查找不到返回-1</p><h3 id="2-index-方法："><a href="#2-index-方法：" class="headerlink" title="2 index()方法："></a>2 index()方法：</h3><p>python 的index方法是在字符串里查找子串第一次出现的位置，类似字符串的find方法，不过比find方法更好的是，如果查找不到子串，会抛出异常，而不是返回-1</p><p>info = ‘abca’<br>print info.index(‘a’)<br>print info.index(‘33’)</p><h3 id="3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"><a href="#3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。" class="headerlink" title="3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"></a>3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。</h3><p>如果查找全部，可以先找到第一个，然后从当前为起点继续查找。另外一种方法就是正则表达式。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://hankin2015.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="DataFrame" scheme="https://hankin2015.github.io/tags/DataFrame/"/>
    
      <category term="Pandas" scheme="https://hankin2015.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法总结[置顶]</title>
    <link href="https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/"/>
    <id>https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/</id>
    <published>2222-04-24T02:47:41.000Z</published>
    <updated>2018-08-11T16:42:21.942Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">参考：@移动开发小冉</a></p><blockquote><p>算法虐我千百遍，我待算法如初恋</p></blockquote><p>这里的内容是我学习算法过程的一些记录，希望能一直坚持下去。</p><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul><li>把所有经典算法写一遍  </li><li>看算法有关源码   </li><li>加入算法学习社区，相互鼓励学习   </li><li>看经典书籍  </li><li>刷题   </li></ul><h2 id="基本数据结构和算法"><a href="#基本数据结构和算法" class="headerlink" title="基本数据结构和算法"></a>基本数据结构和算法</h2><p>这些算法全部自己敲一遍：</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表</li><li>双向链表</li></ul><h3 id="哈希表-散列表-Hash-Table"><a href="#哈希表-散列表-Hash-Table" class="headerlink" title="哈希表/散列表 (Hash Table)"></a>哈希表/散列表 (Hash Table)</h3><ul><li>散列函数</li><li>碰撞解决</li></ul><h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><ul><li>排序</li><li>查找<ul><li>BF算法  </li><li>KMP算法  </li><li>BM算法  </li></ul></li><li>正则表达式</li><li>数据压缩</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>二叉树    </li><li>二叉查找树   </li><li>伸展树(splay tree 分裂树)   </li><li>平衡二叉树AVL    </li><li>红黑树  </li><li>B树,B+,B*  </li><li>R树  </li><li>Trie树(前缀树)  </li><li>后缀树  </li><li>最优二叉树(赫夫曼树) </li><li>二叉堆 （大根堆，小根堆）   </li><li>二项树    </li><li>二项堆  </li><li>斐波那契堆(Fibonacci Heap)   </li></ul><h3 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h3><ul><li>图的存储结构和基本操作（建立，遍历，删除节点，添加节点）   </li><li>最小生成树  </li><li>拓扑排序  </li><li>关键路径  </li><li>最短路径: Floyd,Dijkstra,bellman-ford,spfa  </li></ul><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>交换排序算法</strong></p><ul><li>冒泡排序</li><li>插入排序    </li><li>选择排序    </li><li>希尔排序</li><li>快排   </li><li>归并排序  </li><li>堆排序</li></ul><p><strong>线性排序算法</strong></p><ul><li>桶排序 </li></ul><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul><li>顺序表查找：顺序查找  </li><li>有序表查找：二分查找  </li><li>分块查找： 块内无序，块之间有序；可以先二分查找定位到块，然后再到<code>块</code>中顺序查找  </li><li>动态查找:  二叉排序树，AVL树，B- ，B+    （这里之所以叫 <code>动态查找表</code>，是因为表结构是查找的过程中动态生成的）</li><li>哈希表：  O(1)     </li></ul><h3 id="15个经典基础算法"><a href="#15个经典基础算法" class="headerlink" title="15个经典基础算法"></a>15个经典基础算法</h3><ul><li>Hash  </li><li>快速排序 </li><li>快递选择SELECT </li><li>BFS/DFS （广度/深度优先遍历）    </li><li>红黑树 （一种自平衡的<code>二叉查找树</code>）  </li><li>KMP    字符串匹配算法</li><li>DP (动态规划 dynamic programming)   </li><li>A*寻路算法： 求解最短路径 </li><li>Dijkstra：最短路径算法 （八卦下：Dijkstra是荷兰的计算机科学家,提出”信号量和PV原语“,”解决哲学家就餐问题”,”死锁“也是它提出来的） </li><li>遗传算法  </li><li>启发式搜索   </li><li>图像特征提取之SIFT算法  </li><li>傅立叶变换  </li><li>SPFA(shortest path faster algorithm)  单元最短路径算法  </li></ul><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li>Hash映射/分而治之</li><li>Bitmap</li><li>Bloom filter(布隆过滤器)</li><li>Trie树</li><li>数据库索引</li><li>倒排索引(Inverted Index)</li><li>双层桶划分</li><li>外排序</li><li>simhash算法</li><li>分布处理之Mapreduce</li></ul><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ul><li>迭代法  </li><li>穷举搜索法  </li><li>递推法  </li><li>动态规划  </li><li>贪心算法  </li><li>回溯  </li><li>分治算法  </li></ul><h2 id="算法问题选编"><a href="#算法问题选编" class="headerlink" title="算法问题选编"></a>算法问题选编</h2><p>这是一个算法题目合集，题目是我从网络和书籍之中整理而来，部分题目已经做了思路整理。问题分类包括：</p><ul><li>字符串</li><li>堆和栈</li><li>链表</li><li>数值问题</li><li>数组和数列问题</li><li>矩阵问题</li><li>二叉树</li><li>图</li><li>海量数据处理</li><li>智力思维训练</li><li>系统设计</li></ul><p>还有部分来自算法网站和书籍：</p><ul><li>九度OJ</li><li>leetcode</li><li>剑指offer</li></ul><h2 id="开源项目中的算法"><a href="#开源项目中的算法" class="headerlink" title="开源项目中的算法"></a>开源项目中的算法</h2><ul><li>YYCache</li><li>cocos2d-objc</li><li>…</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="刷题必备"><a href="#刷题必备" class="headerlink" title="刷题必备"></a>刷题必备</h3><p>《剑指offer》<br>《编程之美》<br>《编程之法:面试和算法心得》<br>《算法谜题》 都是思维题 </p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>《编程珠玑》Programming Pearls<br>《编程珠玑(续)》<br>《数据结构与算法分析》<br>《Algorithms》 这本近千页的书只有6章,其中四章分别是排序，查找，图，字符串，足见介绍细致     </p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>《算法设计与分析基础》<br>《算法引论》 告诉你如何创造算法   断货<br>《Algorithm Design Manual》算法设计手册 红皮书  </p><p>《算法导论》 是一本对算法介绍比较全面的经典书籍   </p><p>《Algorithms on Strings,Trees and Sequences》<br>《Advanced Data Structures》 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树  600块    </p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>《深入理解计算机系统》<br>《TCP/IP详解三卷》<br>《UNIX网络编程二卷》<br>《UNIX环境高级编程：第2版》  </p><p>《The practice of programming》   Brian Kernighan和Rob Pike<br>《writing efficient programs》  优化<br>《The science of programming》 证明代码段的正确性   800块一本   </p><h2 id="参考链接和学习网站"><a href="#参考链接和学习网站" class="headerlink" title="参考链接和学习网站"></a>参考链接和学习网站</h2><h3 id="July-博客"><a href="#July-博客" class="headerlink" title="July 博客"></a><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">July 博客</a></h3><p>《数学建模十大经典算法》<br>《数据挖掘领域十大经典算法》<br>《十道海量数据处理面试题》<br>《数字图像处理领域的二十四个经典算法》<br>《精选微软等公司经典的算法面试100题》 </p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">The-Art-Of-Programming-By-July</a><br><a href="http://blog.csdn.net/column/details/ms100.html" target="_blank" rel="noopener">微软面试100题</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6460494" target="_blank" rel="noopener">程序员编程艺术</a>   </p><h3 id="基本算法演示"><a href="#基本算法演示" class="headerlink" title="基本算法演示"></a>基本算法演示</h3><p><a href="http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html" target="_blank" rel="noopener">http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html</a><br><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">http://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a>  </p><h3 id="编程网站"><a href="#编程网站" class="headerlink" title="编程网站"></a>编程网站</h3><p><a href="http://leetcode.com/" target="_blank" rel="noopener">leetcode</a><br><a href="http://openjudge.cn/" target="_blank" rel="noopener">openjudge</a>  开放在线程序评测平台，可以床架自己的OJ小组<br><a href="http://ac.jobdu.com/index.php" target="_blank" rel="noopener">九度OJ</a>     </p><p>这有个<a href="http://www.java3z.com/cwbwebhome/article/article19/res041.html" target="_blank" rel="noopener">ACM训练方案</a>   </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/" target="_blank" rel="noopener">高级数据结构和算法</a>  北大教授张铭老师在coursera上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie树、AVL树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然coursera上也还有很多其它算法方面的视频课程。</p><p><a href="https://class.coursera.org/algorithms-001/lecture" target="_blank" rel="noopener">算法设计与分析 Design and Analysis of Algorithms</a> 由北大教授Wanling Qu在coursera讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf文件）以便阅读和复习。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构算法" scheme="https://hankin2015.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://hankin2015.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅的机器学习笔记</title>
    <link href="https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/"/>
    <id>https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/</id>
    <published>2019-04-21T02:47:41.000Z</published>
    <updated>2018-08-12T17:35:33.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html" target="_blank" rel="noopener">李宏毅机器学习深度学习资料</a><br><a href="https://www.bilibili.com/video/av10590361?from=search&amp;seid=8971112424275201304" target="_blank" rel="noopener">李宏毅2017机器学习视频</a><br><a href="https://www.52ml.net/" target="_blank" rel="noopener">我爱机器学习</a><br><a href="https://www.lintcode.com/" target="_blank" rel="noopener">周sir推荐lintcode</a><br><a href="https://www.jiqizhixin.com/articles/02111" target="_blank" rel="noopener">邓miss推荐李沫动手学深度学习</a></p><h1 id="1、Introduction-of-this-course"><a href="#1、Introduction-of-this-course" class="headerlink" title="1、Introduction of this course"></a>1、Introduction of this course</h1><p>人工智慧目标-》机器学习手段-》深度学习方法<br>之前的智慧：人类设定好的天生本能</p><ul><li>河狸生物的本能筑水坝</li><li>Chat_bot和漫画智能机器人多个if调侃AI<a id="more"></a><h2 id="3步Machine-Learning-is-so-simple-……"><a href="#3步Machine-Learning-is-so-simple-……" class="headerlink" title="3步Machine Learning is so simple ……"></a>3步Machine Learning is so simple ……</h2>Step 1: define a set of function<br>Step 2: goodness of function<br>Step 3: pick the best function<br>就好像吧大象放进冰箱……</li></ul><h2 id="Learning-Map-scenario-task-method"><a href="#Learning-Map-scenario-task-method" class="headerlink" title="Learning Map: scenario task method"></a>Learning Map: scenario task method</h2><ul><li>Supervised Learning<ul><li>Regression</li><li>Classification<ul><li>Linear Model</li><li>Non-linear Model<ul><li>Deep Learning</li><li>SVM, decision tree, K-NN …</li></ul></li></ul></li><li>Structured Learning</li></ul></li><li>Semi-supervised Learning</li><li>Transfer Learning</li><li>Unsupervised Learning</li><li>Reinforcement Learning</li></ul><h1 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h1><p>saddle point鞍点<br>local minima极点</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅机器学习深度学习资料&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.bilibili.com/video/av10590361?from=search&amp;amp;seid=8971112424275201304&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅2017机器学习视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.52ml.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我爱机器学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.lintcode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;周sir推荐lintcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/02111&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;邓miss推荐李沫动手学深度学习&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、Introduction-of-this-course&quot;&gt;&lt;a href=&quot;#1、Introduction-of-this-course&quot; class=&quot;headerlink&quot; title=&quot;1、Introduction of this course&quot;&gt;&lt;/a&gt;1、Introduction of this course&lt;/h1&gt;&lt;p&gt;人工智慧目标-》机器学习手段-》深度学习方法&lt;br&gt;之前的智慧：人类设定好的天生本能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;河狸生物的本能筑水坝&lt;/li&gt;
&lt;li&gt;Chat_bot和漫画智能机器人多个if调侃AI
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习笔记</title>
    <link href="https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/"/>
    <id>https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/</id>
    <published>2019-01-15T02:47:41.000Z</published>
    <updated>2018-09-25T01:53:46.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="http://zh.gluon.ai/index.html#" target="_blank" rel="noopener">动手学深度学习</a><br>这是一个深度学习的教学项目。我们将使用 Apache MXNet (incubating) 的最新 gluon 接口来演示如何从0开始实现深度学习的各个算法。我们的将利用 Jupyter notebook 能将文档，代码，公式和图形统一在一起的优势，提供一个交互式的学习体验。这个项目可以作为一本书，上课用的材料，现场演示的案例，和一个可以尽情拷贝的代码库。据我们所知，目前并没有哪个项目能既覆盖全面深度学习，又提供交互式的可执行代码。我们将尝试弥补这个空白。</p><p>第一季十九课视频汇总<br>可打印的PDF版本在这里<br>课程源代码在Github （亲，给个好评加颗星）<br>请使用 <a href="http://discuss.gluon.ai/" target="_blank" rel="noopener">http://discuss.gluon.ai/</a> 来进行讨论</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="主要符号一览"><a href="#主要符号一览" class="headerlink" title="主要符号一览"></a>主要符号一览</h2><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><h3 id="1、用代码编程和用数据编程"><a href="#1、用代码编程和用数据编程" class="headerlink" title="1、用代码编程和用数据编程"></a>1、用代码编程和用数据编程</h3><p>这个例子灵感来自 Joel Grus 的一次 应聘面试. 面试官让他写个程序来玩Fizz Buzz. 这是一个小孩子游戏。玩家从1数到100，如果数字被3整除，那么喊’fizz’，如果被5整除就喊’buzz’，如果两个都满足就喊’fizzbuzz’，不然就直接说数字。这个游戏玩起来就像是：</p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 …</p></blockquote><p>传统的实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [1]:</span><br><span class="line">res = []</span><br><span class="line">for i in range(1, 101):</span><br><span class="line">    if i % 15 == 0:</span><br><span class="line">        res.append(&apos;fizzbuzz&apos;)</span><br><span class="line">    elif i % 3 == 0:</span><br><span class="line">        res.append(&apos;fizz&apos;)</span><br><span class="line">    elif i % 5 == 0:</span><br><span class="line">        res.append(&apos;buzz&apos;)</span><br><span class="line">    else:</span><br><span class="line">        res.append(str(i))</span><br><span class="line">print(&apos; &apos;.join(res))</span><br></pre></td></tr></table></figure></p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz b</p></blockquote><p>对于经验丰富的程序员来说这个太不够一颗赛艇了。所以Joel尝试用机器学习来实现这个。为了让程序能学，他需要准备下面这个数据集：</p><ul><li>数据 X [1, 2, 3, 4, …] 和标注Y [‘fizz’, ‘buzz’, ‘fizzbuzz’, identity]</li><li>训练数据，也就是系统输入输出的实例。例如 [(2, 2), (6, fizz), (15, fizzbuzz), (23, 23), (40, buzz)]</li><li>从输入数据中抽取的特征，例如 x -&gt; [(x % 3), (x % 5), (x % 15)].</li></ul><p>有了这些，Jeol利用TensorFlow写了一个分类器。对于不按常理出牌的Jeol，面试官一脸黑线。而且这个分类器不是总是对的。</p><h3 id="2、机器学习最简要素"><a href="#2、机器学习最简要素" class="headerlink" title="2、机器学习最简要素"></a>2、机器学习最简要素</h3><p>成功的机器学习有四个要素：数据、转换数据的模型、衡量模型好坏的损失函数和一个调整模型权重来最小化损失函数的算法。</p><h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><h4 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h4><ul><li>训练误差（training error）：这是模型在用于训练的数据集上的误差。类似于考试前我们在模拟试卷上拿到的分数。有一定的指向性，但不一定保证真实考试分数。</li><li>测试误差（test error）：这是模型在没见过的新数据上的误差，可能会跟训练误差很不一样（统计上称之为过拟合）。类似于考前模考次次拿高分，但实际考起来却失误了。</li></ul><h4 id="Optimization-Algorithms"><a href="#Optimization-Algorithms" class="headerlink" title="Optimization Algorithms"></a>Optimization Algorithms</h4><h3 id="3、Supervised-Learning"><a href="#3、Supervised-Learning" class="headerlink" title="3、Supervised Learning"></a>3、Supervised Learning</h3><p>简单概括，学习过程看起来是这样的：在一大组数据中随机地选择样本输入，并获得其真实（ground-truth）的标注（label）；这些输入和标注（即期望的结果）构成了训练集（training set）。我们把训练集放入一个监督学习算法（supervised learning algorithm）。算法的输入是训练集，输出则是学得模型（learned model）。基于这个学得模型，我们输入之前未见过的测试数据，并预测相应的标注。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zh.gluon.ai/_images/supervised-learning.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="3-1、Regression"><a href="#3-1、Regression" class="headerlink" title="3-1、Regression"></a>3-1、Regression</h4><p>在该项任务里，输入是任意离散或连续的、单一或多个的变量，而输出是连续的数值。</p><p>一条经验就是，问题中如果包含“多少？”，这类问题一般是回归问题。“这次手术需要几个小时？”……回归分析。“这张照片里有几只狗？”……回归分析。不过，如果问题能够转化为“这是一个<em>__</em>吗？”，那这很有可能是一个分类，或者属于其余我们将会谈及的问题。</p><p>如果我们把模型预测的输出值和真实的输出值之间的差别定义为残差，常见的回归分析的损失函数包括训练数据的残差的平方和或者绝对值的和。机器学习的任务是找到一组模型参数使得损失函数最小化。</p><h4 id="3-2、Classification"><a href="#3-2、Classification" class="headerlink" title="3-2、Classification"></a>3-2、Classification</h4><p>回归分析所关注的预测可以解答输出为连续数值 的问题。当预测的输出是离散的 类别时，这个监督学习任务就叫做分类。</p><h2 id="使用NDArray来处理数据"><a href="#使用NDArray来处理数据" class="headerlink" title="使用NDArray来处理数据"></a>使用NDArray来处理数据</h2><p>使用autograd来自动求导<br>深度学习模型基础<br>线性回归——从零开始<br>线性回归——使用Gluon<br>多类逻辑回归——从零开始<br>多类逻辑回归——使用Gluon<br>多层感知机——从零开始<br>多层感知机——使用Gluon<br>欠拟合和过拟合<br>正则化——从零开始<br>正则化——使用Gluon<br>丢弃法（Dropout）——从零开始<br>丢弃法（Dropout）——使用Gluon<br>正向传播和反向传播<br>实战Kaggle比赛——使用Gluon预测房价和K折交叉验证<br>深度学习计算基础<br>模型构造<br>模型参数<br>自定义层<br>读取和存储<br>GPU计算<br>卷积神经网络<br>卷积神经网络 — 从0开始<br>卷积神经网络 — 使用Gluon<br>批量归一化 — 从0开始<br>批量归一化 — 使用Gluon<br>深度卷积神经网络和AlexNet<br>VGG：使用重复元素的非常深的网络<br>网络中的网络<br>更深的卷积神经网络：GoogLeNet<br>ResNet：深度残差网络<br>DenseNet：稠密连接的卷积神经网络<br>循环神经网络<br>循环神经网络 — 从0开始<br>通过时间反向传播<br>门控循环单元（GRU）— 从0开始<br>长短期记忆（LSTM）— 从0开始<br>循环神经网络 — 使用Gluon<br>优化算法<br>优化算法概述<br>梯度下降和随机梯度下降——从零开始<br>梯度下降和随机梯度下降——使用Gluon<br>动量法——从零开始<br>动量法——使用Gluon<br>Adagrad——从零开始<br>Adagrad——使用Gluon<br>RMSProp——从零开始<br>RMSProp——使用Gluon<br>Adadelta——从零开始<br>Adadelta——使用Gluon<br>Adam——从零开始<br>Adam——使用Gluon<br>计算性能<br>命令式和符号式混合编程<br>惰性计算<br>自动并行计算<br>多GPU训练模型——从零开始<br>多GPU训练模型——使用Gluon<br>计算机视觉<br>图片增广<br>Fine-tuning: 通过微调来迁移学习<br>使用卷积神经网络的物体检测<br>SSD — 使用Gluon<br>YOLO — 使用Gluon<br>语义分割：FCN<br>样式迁移<br>实战Kaggle比赛——使用Gluon对原始图像文件分类（CIFAR-10）<br>实战Kaggle比赛——使用Gluon识别120种狗 (ImageNet Dogs)<br>自然语言处理<br>词向量 — word2vec<br>词向量 — GloVe和fastText<br>使用预训练的词向量<br>编码器—解码器（seq2seq）和注意力机制<br>神经机器翻译<br>附录<br>安装和使用<br>GPU购买指南<br>在AWS上运行教程<br>数学基础<br>本教程的英文版本 （注意：中文版本根据社区的反馈做了比较大的更改，我们还在努力的将改动同步到英文版）</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理</title>
    <link href="https://hankin2015.github.io/2018/11/10/20181110Principle/"/>
    <id>https://hankin2015.github.io/2018/11/10/20181110Principle/</id>
    <published>2018-11-10T14:47:41.000Z</published>
    <updated>2018-11-10T13:30:41.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。<br><a href="https://www.cnblogs.com/rhythmic/p/5503272.html" target="_blank" rel="noopener">《程序设计中的组合数学》——容斥定理</a><br><a href="http://blog.csdn.net/han_kin/article/details/47662801" target="_blank" rel="noopener">容斥定理</a><br><a id="more"></a></p><p>韦恩图能够鲜明的解释这个原理。</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>时间复杂度：2^n （n集合个数）<br>总共就2^n种组合（子串），然后判断每种可能中有多少集合来判断正负。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int solve (int n, int r)</span><br><span class="line">&#123;</span><br><span class="line">    /*求质数*/</span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            p.push_back (i);</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) p.push_back (n);</span><br><span class="line"></span><br><span class="line">    int sum = 0;   // 非互质的个数</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; (int)p.size()); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int mult = 1, bits = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; (int)p.size(); ++i) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ++bits;</span><br><span class="line">                mult *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = r / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) sum += cur;</span><br><span class="line">        else sum -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return r - sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="两个同一个问题"><a href="#两个同一个问题" class="headerlink" title="两个同一个问题"></a>两个同一个问题</h1><ol><li>给出整数n和r。求区间[1;r]中与n互素的数的个数。</li><li>给定一个区间[A,B],找出在这个区间内与给定的n互质的整数的个数。</li></ol><p>两个问题解决方案一样，去解决它的逆问题，求不与n互素的数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 求n的质因数</span><br><span class="line">void FindPrimeFactor(int n, int a[], int &amp;cnt)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            a[cnt++] = i;</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) a[cnt++] = n;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 复杂度也是2^k</span><br><span class="line">LL Solve2(LL n, int a[], int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    int t = 1, que[1005] = &#123; -1&#125;; // 依据容斥原理，que[0]的值是-1</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;  // 比如2 3 4，形成-1 2 3 -6 4 -8 -12 24</span><br><span class="line">        int k = t;</span><br><span class="line">        for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">            que[t++] = que[j] * a[i] * (-1);  // 难点</span><br><span class="line">            /*乘以-1和-1^k是一样的效果</span><br><span class="line">            重点在第一个for循环，新加进去的数和前面形成组合子串*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;t = &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    for (int i = 1; i &lt; t; i++) &#123;</span><br><span class="line">        cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line">        res += n / que[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve (int n, int r)</span><br><span class="line">&#123;</span><br><span class="line">    /*求质数*/</span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            p.push_back (i);</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) p.push_back (n);</span><br><span class="line"></span><br><span class="line">    int sum = 0;   // 非互质的个数</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; (int)p.size()); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int mult = 1, bits = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; (int)p.size(); ++i) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ++bits;</span><br><span class="line">                mult *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = r / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) sum += cur;</span><br><span class="line">        else sum -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return r - sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">题目：给定一个区间[A,B],找出在这个区间内与给定的N互质的整数的个数。</span><br><span class="line">T(0 &lt; T &lt;= 100)the number of test cases</span><br><span class="line">each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;= 10^15) and (1 &lt;=N &lt;= 10^9).</span><br><span class="line"></span><br><span class="line">直接求互质复杂度高，可以用素数筛选法求非互质的数。</span><br><span class="line">求[1,B]-[1,A-1]。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 直接算一定有错误，必须使用容斥原理</span><br><span class="line">LL Solve(LL n, int a[], int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        for (int j = 1; ; j++) &#123;</span><br><span class="line">            if (j * a[i] &gt; n) &#123;</span><br><span class="line">                res += j - 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">N = 12 --- 2 3</span><br><span class="line">18  2 4 6 8 10 12 14 16 18</span><br><span class="line">    3 6 9 12 15 18</span><br><span class="line">会返回结果为15.</span><br><span class="line">正确答案是12.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int maxn = 1005;</span><br><span class="line">    int a[maxn] = &#123;2, 3, 4&#125;, cnt = 3;</span><br><span class="line">    //FindPrimeFactor(12, a, cnt);</span><br><span class="line">    //cout &lt;&lt; Solve2(18, a, cnt) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; solve(12, 18) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    __int64 i, T, x, y, n, sum;</span><br><span class="line">    while(scanf(&quot;%I64d&quot;, &amp;T) != EOF) &#123;</span><br><span class="line">        for(i = 1; i &lt;= T; i++) &#123;</span><br><span class="line">            scanf(&quot;%I64d%I64d%I64d&quot;, &amp;x, &amp;y, &amp;n);</span><br><span class="line">            //sum = y - haha(y) - (x - 1 - haha(x - 1)); //由于区间是[x,y],求出[1,y]的互质个数，再减去[1,x-1]的互质个数</span><br><span class="line">            printf(&quot;Case #%I64d: &quot;, i);</span><br><span class="line">            printf(&quot;%I64d\n&quot;, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="另外一个缠绕我很久的问题，居然是容斥原理"><a href="#另外一个缠绕我很久的问题，居然是容斥原理" class="headerlink" title="另外一个缠绕我很久的问题，居然是容斥原理"></a>另外一个缠绕我很久的问题，居然是容斥原理</h1><p><a href="https://hankin2015.github.io/2017/12/18/20171218NEUQ1021/">NEUQ1027：谷学长的童年（概率问题）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;容斥原理&quot;&gt;&lt;a href=&quot;#容斥原理&quot; class=&quot;headerlink&quot; title=&quot;容斥原理&quot;&gt;&lt;/a&gt;容斥原理&lt;/h1&gt;&lt;p&gt;在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/rhythmic/p/5503272.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《程序设计中的组合数学》——容斥定理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/han_kin/article/details/47662801&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;容斥定理&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algrithm" scheme="https://hankin2015.github.io/categories/Algrithm/"/>
    
    
      <category term="容斥原理" scheme="https://hankin2015.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NEUQ1027：谷学长的童年（概率问题）</title>
    <link href="https://hankin2015.github.io/2018/11/09/20181109NEUQ1021/"/>
    <id>https://hankin2015.github.io/2018/11/09/20181109NEUQ1021/</id>
    <published>2018-11-09T02:47:41.000Z</published>
    <updated>2018-11-10T13:35:24.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="http://newoj.acmclub.cn/problems/1021" target="_blank" rel="noopener">题目描述</a></h1><p>小时候，谷学长买了很多干脆面，因为一旦集齐所有类型的卡片就有大奖可拿。<br>谷学长很聪明的意识到要想集齐全套卡片就得买相当多的干脆面，为了尽可能的省钱，他想计算出每种类型卡片均获得一张应买干脆面的期望数目。</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>每个测试用例的第一行包含一个N(1 &lt;= N &lt;= 20), 表示干脆面里可能放置N种类型的卡片，第二行有N个数p1, p2, …, pN, (p1 + p2 + … + pN &lt;= 1), 表示中到对应类型卡片的概率。<br>注意每袋干脆面最多只有一张卡片。<br><a id="more"></a></p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>对于每组测试用例，输出集齐N张不同类型的卡片所买干脆面的期望数目。结果保留三位有效数字。</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><pre><code>10.120.1 0.4</code></pre><h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><pre><code>10.00010.500</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>花了我很久很久的时间来解决这道题。。。</p><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。<br>需要注意的是，期望值并不一定等同于常识中的“期望”——“期望值”也许与每一个结果都不相等。期望值是该变量输出值的平均数。期望值并不一定包含于变量的输出值集合里。<br>大数定律规定，随着重复次数接近无穷大，数值的算术平均值几乎肯定地收敛于期望值。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>设C为一个常数，X和Y是两个随机变量。以下是数学期望的重要性质：[2] </p><ol><li>E(C) = C</li><li>E(CX) = CE(X)</li><li>E(X + Y) = E(X) + E(Y)<br>4.当X和Y相互独立时， E(XY) = E(X)E(Y)<br>性质3和性质4可以推到到任意有限个相互独立的随机变量之和或之积的情况。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/63691292" target="_blank" rel="noopener">如何计算不等概率的抽卡次数期望？</a><br><a href="https://www.zybang.com/question/dc33d975f38865257ab9a8d3d35a49d0.html" target="_blank" rel="noopener">为什么说A+B多算的这一块,是他?</a><br><a href="http://blog.sciencenet.cn/blog-752541-995651.html" target="_blank" rel="noopener">为了集齐小浣熊干脆面108将卡,得吃多少袋干脆面？</a><br><a href="https://www.zhihu.com/question/20930350" target="_blank" rel="noopener">假设小浣熊随机赠送的卡片共有 100 种（出现概率相同），那么集齐所有卡片所需购买小浣熊包数的数学期望是多少？</a><br><a href="https://en.wikipedia.org/wiki/Coupon_collector&#39;s_problem" target="_blank" rel="noopener">Coupon collector’s problem</a><br><a href="https://www.guokr.com/question/477410/" target="_blank" rel="noopener">干脆面大家都吃过，里头往往会有一张卡，一共几十种，集齐送奖品。假设只有三种卡，那么集齐卡片需要买的方便面包数X的期望是多少？如果是N种卡，期望又怎么算？</a><br><a href="http://blog.csdn.net/q1w2e3r4470/article/details/60331703" target="_blank" rel="noopener">50个概率题</a><br><a href="https://www.cnblogs.com/no-tears-girl/p/7476175.html" target="_blank" rel="noopener">试题1—经典概率问题：优惠券收集问题</a><br><a href="http://blog.csdn.net/xyb890826/article/details/41829627" target="_blank" rel="noopener">模拟要得到四张不同花色的牌所需要的选取次数，然后显示选中的四张牌（有可能一张牌被选了两次）。</a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>就是使用容斥原理即可，困难我很久的问题终于解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double Solve(int N, double p[])</span><br><span class="line">&#123;</span><br><span class="line">    double ans = 0;</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; N); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int bits = 0;</span><br><span class="line">        double mult = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">                mult += p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double cur = 1 / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) ans += cur;</span><br><span class="line">        else ans -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    double p[25];</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        for (int i = 0; i &lt; N; i++) cin &gt;&gt; p[i];</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; Solve(N, p) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://newoj.acmclub.cn/problems/1021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目描述&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;小时候，谷学长买了很多干脆面，因为一旦集齐所有类型的卡片就有大奖可拿。&lt;br&gt;谷学长很聪明的意识到要想集齐全套卡片就得买相当多的干脆面，为了尽可能的省钱，他想计算出每种类型卡片均获得一张应买干脆面的期望数目。&lt;/p&gt;
&lt;h1 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h1&gt;&lt;p&gt;每个测试用例的第一行包含一个N(1 &amp;lt;= N &amp;lt;= 20), 表示干脆面里可能放置N种类型的卡片，第二行有N个数p1, p2, …, pN, (p1 + p2 + … + pN &amp;lt;= 1), 表示中到对应类型卡片的概率。&lt;br&gt;注意每袋干脆面最多只有一张卡片。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://hankin2015.github.io/categories/ACM/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="NEUQ" scheme="https://hankin2015.github.io/tags/NEUQ/"/>
    
  </entry>
  
  <entry>
    <title>一款好玩的游戏：饥荒</title>
    <link href="https://hankin2015.github.io/2018/11/08/20181108DontStarve/"/>
    <id>https://hankin2015.github.io/2018/11/08/20181108DontStarve/</id>
    <published>2018-11-08T11:48:41.000Z</published>
    <updated>2018-11-10T14:07:40.989Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=3c76e13a20f5e0fefa1581533d095fcd/a71ea8d3fd1f41345b63eb5d281f95cad1c85eb9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="饥荒-（2013年Klei-Entertainment出品单机游戏）"><a href="#饥荒-（2013年Klei-Entertainment出品单机游戏）" class="headerlink" title="饥荒 （2013年Klei Entertainment出品单机游戏）"></a>饥荒 （2013年Klei Entertainment出品单机游戏）</h1><p>《饥荒》是由Klei Entertainment开发的一款动作冒险类求生游戏，于2013年4月23日在PC上发行，2015年7月9日在iOS发布口袋版。<br>游戏讲述的是关于一名科学家被恶魔传送到了一个神秘的世界，玩家将在这个异世界生存并逃出这个异世界的故事。</p><p>Don’t Starve不要饿死<br>The Forge熔炉</p><a id="more"></a><h1 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h1><p>上帝模式，顾名思义是给小学生用的。<br>上帝模式：一般情况下不掉血，不掉脑残，不掉饥饿。<br>方法一：c_godmode()<br>方法二：GetPlayer().components.health:SetInvincible(true) </p><p>关闭：GetPlayer().components.health:SetInvincible(false)<br>跳虫洞、重进游戏都会关闭。</p><h1 id="复活石代码"><a href="#复活石代码" class="headerlink" title="复活石代码"></a>复活石代码</h1><p>似乎只能是房主的复活石有用。<br>c_spawn(“resurrectionstone”,1)</p><h1 id="饥荒移动手杖代码"><a href="#饥荒移动手杖代码" class="headerlink" title="饥荒移动手杖代码"></a>饥荒移动手杖代码</h1><p>c_give(“cane”,1)</p><h1 id="取企鹅蛋"><a href="#取企鹅蛋" class="headerlink" title="取企鹅蛋"></a>取企鹅蛋</h1><p>烧树火攻、晚上取蛋。</p><h1 id="存档"><a href="#存档" class="headerlink" title="存档"></a><a href="https://jingyan.baidu.com/article/5d368d1ef62fd33f60c05788.html" target="_blank" rel="noopener">存档</a></h1><p>C:\Users\用户名\Documents（win7以上）在里面找到Klei文件夹。<br>在Klei文件夹中，会有两个文件 DoNotStarve 和 DoNotStarveTogether 联机版的名称是DoNotStarveTogether</p><h1 id="植物患病"><a href="#植物患病" class="headerlink" title="植物患病"></a>植物患病</h1><p>铲掉，不然会传染。</p><h1 id="冒险模式"><a href="#冒险模式" class="headerlink" title="冒险模式"></a>冒险模式</h1><p>饥荒联机版没有冒险模式，冒险模式作用是来解锁人物的，联机版全解锁。</p><h1 id="羚羊、鬣狗、秃鹫和龙蝇"><a href="#羚羊、鬣狗、秃鹫和龙蝇" class="headerlink" title="羚羊、鬣狗、秃鹫和龙蝇"></a>羚羊、鬣狗、秃鹫和龙蝇</h1><p>羚羊：逼墙角或者晚上生火击杀。<br>秃鹫：丢肉吸引击杀。<br>龙蝇：龙蝇是游戏中拥有最高DPS 的生物。如果你在龙蝇愤怒时退出游戏，重新进入游戏时龙蝇会立即猛击地面。　多人版饥荒中，龙蝇有27500生命，是游戏中血量最高的生物。这使得即使多名玩家协力也难以杀死她。</p><h1 id="可疑的大理石"><a href="#可疑的大理石" class="headerlink" title="可疑的大理石"></a>可疑的大理石</h1><p>用铁镐敲雕像可以得到图纸和大理石块。一些雕像敲完就没有了，最终会留下3个雕像。没错这三个雕像分别是发条主教，发条骑士和发条战车。主教和骑士的头丢了，战车鼻子丢了，必须修复它。<br>可疑的大理石就是材料，直接背移动很慢，可疑骑牛，然后修补雕像，月圆之夜敲碎会复活。</p><h1 id="图纸的作用"><a href="#图纸的作用" class="headerlink" title="图纸的作用"></a>图纸的作用</h1><p>给制图。</p><h1 id="可疑的土堆"><a href="#可疑的土堆" class="headerlink" title="可疑的土堆"></a>可疑的土堆</h1><p>在饥荒游戏中，可疑土堆只有一个作用，那就是追踪无尾象啦。在主世界中，土堆会随机出现，如果我们不管它，这些土堆的位置还会改变。如果是有用的土堆，调查后会发现无尾象的脚印，而无尾象的位置就可以通过脚印来判断了，脚趾方向就是无尾象前进的方向了。这时候我们如果继续跟着脚印调查，大概两个满屏地图那么大，就可以找到无尾象了。<br>当我们调查到最后一个可以土堆的时候，游戏中会有角色对话，说该动物就在附近。玩家如果想顺利找到无尾象，就必须每个可疑土堆都调查一下，每次的土堆最少六个，最多有十二个。玩家调查过的交易会在一分钟后消失，如果没有找到下一个线索，就会追丢无尾象了。<br>当然了，有时就算我们调查了线索也不一定可以找到无尾象，因为有时调查的可疑土堆会提示这并不是无尾象的脚印哦。</p><p>持续8-10个会找到，分两种：夏象和冬象。<br>攻击一下拉仇恨，然后跑到圈里面。</p><h1 id="草蜥蜴"><a href="#草蜥蜴" class="headerlink" title="草蜥蜴"></a>草蜥蜴</h1><p>草会变异，然后变成四处乱跑的草蜥蜴，所以建议大家在新版联机种植的时候把草用墙围起来，没必要去花时间杀草蜥蜴，因为草蜥蜴受到惊吓就会掉落草，感觉比等草自己长大效率还高些额。</p><h1 id="养牛"><a href="#养牛" class="headerlink" title="养牛"></a>养牛</h1><p>杀牦牛，得牛角，吹牛角。</p><h1 id="夏季BOSS蚁狮"><a href="#夏季BOSS蚁狮" class="headerlink" title="夏季BOSS蚁狮"></a>夏季BOSS蚁狮</h1><p>会产生地震。准备保暖石击杀。<br><a href="https://www.gamersky.com/handbook/201704/889517.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201704/889517.shtml</a></p><h1 id="大理石种植"><a href="#大理石种植" class="headerlink" title="大理石种植"></a>大理石种植</h1><p>一个大理石合成一个大理石豌豆。</p><h1 id="驯牛"><a href="#驯牛" class="headerlink" title="驯牛"></a>驯牛</h1><p><a href="https://jingyan.baidu.com/article/3c343ff7ca50ab0d36796349.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/3c343ff7ca50ab0d36796349.html</a><br>1、使用新物品猫尾鞭<br>2、喂食，可以选择草，树枝（这个都吃）,蔬菜</p><p>永久。</p><h1 id="《饥荒》多肉的球茎怎么用"><a href="#《饥荒》多肉的球茎怎么用" class="headerlink" title="《饥荒》多肉的球茎怎么用?"></a>《饥荒》多肉的球茎怎么用?</h1><p>答：可以当种子种在地上，等长大了就可以刷肉，或者当狗牙陷阱一样当陷阱。</p><h1 id="舞台之饰"><a href="#舞台之饰" class="headerlink" title="舞台之饰"></a>舞台之饰</h1><p>天黑带灯引走，最好引到以后不太去的角落，不过我挺喜欢这个茶几的，花瓶里的花枯萎后可以用花瓣换上鲜花，每次还回5点精神，每次花瓶的的花也会不太一样。</p><h1 id="雪球发射器"><a href="#雪球发射器" class="headerlink" title="雪球发射器"></a>雪球发射器</h1><p>夏季必备。防止东西被烧毁。</p><p>雪球发射器没油解决方法介绍：加燃料，木头草树枝大便腐烂食物草根树苗木板绳子各种。</p><h1 id="发光的物品"><a href="#发光的物品" class="headerlink" title="发光的物品"></a>发光的物品</h1><p>在洞穴里有。</p><h1 id="蜂箱、种植花"><a href="#蜂箱、种植花" class="headerlink" title="蜂箱、种植花"></a>蜂箱、种植花</h1><p>每天能收蜂蜜，捕蝴蝶种植成花。</p><h1 id="如何杀海象"><a href="#如何杀海象" class="headerlink" title="如何杀海象"></a>如何杀海象</h1><h1 id="宝石来源"><a href="#宝石来源" class="headerlink" title="宝石来源"></a>宝石来源</h1><p>红宝石啊 有两种方法获得：第一：挖坟最简单了，准备一把铲子，去森林什么地方（坟多的）挖，很容易挖到。也有蓝宝石和紫宝石（齿轮，什么遗物什么的）。第二：打着火的那种（地狱狗）也有几率获得红宝石，如果要蓝宝石白色的（冰冻狗）获得蓝宝石，打发条教主死了会掉落紫宝石（远程攻击小心，我被他打死过几次）和齿轮。（齿轮可做冰箱）</p><h1 id="升级切斯特"><a href="#升级切斯特" class="headerlink" title="升级切斯特"></a>升级切斯特</h1><p>准备条件：9个蓝宝石（冰箱）或9个噩梦燃料（大宝箱）。<br>天时：月圆之夜。</p><h1 id="好用的mod"><a href="#好用的mod" class="headerlink" title="好用的mod"></a>好用的mod</h1><ul><li>minimap：小地图</li><li>fast travel：路标</li><li>建筑几何学：</li><li>show me：显示物品属性</li></ul><h1 id="《饥荒》熔炉模式人物能力介绍及打法攻略-饥荒熔炉模式怎么玩"><a href="#《饥荒》熔炉模式人物能力介绍及打法攻略-饥荒熔炉模式怎么玩" class="headerlink" title="《饥荒》熔炉模式人物能力介绍及打法攻略 饥荒熔炉模式怎么玩"></a>《饥荒》熔炉模式人物能力介绍及打法攻略 饥荒熔炉模式怎么玩</h1><p><a href="https://www.gamersky.com/handbook/201710/972043.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201710/972043.shtml</a></p><h1 id="老奶奶"><a href="#老奶奶" class="headerlink" title="老奶奶"></a>老奶奶</h1><p>老奶奶的优势在于自带2级科技，前期可以不用担心科技问题，而且只要地点合适就可以安家。而她携带的几种书籍，入睡觉书配合触手书与雷电书清怪效果很不错。<br>但是缺点同样明显，使用书籍需要消耗精神，可是不能睡觉，也就无法就地补充精神值，这也导致很容易出现精神过低的情况。同时由于血量低以及伤害偏低，所以打怪时间比较长。<br>总体老说最需要注意的就是脑残值，必须随时关注。脑残值建议带高帽，这比脑残片靠谱，当然其他各种食物什么的都可以备着。</p><p>老奶奶有失眠症，她的特点就是失眠，不能睡觉。<br>老奶奶不睡觉怎么补充精神<br>以试试这样恢复精神：<br>高礼帽+ 狗牙小背心，<br>贝雷帽效果更好，<br>不行就和二师兄做朋友，<br>吃烤熟的绿蘑菇和太妃糖加的精神也很多。</p><h1 id="完全正常的树"><a href="#完全正常的树" class="headerlink" title="完全正常的树"></a>完全正常的树</h1><p><a href="http://zh.dontstarve.wikia.com/wiki/%E6%A8%B9/%E5%AE%8C%E5%85%A8%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%A8%B9" target="_blank" rel="noopener">http://zh.dontstarve.wikia.com/wiki/%E6%A8%B9/%E5%AE%8C%E5%85%A8%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%A8%B9</a><br>不清楚添加三个什么东西可以装饰，但可以砍伐得活木。</p><h1 id="饥荒眼骨死了怎么办"><a href="#饥荒眼骨死了怎么办" class="headerlink" title="饥荒眼骨死了怎么办"></a>饥荒眼骨死了怎么办</h1><p>饥荒游戏中眼骨就是斯切特，它有复活功能，一般在死后过个两天左右，在它死时的原地方就可以发现它。然后重新捡起来即可使用。</p><h1 id="饥荒独立服务器搭建"><a href="#饥荒独立服务器搭建" class="headerlink" title="饥荒独立服务器搭建"></a>饥荒独立服务器搭建</h1><p><a href="http://lebi.github.io/2016/06/14/%E9%A5%A5%E8%8D%92%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">http://lebi.github.io/2016/06/14/%E9%A5%A5%E8%8D%92%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</a><br><a href="https://www.jianshu.com/p/440d64cd3ac4" target="_blank" rel="noopener">https://www.jianshu.com/p/440d64cd3ac4</a></p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>月圆之夜：采集花<br>科学机器<br>Y-发消息<br>M-地图<br>~-代码模式<br>tab-查看队友信息</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　可用Ctrl+F查询所需物品名称（大部分代码名称已修改成联机中文MOD翻译）。</p><p>　　进入游戏后按“～”键调出控制台</p><p>　　输入c_give(“代码名称“，数量）——物品会按所输数量出现在物品栏，假若包裹放不下，会自动掉落在地上。此代码最方便，甚至还可以在鼠标指针处直接放置建筑类物品。</p><p>　　c_spawn(“XX”，数量)——放鼠标指针指示的地上</p><p>　　上帝模式：c_godmode()</p><p>　　饥饿值上限：GetPlayer().components.hunger:SetMax(500)</p><p>　　精神值上限：GetPlayer().components.sanity:SetMax(500)</p><p>　　生命值上限：GetPlayer().components.health:SetMaxHealth(300)</p><p>　　全物品直接制造：GetPlayer().components.builder:GiveAllRecipes()</p><p>　　删除物品：TheInput:GetWorldEntityUnderMouse():Remove()</p><p>　　传送：GetPlayer().Transform:SetPosition(坐标，例：0,0,0)</p><p>　　此列表已剔除一些对于联机无效的代码，测试过真实有效。</p><h1 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h1><p>　　割下的草：cutgrass</p><p>　　树枝：twigs</p><p>　　木头：log</p><p>　　木炭：charcoal</p><p>　　灰：ash</p><p>　　采集的芦苇：cutreeds</p><p>　　花瓣：petals</p><p>　　噩梦花瓣：petals_evil</p><p>　　活木头：livinglog</p><p>　　叶子：foliage</p><p>　　荧光果：lightbulb</p><p>　　发光浆果：wormlight</p><p>　　冰：ice</p><p>　　燧石：flint</p><p>　　硝石：nitre</p><p>　　岩石：rocks</p><p>　　大理石：marble</p><p>　　月之石：moonrocknugget</p><p>　　黄金：goldnugget</p><p>　　铥矿石：thulecite</p><p>　　铥矿石碎片：thulecite_pieces</p><p>　　红宝石：redgem</p><p>　　蓝宝石：bluegem</p><p>　　紫宝石：purplegem</p><p>　　绿宝石：greengem</p><p>　　橙宝石：orangegem</p><p>　　黄宝石：yellowgem</p><p>　　彩色宝石：opalpreciousgem</p><p>　　绳子：rope</p><p>　　木板：boards</p><p>　　石砖：cutstone</p><p>　　莎草纸：papyrus</p><p>　　噩梦燃料：nightmarefuel</p><p>　　蜂蜡：beeswax</p><p>　　蜡纸：waxpaper</p><p>　　电器元件：transistor</p><p>　　狗牙：houndstooth</p><p>　　蜘蛛丝：silk</p><p>　　蜘蛛腺体：spidergland</p><p>　　胡子：beardhair</p><p>　　牛毛：beefalowool</p><p>　　牛角：hornm</p><p>　　猫尾：coontail</p><p>　　海象牙：walrus_tusk</p><p>　　胡须：beardhair</p><p>　　烂鸡蛋：rottenegg</p><p>　　乌鸦羽毛：feather_crow</p><p>　　红雀羽毛：feather_robin</p><p>　　雪雀羽毛：feather_robin_winter</p><p>　　金丝雀羽毛：feather_canary</p><p>　　鸟粪：guano</p><p>　　触手皮：tentaclespots</p><p>　　粘滑含糊虫（黏糊虫粘液）：slurtleslime</p><p>　　破碎的背壳：slurtle_shellpieces</p><p>　　蚊子血袋：mosquitosack</p><p>　　缀食者皮：slurper_pelt</p><p>　　远古守护者角：minotaurhorn</p><p>　　掉落的羽毛：goose_feather</p><p>　　鳞片：dragon_scales</p><p>　　厚皮毛：bearger_fur</p><p>　　巨鹿眼球：deerclops_eyeball</p><p>　　毒蕈皮：shroom_skin</p><p>　　闪电羊角：lightninggoathorn</p><p>　　格罗门翅膀：glommerwings</p><p>　　格罗门花（花瞬间死亡）：glommerflower</p><p>　　格罗门燃料：glommerfuel</p><p>　　冷冻虫卵：lavae_cocoon</p><p>　　暗影之心：shadowheart</p><p>　　鹿茸：deer_antler</p><p>　　克劳斯钥匙：klaussackkey</p><p>　　齿轮：gears</p><p>　　骨片：boneshard</p><p>　　化石碎片（据说多种实际上只出一种）：fossil_piece</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>　　斧头：axe</p><p>　　金斧头：goldenaxe</p><p>　　露西斧：lucy</p><p>　　鹤嘴锄：pickaxe</p><p>　　黄金鹤嘴锄：goldenpickaxe</p><p>　　铁铲：shovel</p><p>　　黄金铁铲（讲真黄金做的还能叫铁铲）：goldenshovel</p><p>　　镐斧：multitool_axe_pickaxe</p><p>　　锤子：hammer</p><p>　　草叉：pitchfork</p><p>　　剃刀：razor</p><p>　　捕虫网：bugnet</p><p>　　鱼竿：fishingrod</p><p>　　陷阱：trap</p><p>　　鸟陷阱：birdtrap</p><p>　　南瓜灯：pumpkin_lantern</p><p>　　提灯：lantern</p><p>　　漂亮太阳伞：grass_umbrella</p><p>　　雨伞：umbrella</p><p>　　保温石：heatrock</p><p>　　水球：waterballoon</p><p>　　指南针：compass</p><p>　　空包裹：bundlewrap</p><p>　　彩纸：giftwrap</p><p>　　稻草卷：bedroll_straw</p><p>　　毛皮铺盖：bedroll_furry</p><p>　　鹅毛扇：featherfan</p><p>　　狗牙陷阱：trap_teeth</p><p>　　麦斯威尔的利齿陷阱：trap_teeth_maxwell</p><p>　　背包：backpack</p><p>　　猪皮包：piggyback</p><p>　　隔热包：icepack</p><p>　　坎普斯背包：krampus_sack</p><p>　　糖果袋：candybag</p><p>　　羽毛笔：featherpencil</p><p>　　便便蓝：fertilizer</p><p>　　取鞍器：saddlehorn</p><p>　　鞍：saddle_basic</p><p>　　浴血战鞍：saddle_war</p><p>　　闪亮之鞍：saddle_race</p><p>　　刷子：brush</p><p>　　舐盐器：saltlick</p><p>武器</p><p>　　长矛：spear</p><p>　　瓦丝格雷斯矛：spear_wathgrithr</p><p>　　气球（吹好的，可以装饰自己的窝~）：balloon</p><p>　　火腿球棒：hambat</p><p>　　触手尖刺：tentaclespike</p><p>　　晨星：nightstick</p><p>　　三脚猫的教诲：whip</p><p>　　暗影剑：nightsword</p><p>　　蝙蝠斧棍：batbat</p><p>　　铥矿棒：ruins_bat</p><p>　　冰魔杖（蓝）：icestaff</p><p>　　火魔杖（红）：firestaff</p><p>　　传送魔杖（紫）：telestaff</p><p>　　懒惰的探索者（橙）：orangestaff</p><p>　　星星呼唤者（黄）：yellowstaff</p><p>　　毁灭权杖（绿）：greenstaff</p><p>　　魔杖（单机用来找零件那个）：diviningrod</p><p>　　呼月者权杖：opalstaff</p><p>　　回旋镖：boomerang</p><p>　　吹箭：blowdart_pipe</p><p>　　燃烧吹箭：blowdart_fire</p><p>　　麻醉吹箭：blowdart_sleep</p><p>　　电磁吹箭：blowdart_yellow</p><p>　　旋风：staff_tornado</p><p>　　排箫：panflute</p><p>　　独奏乐器:onemanband</p><p>　　火药：gunpowder</p><p>　　蜜蜂地雷：beemine</p><p>　　恒迪尤斯·舒提尤斯（眼睛炮塔）：eyeturret</p><p>　　可放置的眼睛炮塔：eyeturret_item</p><p><a href="https://www.gamersky.com/handbook/201701/859832.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201701/859832.shtml</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=3c76e13a20f5e0fefa1581533d095fcd/a71ea8d3fd1f41345b63eb5d281f95cad1c85eb9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;h1 id=&quot;饥荒-（2013年Klei-Entertainment出品单机游戏）&quot;&gt;&lt;a href=&quot;#饥荒-（2013年Klei-Entertainment出品单机游戏）&quot; class=&quot;headerlink&quot; title=&quot;饥荒 （2013年Klei Entertainment出品单机游戏）&quot;&gt;&lt;/a&gt;饥荒 （2013年Klei Entertainment出品单机游戏）&lt;/h1&gt;&lt;p&gt;《饥荒》是由Klei Entertainment开发的一款动作冒险类求生游戏，于2013年4月23日在PC上发行，2015年7月9日在iOS发布口袋版。&lt;br&gt;游戏讲述的是关于一名科学家被恶魔传送到了一个神秘的世界，玩家将在这个异世界生存并逃出这个异世界的故事。&lt;/p&gt;
&lt;p&gt;Don’t Starve不要饿死&lt;br&gt;The Forge熔炉&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://hankin2015.github.io/categories/Others/"/>
    
    
      <category term="Game" scheme="https://hankin2015.github.io/tags/Game/"/>
    
      <category term="饥荒" scheme="https://hankin2015.github.io/tags/%E9%A5%A5%E8%8D%92/"/>
    
  </entry>
  
  <entry>
    <title>判断一个点是否在一个多边形内</title>
    <link href="https://hankin2015.github.io/2018/11/03/20181103poly/"/>
    <id>https://hankin2015.github.io/2018/11/03/20181103poly/</id>
    <published>2018-11-03T03:48:41.000Z</published>
    <updated>2018-11-03T11:54:27.313Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。</p><a id="more"></a><h1 id="简单的特例：三角形"><a href="#简单的特例：三角形" class="headerlink" title="简单的特例：三角形"></a>简单的特例：三角形</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>比较常用的算法是射线法，以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。<br>若有偶数个交点则在形外，否则在形内。<br>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>面积法：海伦公式、向量公式</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>向量法</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://hihocoder.com/contest/hiho225/problem/1" target="_blank" rel="noopener">http://hihocoder.com/contest/hiho225/problem/1</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">在三角形内部的点形成的都是钝角三角形</span><br><span class="line">点在x,y的中间并不能判断</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long double</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">LL Heron(LL a, LL b, LL c)</span><br><span class="line">&#123;</span><br><span class="line">    return 0.25 * sqrt((a + b + c) * (a + b - c) * (a + c - b) * (b + c - a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Distance(LL x1, LL y1, LL x2, LL y2)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        LL x[4], y[4];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        LL s = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; 4; j++) &#123;</span><br><span class="line">                LL a = Distance(x[0], y[0], x[i], y[i]), b = Distance(x[0], y[0], x[j], y[j]), c = Distance(x[i], y[i], x[j], y[j]);</span><br><span class="line">                s += Heron(a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Distance(x[1], y[1], x[2], y[2]), b = Distance(x[1], y[1], x[3], y[3]), c = Distance(x[2], y[2], x[3], y[3]);</span><br><span class="line">        //cout &lt;&lt; s &lt;&lt; &apos; &apos; &lt;&lt; Heron(a, b, c) &lt;&lt; endl;</span><br><span class="line">        if (abs(s - Heron(a, b, c)) &lt; eps) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入的都是整数，三角形面积计算s=0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">所有面积里都有这个0.5，去掉这个0.5对结果不影响，于是面积计算出来就是整数，没有精度问题了。</span><br><span class="line">向量法求面积。</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">LL area(LL x1,LL y1,LL x2,LL y2,LL x3,LL y3)</span><br><span class="line">&#123;</span><br><span class="line">    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LL Px, Py, Ax, Ay, Bx, By, Cx, Cy;</span><br><span class="line">    LL S, S1, S2, S3;</span><br><span class="line">    LL t;</span><br><span class="line">    for(cin&gt;&gt;t;t&gt;0;t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;Px&gt;&gt;Py&gt;&gt;Ax&gt;&gt;Ay&gt;&gt;Bx&gt;&gt;By&gt;&gt;Cx&gt;&gt;Cy;</span><br><span class="line">        S  = area(Ax, Ay, Bx, By, Cx, Cy);</span><br><span class="line">        S1 = area(Px, Py, Ax, Ay, Bx, By);</span><br><span class="line">        S2 = area(Px, Py, Ax, Ay, Cx, Cy);</span><br><span class="line">        S3 = area(Px, Py, Bx, By, Cx, Cy);</span><br><span class="line">        if(S1+S2+S3&lt;=S)cout&lt;&lt;&quot;YES\n&quot;;else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">还有个简单的方法，判断三条边的向量与P跟三个点连接的向量的叉积，如果三个叉积值同正负，则在三角形内。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define G(v,_) scanf(&quot;%ld&quot;,&amp;v),v-=_;</span><br><span class="line">main(T)&#123;long p,P,a,A,b,B,c,C,x,y,z;for(G(T,0)T--;puts(((-x|-y|-z)&amp;(x|y|z))&lt;0?&quot;NO&quot;:&quot;YES&quot;))&#123;G(p,0)G(P,0)G(a,p)G(A,P)G(b,p)G(B,P)G(c,p)G(C,P)x=a*B-b*A;y=b*C-c*B;z=c*A-a*C;&#125;return 0;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四边形特例：矩形"><a href="#四边形特例：矩形" class="headerlink" title="四边形特例：矩形"></a>四边形特例：矩形</h1><p>（1）面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。<br>（2）夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。<br>（3）引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</p><p><a href="https://blog.csdn.net/u283056051/article/details/53980832" target="_blank" rel="noopener">https://blog.csdn.net/u283056051/article/details/53980832</a><br>1、射线法理论：从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。<br>2、特殊情况特殊处理：</p><pre><code>1. 点在多边形的边上 ：判断点与边端点连线斜率是否相同。2. 点和多边形的顶点重合 ：直接hash。3. 射线经过多边形顶点：只需要规定被射线穿越的点都算作其中一侧。 4. 射线刚好经过多边形的一条边：上面的特例，经过两个顶点。射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。</code></pre><h1 id="多边形代码（射线法和回转数法）"><a href="#多边形代码（射线法和回转数法）" class="headerlink" title="多边形代码（射线法和回转数法）"></a>多边形代码（射线法和回转数法）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">测试题：http://hihocoder.com/problemset/problem/1450?sid=1416458</span><br><span class="line">射线法没有过，回转数法连样例都不了，还弄不明白哪里错了。</span><br><span class="line">参考：https://blog.csdn.net/u283056051/article/details/53980832</span><br><span class="line">*/</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1e3 + 5;</span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">const double PI = atan(1) * 4;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 射线法</span><br><span class="line">string RayCasting(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey)) return &quot;on&quot;;</span><br><span class="line">        // 2、做一条水平射线，判断边两断点是否在射线两侧，并令穿过顶点的点在上端</span><br><span class="line">        if ((sy &lt; p.y &amp;&amp; ey &gt;= p.y) || (sy &gt;= p.y &amp;&amp; ey &lt; p.y)) &#123;</span><br><span class="line">            // 3、判断p点是否在多边形边上，斜率公式或者三角形比例公式（方便）</span><br><span class="line">            double x = sx + (p.y - sy) * (ex - sx) * 1.0 / (ey - sy);</span><br><span class="line">            if (abs(x - p.x) &lt; eps) return &quot;on&quot;;</span><br><span class="line">            // 水平向右作的射线，穿过一次就变换</span><br><span class="line">            if (x &gt; p.x) flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? &quot;in&quot; : &quot;out&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回转数法</span><br><span class="line">string WindingNumber(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0;  // 回转度数和</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合或在多边形边上</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey) || (p.x - sx) * (ey - sy) == (p.y - sy) * (ex - sx)) return &quot;on&quot;;</span><br><span class="line">        // 2、求夹角</span><br><span class="line">        double angle = atan((sy - p.y) * 1.0 / (sx - p.x)) - atan((ey - p.y) * 1.0 / (ex - p.x));</span><br><span class="line">        cout &lt;&lt; angle &lt;&lt; endl;</span><br><span class="line">        // 3、确保夹角不超过取值范围（-PI到PI）</span><br><span class="line">        if (angle &gt;= PI) angle -= 2 * PI;</span><br><span class="line">        else if (angle &lt;= -PI) angle += 2 * PI;</span><br><span class="line">        sum += angle;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    // 4、计算回转数</span><br><span class="line">    return round(sum / PI) == 0 ? &quot;out&quot; : &quot;in&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node p, poly[maxn];</span><br><span class="line">    int n = 3, T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        cin &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; poly[i].x &gt;&gt; poly[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        string res1 = RayCasting(p, poly, 3);</span><br><span class="line">        string res2 = WindingNumber(p, poly, 3);</span><br><span class="line">        if (res1 != res2) cout &lt;&lt; &quot;Wrong&quot; &lt;&lt; endl;</span><br><span class="line">        else if (res1 == &quot;out&quot;) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="https://hankin2015.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="凸包" scheme="https://hankin2015.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://hankin2015.github.io/2018/10/31/20181031topo/"/>
    <id>https://hankin2015.github.io/2018/10/31/20181031topo/</id>
    <published>2018-10-31T03:48:41.000Z</published>
    <updated>2018-11-03T12:22:40.474Z</updated>
    
    <content type="html"><![CDATA[<p>Face++面试中遇到的问题，手写一个拓扑排序函数，数据按照链式存储，即每个点链表存储出度的点。<br>当时想出了一种解决方法，不过看了其他解法，感觉自己的方法有点复杂，不过时间复杂度都是O(n^2)。</p><p>我当时的想法：正序没法找到拓扑的前后顺序，但是反过来就迎刃而解。从结束点（出度为0）开始，入队列。然后将入度当前点的点加入队列中。这样就找到了反序的拓扑序列，然后利用栈的特点反转就得到答案了。<br>当时面试官还和我谈论验证这个解法，但我觉得没啥问题。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">提示：跟一般的排序不一样，这个用于有向无环图</span><br><span class="line"></span><br><span class="line">对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，</span><br><span class="line">使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。</span><br><span class="line"></span><br><span class="line">拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某</span><br><span class="line">些工程执行后才可以执行。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span><br><span class="line">//优先队列的话，会按照数值大小有顺序的输出</span><br><span class="line">//此处为了理解，暂时就用简单队列</span><br><span class="line">int topo()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(indegree[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);  // 起点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=q.front();// 如果是优先队列，这里可以是top()</span><br><span class="line">        printf(&quot;%d-&gt;&quot;,temp);</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)// 遍历从temp出发的每一条边，入度--</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[temp][i])</span><br><span class="line">            &#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                if(indegree[i]==0)q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Face++面试中遇到的问题，手写一个拓扑排序函数，数据按照链式存储，即每个点链表存储出度的点。&lt;br&gt;当时想出了一种解决方法，不过看了其他解法，感觉自己的方法有点复杂，不过时间复杂度都是O(n^2)。&lt;/p&gt;
&lt;p&gt;我当时的想法：正序没法找到拓扑的前后顺序，但是反过来就迎刃而解。从结束点（出度为0）开始，入队列。然后将入度当前点的点加入队列中。这样就找到了反序的拓扑序列，然后利用栈的特点反转就得到答案了。&lt;br&gt;当时面试官还和我谈论验证这个解法，但我觉得没啥问题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="拓扑排序" scheme="https://hankin2015.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序" scheme="https://hankin2015.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>python中os模块</title>
    <link href="https://hankin2015.github.io/2018/10/27/20181027os/"/>
    <id>https://hankin2015.github.io/2018/10/27/20181027os/</id>
    <published>2018-10-27T03:48:41.000Z</published>
    <updated>2018-11-06T03:35:30.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判读文件和文件夹是否存在"><a href="#判读文件和文件夹是否存在" class="headerlink" title="判读文件和文件夹是否存在"></a>判读文件和文件夹是否存在</h1><p>文件能直接保存创建，但文件夹不行，需要先创建文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">if not os.path.exists(&apos;name&apos;):  # 能判断文件和文件夹</span><br><span class="line">os.mkdir(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">os.path.isfile(&apos;name&apos;)  # 只能判断文件</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用os.access()方法判断文件是否可进行读写操作。</p><p>语法：os.access(path, mode)</p><p>path为文件路径，mode为操作模式，有这么几种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.F_OK: 检查文件是否存在;</span><br><span class="line">os.R_OK: 检查文件是否可读;</span><br><span class="line">os.W_OK: 检查文件是否可以写入;</span><br><span class="line">os.X_OK: 检查文件是否可以执行.</span><br><span class="line"></span><br><span class="line">if not os.access(&apos;name&apos;, os.F_OK):</span><br><span class="line">os.mkdir(&apos;name&apos;)</span><br></pre></td></tr></table></figure></p><p>try语句也能，但尽量少用。<br>os.makedirs(path) 多层创建目录</p><h1 id="获取当前文件夹下所有文件"><a href="#获取当前文件夹下所有文件" class="headerlink" title="获取当前文件夹下所有文件"></a>获取当前文件夹下所有文件</h1><p>使用os.walk()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dataPath = &apos;./Unprocessed/&apos; </span><br><span class="line">def ListFile(fileDir):   </span><br><span class="line">    ret = []   </span><br><span class="line">    for root, dirs, files in os.walk(fileDir):  </span><br><span class="line">        for file in files:  </span><br><span class="line">            if os.path.splitext(file)[1] == &apos;.txt&apos;:   #其中os.path.splitext()函数将路径拆分为文件名+扩展名</span><br><span class="line">                ret.append(os.path.join(root, file))  </span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line">files = ListFile(dataPath)</span><br></pre></td></tr></table></figure></p><h1 id="使用os模块进行分类整理"><a href="#使用os模块进行分类整理" class="headerlink" title="使用os模块进行分类整理"></a>使用os模块进行分类整理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">path = &apos;./&apos;</span><br><span class="line">files = os.listdir(path)</span><br><span class="line"></span><br><span class="line">for file in files:</span><br><span class="line">folderName = &apos;./&apos; + file.split(&apos;.&apos;)[-1]</span><br><span class="line">if not os.path.exists(folderName):</span><br><span class="line">os.makedirs(folderName)</span><br><span class="line">shutil.move(file, folderName)</span><br><span class="line"></span><br><span class="line">print(&apos;done&apos;)</span><br></pre></td></tr></table></figure><h1 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;&apos;key1&apos; : [&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;a&apos;],</span><br><span class="line">    &apos;key2&apos; : [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;],</span><br><span class="line">    &apos;data1&apos; : np.random.randint(0, 9),</span><br><span class="line">    &apos;data2&apos; : np.random.randint(0, 9)&#125;)</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使数据data1列按照key1进行分组</span><br><span class="line">grouped = df[&apos;data1&apos;].groupby(df[&apos;key1&apos;])  # 需要注意grouped的数据类型，它不在是一个数据框，而是一个GroupBy对象。</span><br><span class="line">grouped</span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line">for name, group in grouped:</span><br><span class="line">    print(name)</span><br><span class="line">    print(group)</span><br><span class="line"></span><br><span class="line"># 做其他计算</span><br><span class="line">grouped.mean()</span><br></pre></td></tr></table></figure><p>看一个大佬的代码语句：</p><blockquote><p>train_df.groupby(‘pred_len’)[‘label’].agg({‘mean’,’count’}).reset_index().sort_values(by=’mean’, ascending=False)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;&apos;key1&apos; : [&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;a&apos;],</span><br><span class="line">    &apos;key2&apos; : [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;],</span><br><span class="line">    &apos;data1&apos; : np.random.randint(0, 9),</span><br><span class="line">    &apos;data2&apos; : np.random.randint(0, 9)&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h1 id="nunique"><a href="#nunique" class="headerlink" title="nunique"></a>nunique</h1><p>nuinque()是查看该序列(axis=0/1对应着列或行)的不同值的数量。用这个函数可以查看数据有多少个不同值。</p><h1 id="stack-、hstack-、vstack"><a href="#stack-、hstack-、vstack" class="headerlink" title="stack()、hstack()、vstack()"></a>stack()、hstack()、vstack()</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack()"></a>stack()</h2><p>stack的意思是堆叠，堆积，unstack即“不要堆叠”，我对两个函数是这样理解和区分的。<br><a href="https://www.cnblogs.com/bambipai/p/7658311.html" target="_blank" rel="noopener">https://www.cnblogs.com/bambipai/p/7658311.html</a></p><h2 id="hstack"><a href="#hstack" class="headerlink" title="hstack()"></a>hstack()</h2><p>水平(按列顺序)把数组给堆叠起来，vstack()函数正好和它相反。</p><h2 id="vstack"><a href="#vstack" class="headerlink" title="vstack()"></a>vstack()</h2><p>垂直（按照行顺序）的把数组给堆叠起来。</p><h1 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h1><p>str.replace(old, new[, max])<br>参数<br>old – 将被替换的子字符串。<br>new – 新字符串，用于替换old子字符串。<br>max – 可选字符串, 替换不超过 max 次</p><h1 id="This-is-beacause…"><a href="#This-is-beacause…" class="headerlink" title="This is beacause…"></a>This is beacause…</h1><p> It/This/That is because……，该句型是because 引导的表语从句。</p><p> 通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><h1 id="first和firstly的区别是什么"><a href="#first和firstly的区别是什么" class="headerlink" title="first和firstly的区别是什么?"></a>first和firstly的区别是什么?</h1><p>first：可以做名词，副词，形容词，第一，首先。除了用于开场白，还有第一的意思 。firstly ：形容词，强调第一个（做完的），最先的。</p><p>注意事项：<br>当first和firstly作副词用的时侯，如果“用于分开并依次列举所述各点”时，是没有什么区别的，可以替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判读文件和文件夹是否存在&quot;&gt;&lt;a href=&quot;#判读文件和文件夹是否存在&quot; class=&quot;headerlink&quot; title=&quot;判读文件和文件夹是否存在&quot;&gt;&lt;/a&gt;判读文件和文件夹是否存在&lt;/h1&gt;&lt;p&gt;文件能直接保存创建，但文件夹不行，需要先创建文件夹。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if not os.path.exists(&amp;apos;name&amp;apos;):  # 能判断文件和文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	os.mkdir(&amp;apos;name&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.path.isfile(&amp;apos;name&amp;apos;)  # 只能判断文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="https://hankin2015.github.io/categories/PYTHON/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="Os" scheme="https://hankin2015.github.io/tags/Os/"/>
    
      <category term="Groupby" scheme="https://hankin2015.github.io/tags/Groupby/"/>
    
      <category term="Replace" scheme="https://hankin2015.github.io/tags/Replace/"/>
    
      <category term="stack" scheme="https://hankin2015.github.io/tags/stack/"/>
    
      <category term="vstack" scheme="https://hankin2015.github.io/tags/vstack/"/>
    
      <category term="hstack" scheme="https://hankin2015.github.io/tags/hstack/"/>
    
  </entry>
  
  <entry>
    <title>删除字符串指针中空格和统计文章中的最频繁词</title>
    <link href="https://hankin2015.github.io/2018/10/26/20181026DeleteSpace/"/>
    <id>https://hankin2015.github.io/2018/10/26/20181026DeleteSpace/</id>
    <published>2018-10-26T09:25:41.000Z</published>
    <updated>2018-10-27T02:57:37.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针函数和函数指针的区别"><a href="#指针函数和函数指针的区别" class="headerlink" title="指针函数和函数指针的区别"></a>指针函数和函数指针的区别</h1><p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p><p><a href="https://baijiahao.baidu.com/s?id=1580218358235866033&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">百度搜索特效：搜索黑洞，屏幕真的出现了黑洞一样的画面</a></p><a id="more"></a><h1 id="删除字符串指针中空格"><a href="#删除字符串指针中空格" class="headerlink" title="删除字符串指针中空格"></a>删除字符串指针中空格</h1><ul><li>原始字符串不能是指针字符串，因不能对其本身进行修改</li><li>必须需要两个指针</li><li>末尾需置”\0”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">DeleteSpace</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = str, *q = str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">while</span> (*q != <span class="string">'\0'</span>) &#123;  <span class="comment">// 指针字符串没有"\0"，但char数组有</span></span><br><span class="line">        <span class="keyword">if</span> (*q != <span class="string">' '</span>) &#123;</span><br><span class="line">            *p = *q;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char* str = "  he jian  ";   // 不能写成指针字符串，指针不能对其值进行修改</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"  he jian  "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; DeleteSpace(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="assert进行样例调试"><a href="#assert进行样例调试" class="headerlink" title="assert进行样例调试"></a>assert进行样例调试</h1><ul><li>报错会出现Assertion failed: fun(5) == 6, file C:\Users\Administrator\Desktop\腾讯.cpp, line 41</li><li>不报错正常运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    assert(fun(5) == 6);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="统计文章中的最频繁K个词"><a href="#统计文章中的最频繁K个词" class="headerlink" title="统计文章中的最频繁K个词"></a>统计文章中的最频繁K个词</h1><ul><li>hash + 优先队列</li><li>堆<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//出现次数最多的是个单词  </span><br><span class="line">void top_k_words()  </span><br><span class="line">&#123;  </span><br><span class="line">    timer t;  </span><br><span class="line">    ifstream fin;  </span><br><span class="line">    fin.open(&quot;modern c.txt&quot;);  </span><br><span class="line">    if (!fin)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;can nont open file&quot;&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    string s;  </span><br><span class="line">    hash_map&lt;string,int&gt; countwords;  </span><br><span class="line">    while (true)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fin&gt;&gt;s;  </span><br><span class="line">        if (fin.eof())  </span><br><span class="line">        &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        countwords[s]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;&quot;单词总数 （重复的不计数）:&quot;&lt;&lt;countwords.size()&lt;&lt;endl;  </span><br><span class="line">    priority_queue&lt;pair&lt;int,string&gt;,vector&lt;pair&lt;int,string&gt;&gt;,greater&lt;pair&lt;int,string&gt;&gt;&gt; countmax;  </span><br><span class="line">    for(hash_map&lt;string,int&gt;::const_iterator i=countwords.begin();  </span><br><span class="line">        i!=countwords.end();i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        countmax.push(make_pair(i-&gt;second,i-&gt;first));  </span><br><span class="line">        if (countmax.size()&gt;10)  </span><br><span class="line">        &#123;  </span><br><span class="line">            countmax.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    while(!countmax.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;countmax.top().second&lt;&lt;&quot; &quot;&lt;&lt;countmax.top().first&lt;&lt;endl;  </span><br><span class="line">        countmax.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;&quot;time elapsed &quot;&lt;&lt;t.elapsed()&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><ul><li>top</li><li>size</li><li>empty</li><li>push</li><li>pop<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">void PQueue()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;   // 按照元素从小到大的顺序出队</span><br><span class="line">    //priority_queue&lt;pair&lt;int,string&gt;,vector&lt;pair&lt;int,string&gt;&gt;,greater&lt;pair&lt;int,string&gt;&gt;&gt; countMax;</span><br><span class="line"></span><br><span class="line">    int A[] = &#123;7, 5, 2, 1, 3, 4, 6&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">        Q.push(A[i]);</span><br><span class="line">        int tmp = Q.top();</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PQueue();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针函数和函数指针的区别&quot;&gt;&lt;a href=&quot;#指针函数和函数指针的区别&quot; class=&quot;headerlink&quot; title=&quot;指针函数和函数指针的区别&quot;&gt;&lt;/a&gt;指针函数和函数指针的区别&lt;/h1&gt;&lt;p&gt;指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。&lt;br&gt;函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1580218358235866033&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度搜索特效：搜索黑洞，屏幕真的出现了黑洞一样的画面&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="Char" scheme="https://hankin2015.github.io/tags/Char/"/>
    
      <category term="指针" scheme="https://hankin2015.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="优先队列" scheme="https://hankin2015.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>bat和vbs脚本</title>
    <link href="https://hankin2015.github.io/2018/10/22/20181022bat_vbs/"/>
    <id>https://hankin2015.github.io/2018/10/22/20181022bat_vbs/</id>
    <published>2018-10-22T09:43:41.000Z</published>
    <updated>2018-10-27T02:56:48.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bat和vbs脚本"><a href="#bat和vbs脚本" class="headerlink" title="bat和vbs脚本"></a>bat和vbs脚本</h1><p>bat脚本是依赖于cmd命令窗口的一种脚本语言。vbs脚本是使用vbasic语言编写的脚本语言，基于wscript.exe程序来运行。两者语法上相差很大.vbs脚本功能更加地强大，他能调用dll动态库完成一些bat不能完成的功能。同时bat与vbs可以互相调用。</p><p>bat是批处文件，实际上是一条条dos命令的集合，由命令行调用。vbs是vb脚本文件，当然还有java脚本文件，vbs由vb语言写成，但他不需要vb那样的编译环境，只要是文本编辑器都可以，他由系统的脚本解释器执行，一般vbs脚本都用在网页中，用于显示一些特效或特殊的用途。<br><a id="more"></a></p><h1 id="自动关机脚本-bat"><a href="#自动关机脚本-bat" class="headerlink" title="自动关机脚本(bat)"></a>自动关机脚本(bat)</h1><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -s -t <span class="number">60</span></span><br><span class="line"></span><br><span class="line">取消 shutdown -a</span><br></pre></td></tr></table></figure><h1 id="隐藏文件-bat"><a href="#隐藏文件-bat" class="headerlink" title="隐藏文件(bat)"></a>隐藏文件(bat)</h1><p>可以将两个不同格式的文件合在一起。<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>/b 何健.jpg+皂片.rar=out.jpg</span><br></pre></td></tr></table></figure></p><h1 id="语音助手-vbs"><a href="#语音助手-vbs" class="headerlink" title="语音助手(vbs)"></a>语音助手(vbs)</h1><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateObject</span>(<span class="string">"SAPI.SpVoice"</span>).speak<span class="string">"机器学习中，如果参数过多，模型过于复杂，容易造成过拟合（overfit）。即模型在训练样本数据上表现的很好，但在实际测试样本上表现的较差，不具备良好的泛化能力。为了避免过拟合，最常用的一种方法是使用使用正则化，例如 L1 和 L2 正则化。但是，正则化项是如何得来的？其背后的数学原理是什么？L1 正则化和 L2 正则化之间有何区别？本文将给出直观的解释。"</span></span><br></pre></td></tr></table></figure><h1 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GodMode.&#123;ED7BA470-8E54-465E-825C-99712043E01C&#125;</span><br><span class="line">新建文件夹-》用上面代码重命名</span><br><span class="line"></span><br><span class="line">隐藏的一个文件夹窗口，包含几乎所有系统的设置。</span><br></pre></td></tr></table></figure><h1 id="黑客帝国中的数字雨"><a href="#黑客帝国中的数字雨" class="headerlink" title="黑客帝国中的数字雨"></a>黑客帝国中的数字雨</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/qq_36238595/article/details/56682261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU st[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//出现位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hout;</span><br><span class="line">    COORD pos;</span><br><span class="line">    pos.X = x;</span><br><span class="line">    pos.Y = y;</span><br><span class="line"></span><br><span class="line">    hout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    SetConsoleCursorPosition(hout, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐藏光标*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_cursor</span><span class="params">(<span class="keyword">int</span> hide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONSOLE_CURSOR_INFO cciCursor;</span><br><span class="line">    HANDLE hout;</span><br><span class="line"></span><br><span class="line">    hout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    <span class="keyword">if</span>(GetConsoleCursorInfo(hout, &amp;cciCursor))</span><br><span class="line">    &#123;</span><br><span class="line">        cciCursor.bVisible = hide;</span><br><span class="line">        SetConsoleCursorInfo(hout, &amp;cciCursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置颜色*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">show_cursor(<span class="number">0</span>);</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i].x = rand()%<span class="number">80</span>;</span><br><span class="line">st[i].y = rand()%<span class="number">20</span>;</span><br><span class="line">st[i].ch = rand()%(<span class="number">49</span><span class="number">-47</span>)+<span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">gotoxy(st[i].x,st[i].y);</span><br><span class="line">set_color(<span class="number">0x2</span>);</span><br><span class="line"><span class="built_in">putchar</span>(st[i].ch);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-5</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">st[i].y++;</span><br><span class="line">st[i].ch = rand()%(<span class="number">49</span><span class="number">-47</span>)+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">if</span> (st[i].y<span class="number">-5</span>&gt;=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-3</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st[i].y &gt; <span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">st[i].x = rand()%<span class="number">80</span>;</span><br><span class="line">st[i].y = rand()%<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">gotoxy(st[i].x,st[i].y);</span><br><span class="line">set_color(<span class="number">0xA</span>);</span><br><span class="line"><span class="built_in">putchar</span>(st[i].ch);</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;bat和vbs脚本&quot;&gt;&lt;a href=&quot;#bat和vbs脚本&quot; class=&quot;headerlink&quot; title=&quot;bat和vbs脚本&quot;&gt;&lt;/a&gt;bat和vbs脚本&lt;/h1&gt;&lt;p&gt;bat脚本是依赖于cmd命令窗口的一种脚本语言。vbs脚本是使用vbasic语言编写的脚本语言，基于wscript.exe程序来运行。两者语法上相差很大.vbs脚本功能更加地强大，他能调用dll动态库完成一些bat不能完成的功能。同时bat与vbs可以互相调用。&lt;/p&gt;
&lt;p&gt;bat是批处文件，实际上是一条条dos命令的集合，由命令行调用。vbs是vb脚本文件，当然还有java脚本文件，vbs由vb语言写成，但他不需要vb那样的编译环境，只要是文本编辑器都可以，他由系统的脚本解释器执行，一般vbs脚本都用在网页中，用于显示一些特效或特殊的用途。&lt;br&gt;
    
    </summary>
    
      <category term="OTHER" scheme="https://hankin2015.github.io/categories/OTHER/"/>
    
    
      <category term="Vbs" scheme="https://hankin2015.github.io/tags/Vbs/"/>
    
      <category term="Bat" scheme="https://hankin2015.github.io/tags/Bat/"/>
    
      <category term="抖音" scheme="https://hankin2015.github.io/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>精通Python爬虫框架Scrapy</title>
    <link href="https://hankin2015.github.io/2018/10/05/20181005Scrapy/"/>
    <id>https://hankin2015.github.io/2018/10/05/20181005Scrapy/</id>
    <published>2018-10-05T15:47:41.000Z</published>
    <updated>2018-11-23T10:03:39.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、个人曾经的爬虫"><a href="#0、个人曾经的爬虫" class="headerlink" title="0、个人曾经的爬虫"></a>0、个人曾经的爬虫</h1><p>Requests库、Beautiful Soup。<br>本科毕业设计：微博爬虫。</p><h1 id="1、Scrapy"><a href="#1、Scrapy" class="headerlink" title="1、Scrapy"></a>1、Scrapy</h1><p>&emsp;&emsp;Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。<br>&emsp;&emsp;Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。<br>&emsp;&emsp;Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。外号小刮刮。<br><a id="more"></a></p><h1 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h1><p>语言无关论者<br>数据格式：csv、json、xml、txt<br>数据库：mongodb、sqlalchemy、postges<br>前端：html、css、js、squery</p><p>Beautiful Soup、lxml、XPath、selectors。<br><a href="https://stackoverflow.com/questions/tagged/scrapy" target="_blank" rel="noopener">https://stackoverflow.com/questions/tagged/scrapy</a><br><a href="https://scrapy.org/community/" target="_blank" rel="noopener">https://scrapy.org/community/</a></p><p>最小可行产品(Minimum Viable Product, MVP)<br>初创公司、精益创业</p><h1 id="3、认识Scrapy"><a href="#3、认识Scrapy" class="headerlink" title="3、认识Scrapy"></a>3、认识Scrapy</h1><p>数据清晰、格式化、装饰以及存储到数据库。</p><p>XPath选择HTML元素：$x工具函数。（在浏览器console中使用）<br>使用//语法去的某一指定类型的元素。使用/语法即前一个父类下的最近子集。<br>符号@（选择属性）、text()函数、符号* 等等。</p><p>一个特殊的网站：example.com</p><h1 id="4、安装Scrapy"><a href="#4、安装Scrapy" class="headerlink" title="4、安装Scrapy"></a>4、安装Scrapy</h1><blockquote><p>pip install scrapy<br>import scrapy</p></blockquote><h1 id="5、UR2IM流程"><a href="#5、UR2IM流程" class="headerlink" title="5、UR2IM流程"></a>5、UR2IM流程</h1><p>U：URL<br>R：Request<br>R：Response<br>I：Item<br>M：More URL</p><h1 id="6、看到第三章发现真的全程用框架，放弃20181123"><a href="#6、看到第三章发现真的全程用框架，放弃20181123" class="headerlink" title="6、看到第三章发现真的全程用框架，放弃20181123"></a>6、看到第三章发现真的全程用框架，放弃20181123</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0、个人曾经的爬虫&quot;&gt;&lt;a href=&quot;#0、个人曾经的爬虫&quot; class=&quot;headerlink&quot; title=&quot;0、个人曾经的爬虫&quot;&gt;&lt;/a&gt;0、个人曾经的爬虫&lt;/h1&gt;&lt;p&gt;Requests库、Beautiful Soup。&lt;br&gt;本科毕业设计：微博爬虫。&lt;/p&gt;
&lt;h1 id=&quot;1、Scrapy&quot;&gt;&lt;a href=&quot;#1、Scrapy&quot; class=&quot;headerlink&quot; title=&quot;1、Scrapy&quot;&gt;&lt;/a&gt;1、Scrapy&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。&lt;br&gt;&amp;emsp;&amp;emsp;Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。&lt;br&gt;&amp;emsp;&amp;emsp;Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。外号小刮刮。&lt;br&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="爬虫" scheme="https://hankin2015.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天乐</title>
    <link href="https://hankin2015.github.io/2018/10/03/20181003GuoQin/"/>
    <id>https://hankin2015.github.io/2018/10/03/20181003GuoQin/</id>
    <published>2018-10-03T02:48:41.000Z</published>
    <updated>2018-10-23T07:24:43.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、英语单词"><a href="#0、英语单词" class="headerlink" title="0、英语单词"></a>0、英语单词</h1><p>Scaler定标器<br>ensemble（合奏）集成<br>perturb-and-combine干扰<br>interval间隔<br>tuning调参<br>estimate估计<br>bag<br>cross交叉</p><a id="more"></a><h1 id="1、学习计划"><a href="#1、学习计划" class="headerlink" title="1、学习计划"></a>1、学习计划</h1><ul><li>制作简历</li><li>数据分析</li><li>特征选择</li><li>归一化</li><li>泰坦尼克号、鸢尾花数据集、</li><li>python爬虫</li><li>GitHub提交</li><li>研究生项目管理和总结</li><li>深度学习</li><li>python刷题</li><li>隐马尔可夫模型（HMM）</li></ul><h1 id="2、ipnb展示"><a href="#2、ipnb展示" class="headerlink" title="2、ipnb展示"></a>2、ipnb展示</h1><p>先cmd到指定文件夹，然后输入jupyter notebook。或者到指定文件夹下，shift+右键打开powershell，输入jupyter notebook。</p><ul><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/模板/数据分析模板%5B泰坦尼克号%5D.ipynb" target="_blank" rel="noopener">数据分析模板</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/LintCode/泰坦尼克号/泰坦尼克号.ipynb" target="_blank" rel="noopener">泰坦尼克号</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/iris%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.ipynb" target="_blank" rel="noopener">鸢尾花数据集</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/Santander%20Customer%20Satisfaction/桑坦德客户满意度.ipynb" target="_blank" rel="noopener">桑坦德客户满意度</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/Santander%20Customer%20Satisfaction/SantanderCustomerSatisfaction数据诊断.ipynb" target="_blank" rel="noopener">慕课网的Santander Customer Satisfaction数据诊断</a></li><li><a href="">IJCAI-18 阿里妈妈搜索广告转化预测</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/航空公司用户价值分析/航空公司客户价值分析.ipynb" target="_blank" rel="noopener">航空公司客户价值分析</a></li><li><a href="">印象盐城·数创未来大数据竞赛 - 乘用车零售量预测</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/简单的文本特征分类/简单的文本特征分类.ipynb" target="_blank" rel="noopener">简单的文本分类（字符串的拆分）</a></li></ul><h1 id="3、文章"><a href="#3、文章" class="headerlink" title="3、文章"></a>3、文章</h1><ul><li><a href="https://hankin2015.github.io/2018/09/29/20180821MyPython/">python使用中解决技巧</a></li><li><a href="https://hankin2015.github.io/2018/09/29/20180929DA-template/">数据分析之模板</a></li><li><a href="https://hankin2015.github.io/2018/09/25/20180925MXNet/">动手学深度学习【个人版】</a></li><li><a href="https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/">数据分析之数据可视化</a></li><li><a href="https://hankin2015.github.io/2018/09/23/20180923/">学习python机器学习2018.9.23</a></li><li><a href="https://hankin2015.github.io/2018/09/23/20180923DA/">python数据分析【个人版】</a></li><li><a href="https://hankin2015.github.io/2013/01/04/20130104ILoveML/">转岗算法工程师日程</a></li><li><a href="https://www.cnblogs.com/tornadomeet/p/3395593.html" target="_blank" rel="noopener">机器学习&amp;数据挖掘笔记_16（常见面试之机器学习算法思想简单梳理）</a></li><li><a href="http://lib.csdn.net/article/python/62942" target="_blank" rel="noopener">Python装饰器的通俗理解</a></li><li><a href="">python中format函数</a></li></ul><p>装饰器就是闭包。</p><h1 id="4、西瓜书"><a href="#4、西瓜书" class="headerlink" title="4、西瓜书"></a>4、西瓜书</h1><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经元、输入层、隐藏层、输出层<br>隐藏层比较多（大于2）的神经网络叫做深度神经网络。而深度学习，就是使用深层架构（比如，深度神经网络）的机器学习方法。<br>为了拟合一个函数，要么使用一个浅而宽的网络，要么使用一个深而窄的网络。而后者往往更节约资源。</p><p>深层网络也有劣势，就是它不太容易训练。简单的说，你需要大量的数据，很多的技巧才能训练好一个深层网络。这是个手艺活。</p><h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><p>神经元也叫做感知器。</p><h2 id="机器学习名字的由来"><a href="#机器学习名字的由来" class="headerlink" title="机器学习名字的由来"></a>机器学习名字的由来</h2><p>阿瑟·萨缪尔研制西洋跳棋程序。</p><p>错误率error rate<br>精度accuracy = 1-错误率<br>误差error<br>训练误差或者经验误差<br>泛化误差：新样本上的误差<br>过拟合overfitting：泛化性能下降<br>欠拟合underfitting<br>分层采样：保留类别比例的而采样方式</p><p>##<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同学您好！非常感谢您参加了华为公司2019届应届生招聘。经过我们慎重的考虑和认真的评估，非常抱歉地通知您未能通过本次面试。我们对您在面试过程中所表现出来的积极努力和认真参与，致以由衷的敬意和真诚的感谢！勇敢新世界，再次感谢您的参与！</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>hr您好！非常感谢您邀请我参加贵公司2019届应届生招聘。经过我慎重的考虑和认真的评估，非常抱歉地通知您未能通过我的筛选。我对您在面试过程中对我的认可，致以由衷的敬意和真诚的感谢！2018，再次感谢认识您！</p><p>Jaccard系数<br>Jaccard index , 又称为Jaccard相似系数（Jaccard similarity coefficient）用于比较有限样本集之间的相似性与差异性。Jaccard系数值越大，样本相似度越高。</p><p>作者：望其向北<br>链接：<a href="https://www.nowcoder.com/discuss/125413?type=0&amp;order=0&amp;pos=21&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/125413?type=0&amp;order=0&amp;pos=21&amp;page=1</a><br>来源：牛客网</p><p>二叉查找树，查找公共父节点<br>TCP，UDP<br>http报文格式，手写<br>bigdecimal大数实现加减运算<br>大学最自豪最印象深刻的事<br>向我提问，意向地(面试官介绍了武汉，南京部门)<br>还有几个问题记不清了，二面加油！😃</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0、英语单词&quot;&gt;&lt;a href=&quot;#0、英语单词&quot; class=&quot;headerlink&quot; title=&quot;0、英语单词&quot;&gt;&lt;/a&gt;0、英语单词&lt;/h1&gt;&lt;p&gt;Scaler定标器&lt;br&gt;ensemble（合奏）集成&lt;br&gt;perturb-and-combine干扰&lt;br&gt;interval间隔&lt;br&gt;tuning调参&lt;br&gt;estimate估计&lt;br&gt;bag&lt;br&gt;cross交叉&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python使用中解决技巧</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180821MyPython/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180821MyPython/</id>
    <published>2018-09-29T11:48:41.000Z</published>
    <updated>2018-10-15T10:03:09.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、格式化输出"><a href="#1、格式化输出" class="headerlink" title="1、格式化输出"></a>1、格式化输出</h1><p><a href="https://www.cnblogs.com/fat39/p/7159881.html" target="_blank" rel="noopener">【Python笔记】1、格式化输出（%用法和format用法）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;%d + %d = %d&apos; % (a, b, c))</span><br></pre></td></tr></table></figure><h1 id="2、Pandas的DataFrame输出截断和省略问题"><a href="#2、Pandas的DataFrame输出截断和省略问题" class="headerlink" title="2、Pandas的DataFrame输出截断和省略问题"></a>2、Pandas的DataFrame输出截断和省略问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.set_option(&apos;display.width&apos;,200)</span><br><span class="line">pd.set_option(&apos;display.max_colwidth&apos;,100)</span><br></pre></td></tr></table></figure><p>同样，我们还可以控制max_row，max_column等参数，使得我们根据实际数据的显示要求进行设置。更多的设置项详见：<br><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.set_option.html" target="_blank" rel="noopener">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.set_option.html</a></p><h1 id="3、jupyter-notebook中美化pandas中DataFrame的输出"><a href="#3、jupyter-notebook中美化pandas中DataFrame的输出" class="headerlink" title="3、jupyter notebook中美化pandas中DataFrame的输出"></a>3、jupyter notebook中美化pandas中DataFrame的输出</h1><p><a href="https://blog.csdn.net/xiaodongxiexie/article/details/71202279" target="_blank" rel="noopener">https://blog.csdn.net/xiaodongxiexie/article/details/71202279</a></p><h1 id="4、Python-Jupyter-Notebook显示行号"><a href="#4、Python-Jupyter-Notebook显示行号" class="headerlink" title="4、Python Jupyter Notebook显示行号"></a>4、Python Jupyter Notebook显示行号</h1><p>Jupyter Notebook默认不显示行号，不方便我们调试排错。操作如下：<br>找到菜单View找到Toggle Line Numbers<br>好了，那我继续调错了……/(ㄒoㄒ)/~~</p><h1 id="5、保留三位小数"><a href="#5、保留三位小数" class="headerlink" title="5、保留三位小数"></a>5、保留三位小数</h1><p>print(round(3.1415926, 3))   # 四舍五入保留3位小数<br>print( format(x*0.4463,’0.1f’))</p><h1 id="6、文件传入参数"><a href="#6、文件传入参数" class="headerlink" title="6、文件传入参数"></a>6、文件传入参数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.argv[<span class="number">0</span>]) <span class="comment"># 当前文件的绝对路径</span></span><br><span class="line"><span class="comment"># print(sys.argv[1]) # 空参数</span></span><br></pre></td></tr></table></figure><h1 id="7、取整操作"><a href="#7、取整操作" class="headerlink" title="7、取整操作"></a>7、取整操作</h1><p><a href="https://www.jb51.net/article/102248.htm" target="_blank" rel="noopener">https://www.jb51.net/article/102248.htm</a><br>双斜杠：53 // 8</p><h1 id="8、输入操作"><a href="#8、输入操作" class="headerlink" title="8、输入操作"></a>8、输入操作</h1><p>学到了：h1, m1, h2, m2 = map(int, input().split())<br>datetime.timedelta似乎<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">s = input().split()</span><br><span class="line"></span><br><span class="line">t1 = datetime.datetime(2018, 10, 2, int(s[0]), int(s[1]))</span><br><span class="line">t2 = datetime.datetime(2018, 10, 2, int(s[2]), int(s[3]))</span><br><span class="line">seconds = (t2 - t1).seconds</span><br><span class="line">print(seconds // 3600, seconds % 3600 // 60)</span><br></pre></td></tr></table></figure></p><h1 id="1、sklearn的train-test-split函数用法"><a href="#1、sklearn的train-test-split函数用法" class="headerlink" title="1、sklearn的train_test_split函数用法"></a>1、sklearn的train_test_split函数用法</h1><p><a href="https://blog.csdn.net/sinat_23338865/article/details/80248599" target="_blank" rel="noopener">https://blog.csdn.net/sinat_23338865/article/details/80248599</a><br>用于将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签。</p><h1 id="2、工欲善其事必先利其器（sublime）"><a href="#2、工欲善其事必先利其器（sublime）" class="headerlink" title="2、工欲善其事必先利其器（sublime）"></a>2、工欲善其事必先利其器（sublime）</h1><p>使用sublime运行python：</p><ul><li>1、添加python环境变量，即可ctrl+B运行python</li><li>2、sublime无法解决输入问题，方法有二：<ul><li>cmd窗口输入设置</li><li>安装sublimeREPL</li></ul></li><li>3、添加快捷键（f5键）</li></ul><p>有时候ctrl+B后会出现控制台，但是关闭有些麻烦，快捷键ctrl+`。</p><h1 id="3、Python-zip-函数"><a href="#3、Python-zip-函数" class="headerlink" title="3、Python zip() 函数"></a>3、Python zip() 函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><h1 id="4、范数"><a href="#4、范数" class="headerlink" title="4、范数"></a>4、范数</h1><p><a href="https://blog.csdn.net/Yaphat/article/details/53304255" target="_blank" rel="noopener">范数&amp;距离</a><br><a href="https://blog.csdn.net/shijing_0214/article/details/51757564" target="_blank" rel="noopener">几种范数的简单介绍</a></p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</p><p>说白了：常用欧式距离，即平方差（方差）就是L2范数。</p><ul><li>L1范数:  ||x|| 为x向量各个元素绝对值之和。 </li><li>L2范数:  ||x||为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或者Frobenius范数 </li><li>Lp范数:  ||x||为x向量各个元素绝对值p次方和的1/p次方 </li><li>L∞范数:  ||x||为x向量各个元素绝对值最大那个元素的绝对值</li></ul><h1 id="5、支持度、置信度、提升度"><a href="#5、支持度、置信度、提升度" class="headerlink" title="5、支持度、置信度、提升度"></a>5、支持度、置信度、提升度</h1><p><a href="https://www.jianshu.com/p/dc053deb94f2" target="_blank" rel="noopener">数据挖掘关联分析中的支持度、置信度和提升度</a></p><ul><li>联系：关联规则或频繁项集</li><li>关联分析：两个变量之间A、B</li><li>项在事务中出现比不出现更重要，因此项是非对称的的二元变量。</li><li>事务的宽度：事务中出现的项的个数</li><li>A对B的置信度：做了A事务的人有多少概率也会做B事务。</li><li>为啥有提升度：查看A、B是否联系-相关、排斥、无关</li><li>提升度受零事务影响大</li><li>KULC度量+不平衡比（IR） 。它们可以有效的降低零事务造成的影响。</li><li>KULC = 两个置信度的均值</li><li>IR = 两个置信度的比值</li><li>置信度就是贝叶斯公式啊</li></ul><p>Support（支持度）：表示同时包含A和B的事务占所有事务的比例。如果用P(A)表示使用A事务的比例，那么Support=P(A&amp;B)</p><p>Confidence（置信度）：表示使用包含A的事务中同时包含B事务的比例，即同时包含A和B的事务占包含A事务的比例。公式表达：Confidence=P(A&amp;B)/P(A)=P(B|A)</p><p>Lift（提升度）：表示“包含A的事务中同时包含B事务的比例”与“包含B事务的比例”的比值。公式表达：Lift=( P(A&amp;B)/P(A))/P(B)=P(A&amp;B)/P(A)/P(B)。</p><p>提升度反映了关联规则中的A与B的相关性，提升度&gt;1且越高表明正相关性越高，提升度&lt;1且越低表明负相关性越高，提升度=1表明没有相关性。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h2 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h2><p>获得一个区间，例如，对这个问题的一个可能的答案是：「我 95％ 相信在美国足球爱好者的比例是 58％ 至 62％」。这就是置信区间名字的来源，我们有一个区间，并且我们对它此一定的信心。</p><h1 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h1><p>贝叶斯定理由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。按照乘法法则，可以立刻导出：P(A∩B) = P(A)<em>P(B|A)=P(B)</em>P(A|B)。如上公式也可变形为：P(B|A) = P(A|B)*P(B) / P(A)。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ul><li>pd.set_option(‘display.max_columns’, None)   强制显示所有属性值</li><li>label = df[‘TARGET’]    dataframe对大小写非常敏感，写成TARGeT就会报错</li><li>axis = 1是对列进行操作</li><li>drop函数删除相应的行和列</li><li>iloc表示下标访问，loc是条件访问<br>df.loc[df[‘a’]&gt;3, ‘a’] = df[‘a’] / 3<br>print(df)</li><li>apply函数和lambda函数常常一起使用</li><li>reset_index()重构索引，重构索引后会自动增加一列index(原始)，需要删除</li></ul><p># </p><h1 id="6、数据诊断"><a href="#6、数据诊断" class="headerlink" title="6、数据诊断"></a>6、数据诊断</h1><p>数量（样本）、值数量（范围）、是否有零值、数据类型、mean平均数值、median中位数、mode众数、mode_percent众数比例</p><p>零值、异常值</p><p>了解特征的分布、缺失和异常的情况。<br>缺失值填充：-1、0、1、中位数、众数、平均值</p><p>numpy:数组、列表<br>pandas:把数据读成dataframe形式，读写<br>scipy:计算，函数，众数等计算</p><p>导入division确保一个数除以另外一个数不等于0，返回值是一个浮点型的数<br>导入pd，np，scipy中的stats函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">依赖包的导入</span><br><span class="line"># coding:utf-8</span><br><span class="line">from __future__ import division</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy import stats</span><br></pre></td></tr></table></figure><p>统计指标介绍：</p><ul><li>均值/中位数/最大值/最小值等</li><li>计数类：多少0值，多少1值，多少缺失值…..</li><li>缺失值/方差等：当某个特征的方差为0，则这个特征无效基本相同；缺失值过多可删除</li><li>分位点/值的频数等：</li></ul><p>##1.Basic Analysis##</p><p>#(1)Missing Value#<br>missSet = [np.nan, 9999999999, -999999]</p><p>#(2)Count distinct#<br>len(df.iloc[:, 0].unique())<br>count_un = df.iloc[:,0:3].apply(lambda x:len(x.unique()))</p><p>#(3)Zero Values#<br>np.sum(df.iloc[:0] == 0)<br>count_zero = df.iloc[:, 0:3].apply(lambda x:np.sum(x == 0))</p><h1 id="describe-函数"><a href="#describe-函数" class="headerlink" title="describe()函数"></a>describe()函数</h1><p><a href="https://blog.csdn.net/g_66_hero/article/details/72899377" target="_blank" rel="noopener">https://blog.csdn.net/g_66_hero/article/details/72899377</a><br>生成描述性统计，总结数据集分布的中心趋势，分散和形状，不包括NaN值。<br>对于数值数据，结果的索引将包括计数，平均值，标准差，最小值，最大值以及较低的百分位数和50。默认情况下，较低的百分位数为25，较高的百分位数为75.50百分位数与中位数相同。</p><p>对于对象数据（例如字符串或时间戳），结果的索引将包括count，unique，top和freq。顶部是最常见的价值。频率是最常见的频率。时间戳还包括第一个和最后一个项目。</p><p>可以使用include和exclude参数来限制DataFrame中哪些列被分析输出。分析系列时，参数将被忽略。</p><p>describe()函数自动计算的字段有count（非空值数）、unique（唯一值数）、top（频数最高者）、freq（最高频数）、mean（平均值）、std（方差）、min（最小值）、50%（中位数）、max（最大值</p><h1 id="Series和Dataframe的区别"><a href="#Series和Dataframe的区别" class="headerlink" title="Series和Dataframe的区别"></a>Series和Dataframe的区别</h1><p><a href="https://geektutu.com/post/pandas-dataframe-series.html" target="_blank" rel="noopener">https://geektutu.com/post/pandas-dataframe-series.html</a><br>DataFrame和Series是pandas中最常见的2种数据结构。DataFrame可以理解为Excel中的一张表，Series可以理解为一张Excel表的一行或一列数据。<br>Series可以理解为一维数组numpy.array，它和一维数组的区别，在于Series具有索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1=pd.Series([1,2,4,6,7,2])</span><br><span class="line">s2=pd.Series([4,3,1,57,8],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br></pre></td></tr></table></figure></p><p>定长的字典。<br>DataFrame相当于表格，有行表头和列表头。<br>series可以看做一个一维的字典，而dataframe可以看作是一个多维的字典。</p><h1 id="astype、dtype"><a href="#astype、dtype" class="headerlink" title="astype、dtype"></a>astype、dtype</h1><ul><li>ndim返回的是数组的维度，返回的只有一个数，该数即表示数组的维度。</li><li>shape：表示各位维度大小的元组。返回的是一个元组。</li><li>dtype：一个用于说明数组数据类型的对象。返回的是该数组的数据类型。由于图中的数据都为整型，所以返回的都是int32。如果数组中有数据带有小数点，那么就会返回float64。</li><li>astype：转换数组的数据类型。</li></ul><h1 id="factorize-函数"><a href="#factorize-函数" class="headerlink" title="factorize()函数"></a>factorize()函数</h1><p>factorize函数可以将Series中的标称型数据映射称为一组数字，相同的标称型映射为相同的数字。<br>factorize函数的返回值是一个tuple（元组），元组中包含两个元素。<br>第一个元素是一个array，其中的元素是标称型元素映射为的数字(从0开始)；<br>第二个元素是Index类型，其中的元素是所有标称型元素，没有重复。</p><h1 id="标称型数据和数值型数据"><a href="#标称型数据和数值型数据" class="headerlink" title="标称型数据和数值型数据"></a>标称型数据和数值型数据</h1><p>在学习机器学习的工程中，发现有一种名为标称型的数据，具体如下：</p><p>标称型：一般在有限的数据中取，而且只存在‘是’和‘否’两种不同的结果（一般用于分类）</p><p>数值型：可以在无限的数据中取，而且数值比较具体化，例如4.02,6.23这种值（一般用于回归分析）</p><h1 id="判断两个数是否相等用异或运算啊"><a href="#判断两个数是否相等用异或运算啊" class="headerlink" title="判断两个数是否相等用异或运算啊"></a>判断两个数是否相等用异或运算啊</h1><h1 id="判断一个数是否为奇数-amp-1"><a href="#判断一个数是否为奇数-amp-1" class="headerlink" title="判断一个数是否为奇数&amp;1"></a>判断一个数是否为奇数&amp;1</h1><h1 id="一个数乘以或者除以2则左移右移"><a href="#一个数乘以或者除以2则左移右移" class="headerlink" title="一个数乘以或者除以2则左移右移"></a>一个数乘以或者除以2则左移右移</h1><h1 id="future模块"><a href="#future模块" class="headerlink" title="future模块"></a><strong>future</strong>模块</h1><p>从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用’xxx’表示str，Unicode字符串用u’xxx’表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u’xxx’和’xxx’是完全一致的，而在2.x中以’xxx’表示的str就必须写成b’xxx’，以此表示“二进制字符串”。</p><p>要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。</p><p>Python提供了<strong>future</strong>模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。</p><h1 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h1><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。 在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类相比较计算的。</p><h1 id="范数-1"><a href="#范数-1" class="headerlink" title="范数"></a>范数</h1><p>范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</p><h1 id="凡是出现-1-IND00-基本可以肯定是发生了除0错误。"><a href="#凡是出现-1-IND00-基本可以肯定是发生了除0错误。" class="headerlink" title="凡是出现-1.#IND00.基本可以肯定是发生了除0错误。"></a>凡是出现-1.#IND00.基本可以肯定是发生了除0错误。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、格式化输出&quot;&gt;&lt;a href=&quot;#1、格式化输出&quot; class=&quot;headerlink&quot; title=&quot;1、格式化输出&quot;&gt;&lt;/a&gt;1、格式化输出&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fat39/p/7159881.h
      
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>手记</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929Note/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929Note/</id>
    <published>2018-09-29T11:47:41.000Z</published>
    <updated>2018-10-03T02:58:13.417Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之模板</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929DA-template/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929DA-template/</id>
    <published>2018-09-29T11:43:41.000Z</published>
    <updated>2018-10-21T12:37:11.862Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.kesci.com/home/project/5b3b3ed771a61726e13833e3" target="_blank" rel="noopener">数据分析（业务向）技能总结</a></p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  # 数学</span><br><span class="line">import pandas as pd</span><br><span class="line">from sklearn import datasets  #用数据库去学习，或者把数据库放到tenserflow模块练习</span><br><span class="line">from sklearn.model_selection import train_test_split # 数据集测试集分离</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier   # 会选择邻近几个点作为他的邻居，综合临近几个点模拟出数据的预测值</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import warnings </span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line">import seaborn as sns</span><br><span class="line">import os</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>&lt;–!more–&gt;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, we'll import pandas, a data processing and CSV file I/O library</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># We'll also import seaborn, a Python graphing library</span></span><br><span class="line"><span class="keyword">import</span> warnings <span class="comment"># current version of seaborn generates a bunch of warnings that we'll ignore</span></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sns.set(style=<span class="string">"white"</span>, color_codes=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Next, we'll load the Iris flower dataset, which is in the "../input/" directory</span></span><br><span class="line">iris = pd.read_csv(<span class="string">"../input/Iris.csv"</span>) <span class="comment"># the iris dataset is now a Pandas DataFrame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's see what's in the iris data - Jupyter notebooks print the result of the last thing you do</span></span><br><span class="line">iris.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Press shift+enter to execute this cell</span></span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/chennai1101/article/details/59483438/" target="_blank" rel="noopener">Python 打印语句</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.kesci.com/home/project/5b3b3ed771a61726e13833e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据分析（业务向）技能总结&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;头文件&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之数据可视化</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/</id>
    <published>2018-09-29T05:47:41.000Z</published>
    <updated>2018-10-03T02:50:21.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、数据集的来源"><a href="#1、数据集的来源" class="headerlink" title="1、数据集的来源"></a>1、数据集的来源</h1><ul><li><a href="https://blog.csdn.net/brucewong0516/article/details/79011562" target="_blank" rel="noopener">numpy之random库简单的随机数据生成</a></li><li><a href="https://blog.csdn.net/tmb8z9vdm66wh68vx1/article/details/79212888" target="_blank" rel="noopener">教你在Python中用Scikit生成测试数据集</a><a id="more"></a></li><li>1、np.random.rand(d0, d1, …, dn)<br>np.random.rand(3,2) #生成3行2列的随机数组<br>np.random.rand(3,2,2) #生产3维的随机数组</li><li>2、randn(d0, d1, …, dn)返回一个样本，具有标准正态分布。</li><li>3、randint(low[, high, size])<ul><li>返回随机整数，范围区间为[low,high），包含low，不包含high</li><li>参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int</li><li>high没有填写时，默认生成随机数的范围是[0，low)</li></ul></li><li>4、np.random.random([size])生成[0,1)之间的浮点数,与np.random.rand()功能类似</li><li>5、numpy.random.choice(a[, size, replace, p])生成一个随机样本，从一个给定的一维数组a中随机选取</li><li>6、numpy.random.seed()生成随机数的种子，使得每次生成随机数相同</li></ul><p><strong>注意</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(2) # 种子和随机函数放在一起运行才能使随机数不变</span><br><span class="line">np.random.rand(3)</span><br></pre></td></tr></table></figure></p><h1 id="2、画散点图看分布"><a href="#2、画散点图看分布" class="headerlink" title="2、画散点图看分布"></a>2、画散点图看分布</h1><h1 id="3、资料满满"><a href="#3、资料满满" class="headerlink" title="3、资料满满"></a>3、资料满满</h1><p><a href="https://blog.csdn.net/suzyu12345/article/details/69029106" target="_blank" rel="noopener">python seaborn画图</a><br><a href="https://www.cnblogs.com/gczr/p/6767175.html" target="_blank" rel="noopener">Python数据可视化-seaborn</a></p><p><a href="https://www.kaggle.com/benhamner/python-data-visualizations/notebook" target="_blank" rel="noopener">Python data visualizations on the Iris dataset</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、数据集的来源&quot;&gt;&lt;a href=&quot;#1、数据集的来源&quot; class=&quot;headerlink&quot; title=&quot;1、数据集的来源&quot;&gt;&lt;/a&gt;1、数据集的来源&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/brucewong0516/article/details/79011562&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numpy之random库简单的随机数据生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/tmb8z9vdm66wh68vx1/article/details/79212888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教你在Python中用Scikit生成测试数据集&lt;/a&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习[个人版]</title>
    <link href="https://hankin2015.github.io/2018/09/25/20180925MXNet/"/>
    <id>https://hankin2015.github.io/2018/09/25/20180925MXNet/</id>
    <published>2018-09-25T02:47:41.000Z</published>
    <updated>2018-10-23T02:38:06.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、学习深度须知"><a href="#1、学习深度须知" class="headerlink" title="1、学习深度须知"></a>1、学习深度须知</h1><h2 id="DL"><a href="#DL" class="headerlink" title="DL???"></a>DL???</h2><ul><li>纸上得来终觉浅，绝知此事要躬行。</li><li>通俗来说，机器学习是一门讨论各式各样适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。</li><li>裁剪平均值的雏形：去掉最高分和最低分。</li><li>绝大多数神经网络的核心原则：<ul><li>交替使用线性与非线性处理单元，经常被称为“层”。</li><li>使用链式法则（即反向传播）来更新网络的参数。<a id="more"></a></li></ul></li></ul><h2 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet???"></a>MXNet???</h2><ul><li>MXNet 是一个开源的<strong>深度学习框架</strong>。它是 AWS（亚马逊云计算服务）首选的深度学习框架，并且也许是最优秀的库【百度百科评价】。</li><li>对 Python 的支持只是其冰山一角—MXNet 同样提供了对 R、Julia、C++、Scala、Matlab，和 Javascript 的接口。</li><li>MXNet 的ndarray、autograd、gluon等模块的基础功能，所以gluon仅仅是一个模块，而不是框架。</li></ul><h2 id="GPU【图像处理器】和CPU【中央处理器】的区别"><a href="#GPU【图像处理器】和CPU【中央处理器】的区别" class="headerlink" title="GPU【图像处理器】和CPU【中央处理器】的区别"></a>GPU【图像处理器】和CPU【中央处理器】的区别</h2><ul><li>CPU擅长逻辑控制和通用类型数据运算</li><li>GPU擅长的是大规模并发计算</li></ul><p>深度学习训练通常需要大量的计算资源。GPU 目前是深度学习最常使用的计算加速硬件。相对于 CPU 来说，GPU 更便宜且计算更加密集。一方面，相同计算能力的 GPU 的价格一般是 CPU 价格的十分之一。另一方面，一台服务器通常可以搭载 8 块或者 16 块 GPU。因此，GPU 数量可以看作是衡量一台服务器的深度学习计算能力的一个标准。</p><p>目前独立 GPU 主要有 AMD 和 Nvidia 两家厂商。其中 Nvidia 在深度学习布局较早，对深度学习框架支持更好。因此，目前大家主要会选择 Nvidia 的 GPU。</p><h1 id="2、数据操作"><a href="#2、数据操作" class="headerlink" title="2、数据操作"></a>2、数据操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://zh.gluon.ai/chapter_prerequisite/install.html" target="_blank" rel="noopener">获取代码并安装运行环境</a><br>conda config –prepend channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>下载存储地址：’D:\Program Files\Anaconda\envs\gluon’</p><p>小问题：我使用anaconda安装的，首先关于python和Linux的安装都需要先升级工具为最新版本。然而gluon模块安装完成后会有jupyter notebook版本，点击后闪退无果。<br>正确的打开方式：打开cmd=》激活gluon（activate gluon）=》jupyter notebook</p><p>还可以直接安装pip install mxnet.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>NDArray 和 NumPy 的多维数组非常类似。然而，NDArray 提供 GPU 计算和自动求梯度等更多功能，这些使得 NDArray 更加适合深度学习。</p><p><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/MXNet1.ipynb" target="_blank" rel="noopener">mxnet的简单使用</a></p><h1 id="3、深度学习基础"><a href="#3、深度学习基础" class="headerlink" title="3、深度学习基础"></a>3、深度学习基础</h1><p>单层神经网络：线性回归和 Softmax 回归。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>权重weight、偏差bias、参数parameter。<br>预测（估计）</p><h3 id="模型训练三要素"><a href="#模型训练三要素" class="headerlink" title="模型训练三要素"></a>模型训练三要素</h3><p>训练数据：特征feature、标签label、样本sample、训练集<br>损失函数：平方误差函数也称平方损失（记得要乘以1/2，其中常数 1/2 使得对平方项求导后的常数系数为 1），然后求和后再取平均值。<br>优化算法：在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。</p><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫做解析解（analytical solution）。<br>只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫做数值解（numerical solution）。</p><p>批量大小和学习率的值是人为设定的，并不是通过模型训练学出的，因此叫做超参数（hyperparameter）。我们通常所说的“调参”指的正是调节超参数，例如通过反复试错来找到合适的超参数。少数情况下，超参数也可以通过模型训练学出。</p><p>这个网站主要还是讲的是深度学习，还是先入门机器学习为好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、学习深度须知&quot;&gt;&lt;a href=&quot;#1、学习深度须知&quot; class=&quot;headerlink&quot; title=&quot;1、学习深度须知&quot;&gt;&lt;/a&gt;1、学习深度须知&lt;/h1&gt;&lt;h2 id=&quot;DL&quot;&gt;&lt;a href=&quot;#DL&quot; class=&quot;headerlink&quot; title=&quot;DL???&quot;&gt;&lt;/a&gt;DL???&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/li&gt;
&lt;li&gt;通俗来说，机器学习是一门讨论各式各样适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。&lt;/li&gt;
&lt;li&gt;裁剪平均值的雏形：去掉最高分和最低分。&lt;/li&gt;
&lt;li&gt;绝大多数神经网络的核心原则：&lt;ul&gt;
&lt;li&gt;交替使用线性与非线性处理单元，经常被称为“层”。&lt;/li&gt;
&lt;li&gt;使用链式法则（即反向传播）来更新网络的参数。
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
  <entry>
    <title>python数据分析【个人版】</title>
    <link href="https://hankin2015.github.io/2018/09/23/20180923DA/"/>
    <id>https://hankin2015.github.io/2018/09/23/20180923DA/</id>
    <published>2018-09-23T13:47:41.000Z</published>
    <updated>2018-10-03T02:51:17.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、枚举指定文件夹中的所有指定格式文件并访问"><a href="#1、枚举指定文件夹中的所有指定格式文件并访问" class="headerlink" title="1、枚举指定文件夹中的所有指定格式文件并访问"></a>1、枚举指定文件夹中的所有指定格式文件并访问</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dirPath = <span class="string">'./'</span>   <span class="comment"># 文件夹路径 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListFile</span><span class="params">(fileDir)</span>:</span>   </span><br><span class="line">    ret = []   </span><br><span class="line"><span class="comment"># os.walk()函数返回根目录、</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(fileDir):  </span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:  </span><br><span class="line"><span class="comment">#其中os.path.splitext()函数将路径拆分为文件名+扩展名</span></span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(file)[<span class="number">1</span>] == <span class="string">'.txt'</span>:</span><br><span class="line">                ret.append(os.path.join(root, file))  </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">files = ListFile(dataPath)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    data = pd.read_table(file)</span><br><span class="line">    ret = data[data[<span class="string">'communities'</span>] == <span class="string">'at question'</span>]</span><br><span class="line">    <span class="keyword">if</span> (ret.shape[<span class="number">0</span>] != <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">'有异常数据的文件：'</span> + file)</span><br><span class="line">        print(ret)</span><br></pre></td></tr></table></figure><h1 id="2、对series和dataframe进行排序"><a href="#2、对series和dataframe进行排序" class="headerlink" title="2、对series和dataframe进行排序"></a>2、对series和dataframe进行排序</h1><ul><li>sort函数好像被淘汰，改为sort_values函数。</li><li>排序不是在源dataframe里进行，而是生成新的dataframe。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">df = df.sort_values(by=<span class="string">'internalReturn'</span>, ascending=<span class="keyword">False</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">frame.sort(columns = [<span class="string">'a'</span>],axis = <span class="number">0</span>,ascending = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#以下实现排序功能。</span></span><br><span class="line">series=pd.Series([<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>],index=[<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>])</span><br><span class="line">frame=pd.DataFrame([[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]],columns=[<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>],index=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>])</span><br><span class="line"><span class="keyword">print</span> frame</span><br><span class="line"><span class="keyword">print</span> series</span><br><span class="line"><span class="keyword">print</span> <span class="string">'series通过索引进行排序：'</span></span><br><span class="line"><span class="keyword">print</span> series.sort_index()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'series通过值进行排序:'</span></span><br><span class="line"><span class="keyword">print</span> series.sort_values()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'dataframe根据行索引进行降序排序（排序时默认升序，调节ascending参数）：'</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(ascending=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'dataframe根据列索引进行排序：'</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'dataframe根据值进行排序：'</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_values(by=<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'通过多个索引进行排序：'</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def use_svg_display():</span><br><span class="line">    # 用矢量图显示。</span><br><span class="line">    display.set_matplotlib_formats(&apos;svg&apos;)</span><br><span class="line"></span><br><span class="line">def set_figsize(figsize=(3.5, 2.5)):</span><br><span class="line">    use_svg_display()</span><br><span class="line">    # 设置图的尺寸。</span><br><span class="line">    plt.rcParams[&apos;figure.figsize&apos;] = figsize</span><br><span class="line"></span><br><span class="line">set_figsize()</span><br><span class="line">plt.scatter(features[:, 1].asnumpy(), labels.asnumpy(), 1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、枚举指定文件夹中的所有指定格式文件并访问&quot;&gt;&lt;a href=&quot;#1、枚举指定文件夹中的所有指定格式文件并访问&quot; class=&quot;headerlink&quot; title=&quot;1、枚举指定文件夹中的所有指定格式文件并访问&quot;&gt;&lt;/a&gt;1、枚举指定文件夹中的所有指定格式文件并
      
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="数据分析" scheme="https://hankin2015.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
