<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HanKin的博客</title>
  
  <subtitle>聪明出于勤奋，天才在于积累。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hankin2015.github.io/"/>
  <updated>2018-09-29T11:31:23.414Z</updated>
  <id>https://hankin2015.github.io/</id>
  
  <author>
    <name>HanKin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据处理常用基础操作(清洗、可视化、特征工程)[置顶]</title>
    <link href="https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/"/>
    <id>https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/</id>
    <published>2222-11-10T13:47:41.000Z</published>
    <updated>2018-09-29T11:31:23.414Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h1 id="一、数据挖掘之pandas-DataFrame"><a href="#一、数据挖掘之pandas-DataFrame" class="headerlink" title="一、数据挖掘之pandas.DataFrame"></a>一、数据挖掘之pandas.DataFrame</h1><p><a href="http://www.jianshu.com/p/682c24aef525" target="_blank" rel="noopener">用python做数据分析4|pandas库介绍之DataFrame基本操作</a><br><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://old.sebug.net/paper/books/scipydoc/index.html#" target="_blank" rel="noopener">用Python做科学计算</a></p><p>数据地址：github.com<br>源代码地址：github.com</p><h2 id="1、jupyter-notebook显示plot图像"><a href="#1、jupyter-notebook显示plot图像" class="headerlink" title="1、jupyter notebook显示plot图像"></a>1、jupyter notebook显示plot图像</h2><blockquote><p>%matplotlib inline</p></blockquote><h2 id="2、处理excel数据"><a href="#2、处理excel数据" class="headerlink" title="2、处理excel数据"></a>2、处理excel数据</h2><p>后缀为xls或者xlsx</p><blockquote><p>import pandas as pd<br>data.to_excel(‘data.xlsx’, index=False)</p></blockquote><h2 id="3、处理csv数据"><a href="#3、处理csv数据" class="headerlink" title="3、处理csv数据"></a>3、处理csv数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_csv(‘./data.csv’, sep=’\t’)  #按照相应的间隔符读取数据，默认空格或者tab符</p></blockquote><h2 id="4、处理txt数据"><a href="#4、处理txt数据" class="headerlink" title="4、处理txt数据"></a>4、处理txt数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_table(‘./data.txt’)<br>data.to_csv(‘data.txt’, sep=’\t’, index=False)</p></blockquote><h2 id="5、数据可视化"><a href="#5、数据可视化" class="headerlink" title="5、数据可视化"></a>5、数据可视化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#marker为形状、s为形状大小，线条没有，c为颜色，也可以写全称size、color</span></span><br><span class="line"><span class="comment">#scatter为散点图、plot为折线图</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x轴数据, y轴数据, marker = <span class="string">'o'</span>, s=<span class="number">200</span>, c=<span class="string">'red'</span>, label=标签名) </span><br><span class="line">plt.plot(x轴数据, y轴数据, marker = <span class="string">'x'</span>, c=<span class="string">'black'</span>, label=<span class="string">'Comprehensive'</span>)</span><br><span class="line">plt.legend()  <span class="comment"># 让图例生效</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(x轴名称)</span><br><span class="line">plt.ylabel(y轴名称)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def scatter(X, Y):</span><br><span class="line">    #产生测试数据  </span><br><span class="line">    x = np.arange(1,10)  </span><br><span class="line">    y = x  </span><br><span class="line">    fig = plt.figure()  </span><br><span class="line">    ax = fig.add_subplot(111)   # 设置子图</span><br><span class="line">    #设置标题  </span><br><span class="line">    ax.set_title(&apos;Scatter Plot&apos;)  </span><br><span class="line">    #设置X轴标签  </span><br><span class="line">    plt.xlabel(&apos;X&apos;)  </span><br><span class="line">    #设置Y轴标签  </span><br><span class="line">    plt.ylabel(&apos;Y&apos;)  </span><br><span class="line">    #添加批注</span><br><span class="line">    for i in range(4):    # xy表示批注点位置，xxtext表示批注文字位置，arrowprops加箭头</span><br><span class="line">        ax.annotate(Y[i],xy=(X[i,0],X[i,1]), xytext=(X[i,0],X[i,1]), arrowprops=dict(facecolor=&apos;black&apos;, shrink=0.05))</span><br><span class="line">    #画散点图  </span><br><span class="line">    ax.scatter(X[:,0],X[:,1],s = 75,c = &apos;r&apos;,marker = &apos;o&apos;,alpha=.5)  </span><br><span class="line">    #设置图标  </span><br><span class="line">    plt.legend(&apos;X&apos;)  </span><br><span class="line">    #显示所画的图  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="画函数曲线"><a href="#画函数曲线" class="headerlink" title="画函数曲线"></a>画函数曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(0, 12)</span><br><span class="line">y1 = 2 * x + 5   #直线函数</span><br><span class="line">y2 = x ** 2 + 5  #曲线函数</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1, c=&apos;yellow&apos;)</span><br><span class="line">plt.plot(x, y2, c=&apos;red&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="6、dataframe增加一行数据或者一列数据"><a href="#6、dataframe增加一行数据或者一列数据" class="headerlink" title="6、dataframe增加一行数据或者一列数据"></a>6、dataframe增加一行数据或者一列数据</h2><h3 id="增加一行"><a href="#增加一行" class="headerlink" title="增加一行"></a>增加一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(columns=[&apos;name&apos;,&apos;sex&apos;,&apos;age&apos;, &apos;other&apos;])</span><br><span class="line"># 方法1(必须加列名)</span><br><span class="line">df.append(&#123;&apos;name&apos;: &apos;hejian&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;age&apos;: 24, &apos;other&apos;: &apos;handsome&apos;&#125;, ignore_index=True, verify_integrity=False)</span><br><span class="line"></span><br><span class="line">#方法2</span><br><span class="line">df.loc[2] = [&apos;hejian&apos;,  &apos;man&apos;,  24, &apos;handsome&apos;]</span><br></pre></td></tr></table></figure><h2 id="7、排序"><a href="#7、排序" class="headerlink" title="7、排序"></a>7、排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sorted([5, 2, 3, 1, 4])</span><br><span class="line">a = [5, 2, 3, 1, 4]</span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line">sorted(res, key = lambda x:x[0])</span><br><span class="line">df.sort_values(by=)</span><br></pre></td></tr></table></figure><h2 id="8、输出格式"><a href="#8、输出格式" class="headerlink" title="8、输出格式"></a>8、输出格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = [1, 2, 3, 4]</span><br><span class="line">res = []</span><br><span class="line">for elem in ans:</span><br><span class="line">    res.append(str(elem))</span><br><span class="line">print(&apos; &apos;.join(res))  #按照空格间隔输出</span><br><span class="line">print(&apos;*&apos;.join(res))  #按照星号间隔输出</span><br></pre></td></tr></table></figure><h2 id="9、基本操作"><a href="#9、基本操作" class="headerlink" title="9、基本操作"></a>9、基本操作</h2><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><blockquote><p>df = pd.DataFrame([1, 2, 3, 4, 5], columns=[‘cols’], index=[‘a’,’b’,’c’,’d’,’e’])<br>df.index<br>df.columns<br>df = pd.DataFrame(np.random.randint(low=0, high=10, size=(5, 5)), columns=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’])<br>df = pd.DataFrame(data=d, dtype=np.int8)<br>df = pd.DataFrame({‘x’:x, ‘y’:y}, columns=[‘x’, ‘y’])</p></blockquote><h3 id="根据索引查看数据"><a href="#根据索引查看数据" class="headerlink" title="根据索引查看数据"></a>根据索引查看数据</h3><blockquote><p>df.loc[‘a’]   # 索引为ａ这一行的数据<br>df.iloc[0]      #跟上面的操作等价，一个是根据索引名，一个是根据数字索引访问数据</p></blockquote><h3 id="对每个元素乘以２"><a href="#对每个元素乘以２" class="headerlink" title="对每个元素乘以２"></a>对每个元素乘以２</h3><blockquote><p>print df.apply(lambda x:x*2)</p></blockquote><h3 id="对每个元素求平方-支持ndarray一样的向量化操作"><a href="#对每个元素求平方-支持ndarray一样的向量化操作" class="headerlink" title="对每个元素求平方(支持ndarray一样的向量化操作)"></a>对每个元素求平方(支持ndarray一样的向量化操作)</h3><blockquote><p>print df**2</p></blockquote><h3 id="默认合并之接受索引已经存在的值"><a href="#默认合并之接受索引已经存在的值" class="headerlink" title="默认合并之接受索引已经存在的值"></a>默认合并之接受索引已经存在的值</h3><p>通过指定参数 how，指定合并的方式：inner(交集)、outer(并集)</p><blockquote><p>print dfb.join(df_a,how=’inner’)   # 合并两个DataFrame对象的交集</p></blockquote><h3 id="对DataFrame对象进行列扩充"><a href="#对DataFrame对象进行列扩充" class="headerlink" title="对DataFrame对象进行列扩充"></a>对DataFrame对象进行列扩充</h3><blockquote><p>df[‘col4’] = [‘cnn’,’rnn’]      #直接添加一列数据</p></blockquote><h3 id="字段类型转换"><a href="#字段类型转换" class="headerlink" title="字段类型转换"></a>字段类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">arr = np.array([1, 2, 3])</span><br><span class="line">print(type(arr))</span><br><span class="line">print(arr.dtype)</span><br><span class="line">brr = arr.astype(np.float64)</span><br><span class="line">print(type(brr))</span><br><span class="line">print(brr.dtype)</span><br><span class="line">print(arr)</span><br><span class="line">print(brr)</span><br><span class="line">crr = arr.astype(str)</span><br><span class="line">print(type(crr))</span><br><span class="line">print(crr.dtype)</span><br><span class="line">crr</span><br></pre></td></tr></table></figure><h1 id="二、基础的特征工程"><a href="#二、基础的特征工程" class="headerlink" title="二、基础的特征工程"></a>二、基础的特征工程</h1><h2 id="1、查看数据类型和一些值"><a href="#1、查看数据类型和一些值" class="headerlink" title="1、查看数据类型和一些值"></a>1、查看数据类型和一些值</h2><blockquote><p>df.info()<br>df.describe()</p><h2 id="2、查看是否有缺失值"><a href="#2、查看是否有缺失值" class="headerlink" title="2、查看是否有缺失值"></a>2、查看是否有缺失值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isnull</span><br><span class="line">isna</span><br><span class="line">isin(values)</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、良-恶性乳腺癌肿瘤预测实例"><a href="#3、良-恶性乳腺癌肿瘤预测实例" class="headerlink" title="3、良/恶性乳腺癌肿瘤预测实例"></a>3、良/恶性乳腺癌肿瘤预测实例</h2><p><a href="">ipython notebook分析</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 创建特征列表。</span><br><span class="line">column_names = [&apos;Sample code number&apos;, &apos;Clump Thickness&apos;, &apos;Uniformity of Cell Size&apos;, &apos;Uniformity of Cell Shape&apos;, &apos;Marginal Adhesion&apos;, &apos;Single Epithelial Cell Size&apos;, &apos;Bare Nuclei&apos;, &apos;Bland Chromatin&apos;, &apos;Normal Nucleoli&apos;, &apos;Mitoses&apos;, &apos;Class&apos;]</span><br><span class="line"></span><br><span class="line"># 使用pandas.read_csv函数从互联网读取指定数据。</span><br><span class="line">data = pd.read_csv(&apos;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&apos;, names = column_names )</span><br><span class="line"></span><br><span class="line"># 将?替换为标准缺失值表示。</span><br><span class="line">data = data.replace(to_replace=&apos;?&apos;, value=np.nan)</span><br><span class="line"># 丢弃带有缺失值的数据（只要有一个维度有缺失）。</span><br><span class="line">data = data.dropna(how=&apos;any&apos;)</span><br><span class="line"></span><br><span class="line"># 输出data的数据量和维度。</span><br><span class="line">data.shape</span><br><span class="line"></span><br><span class="line"># 使用sklearn.cross_valiation里的train_test_split模块用于分割数据。</span><br><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line"></span><br><span class="line"># 随机采样25%的数据用于测试，剩下的75%用于构建训练集合。</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data[column_names[1:10]], data[column_names[10]], test_size=0.25, random_state=33)</span><br><span class="line"></span><br><span class="line"># 查验训练样本的数量和类别分布。</span><br><span class="line">y_train.value_counts()</span><br><span class="line"></span><br><span class="line"># 查验测试样本的数量和类别分布。</span><br><span class="line">y_test.value_counts()</span><br><span class="line"></span><br><span class="line"># 从sklearn.preprocessing里导入StandardScaler。</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"># 从sklearn.linear_model里导入LogisticRegression与SGDClassifier。</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.linear_model import SGDClassifier</span><br><span class="line"></span><br><span class="line"># 标准化数据，保证每个维度的特征数据方差为1，均值为0。使得预测结果不会被某些维度过大的特征值而主导。</span><br><span class="line">ss = StandardScaler()</span><br><span class="line">X_train = ss.fit_transform(X_train)</span><br><span class="line">X_test = ss.transform(X_test)</span><br><span class="line"></span><br><span class="line"># 初始化LogisticRegression与SGDClassifier。</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">sgdc = SGDClassifier()</span><br><span class="line"></span><br><span class="line"># 调用LogisticRegression中的fit函数/模块用来训练模型参数。</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型lr对X_test进行预测，结果储存在变量lr_y_predict中。</span><br><span class="line">lr_y_predict = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 调用SGDClassifier中的fit函数/模块用来训练模型参数。</span><br><span class="line">sgdc.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型sgdc对X_test进行预测，结果储存在变量sgdc_y_predict中。</span><br><span class="line">sgdc_y_predict = sgdc.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 从sklearn.metrics里导入classification_report模块。</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line"># 使用逻辑斯蒂回归模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuracy of LR Classifier:&apos;, lr.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得LogisticRegression其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, lr_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br><span class="line"></span><br><span class="line"> # 使用随机梯度下降模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuarcy of SGD Classifier:&apos;, sgdc.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得SGDClassifier其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, sgdc_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br></pre></td></tr></table></figure></p><h2 id="4、召回率、精确率和F1值"><a href="#4、召回率、精确率和F1值" class="headerlink" title="4、召回率、精确率和F1值"></a>4、召回率、精确率和F1值</h2><p>假设我们手上有60个正样本，40个负样本，我们要找出所有的正样本，系统查找出50个，其中只有40个是真正的正样本，计算上述各指标。</p><p>TP: 将正类预测为正类数  40<br>FN: 将正类预测为负类数  20<br>FP: 将负类预测为正类数  10<br>TN: 将负类预测为负类数  30</p><p>准确率(accuracy) = 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN) = 70%<br>精确率(precision) = TP/(TP+FP) = 80%<br>召回率(recall) = TP/(TP+FN) = 2/3<br>F值  = 正确率 <em> 召回率 </em> 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）<br>白话：精确率就是在所有预测为正例中有多少是预测正确的，召回率就是在全部本身就是正样本中有多少预测正确。</p><h2 id="5、sklearn-model-selection-train-test-split随机划分训练集和测试集"><a href="#5、sklearn-model-selection-train-test-split随机划分训练集和测试集" class="headerlink" title="5、sklearn.model_selection.train_test_split随机划分训练集和测试集"></a>5、sklearn.model_selection.train_test_split随机划分训练集和测试集</h2><p>train_test_split是交叉验证中常用的函数，功能是从样本中随机的按比例选取train data和testdata，形式为：</p><blockquote><p>X_train,X_test, y_train, y_test =<br>cross_validation.train_test_split(train_data,train_target,test_size=0.4, random_state=0)</p></blockquote><p>参数解释：<br>train_data：所要划分的样本特征集<br>train_target：所要划分的样本结果<br>test_size：样本占比，如果是整数的话就是样本的数量<br>random_state：是随机数的种子。</p><p>随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。<br>随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：<br>种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><h1 id="三、实例篇"><a href="#三、实例篇" class="headerlink" title="三、实例篇"></a>三、实例篇</h1><p>数据文件：data.csv   data.txt  data.xlsx<br>数据内容(高中成绩)：</p><table><thead><tr><th style="text-align:center">Date</th><th style="text-align:center">Chinese</th><th style="text-align:center">Math</th><th style="text-align:center">English</th><th style="text-align:center">Comprehensive </th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">111</td><td style="text-align:center">130</td><td style="text-align:center">127</td><td style="text-align:center">269    </td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td style="text-align:center">159</td><td style="text-align:center">ok</td><td style="text-align:center">191</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">137</td><td style="text-align:center">119</td><td style="text-align:center">99</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">97</td><td style="text-align:center">149</td><td style="text-align:center">89</td><td style="text-align:center">235</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">120</td><td style="text-align:center">135</td><td style="text-align:center">116</td><td style="text-align:center">282 </td></tr></tbody></table><h2 id="1、生成数据并保存读取"><a href="#1、生成数据并保存读取" class="headerlink" title="1、生成数据并保存读取"></a>1、生成数据并保存读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    data = pd.DataFrame(columns=[&apos;Date&apos;,&apos;Chinese&apos;,&apos;Math&apos;, &apos;English&apos;, &apos;Comprehensive&apos;])</span><br><span class="line">    data.loc[0] = [7,  111, 130, 127, 269]</span><br><span class="line">    data.loc[1] = [8,  &apos;&apos;, 159, &apos;ok&apos;, 191]</span><br><span class="line">    data.loc[2] = [9, 137, 119, 99, 250]</span><br><span class="line">    data.loc[3] = [10, 97, 149, 89, 235]</span><br><span class="line">    data.loc[4] = [11, 120, 135, 116, 282]</span><br><span class="line"></span><br><span class="line">    data.to_csv(&apos;&apos;)</span><br></pre></td></tr></table></figure><h1 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h1><h2 id="去除警告"><a href="#去除警告" class="headerlink" title="去除警告"></a>去除警告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line"></span><br><span class="line">def ignore_warn(*arg, *swarg):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">warning.warn = ignore_warn</span><br></pre></td></tr></table></figure><h3 id="忽略命令行下警告错误的输出"><a href="#忽略命令行下警告错误的输出" class="headerlink" title="忽略命令行下警告错误的输出"></a>忽略命令行下警告错误的输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -W ignore yourscript.py</span><br><span class="line">with open as [for   ]</span><br></pre></td></tr></table></figure><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for i in range (len(list1)):</span><br><span class="line">    print i ,list1[i]</span><br><span class="line"></span><br><span class="line">上述方法有些累赘，利用enumerate()会更加直接和优美：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0 这</span><br><span class="line">1 是</span><br><span class="line">2 一个</span><br><span class="line">3 测试</span><br><span class="line"></span><br><span class="line">enumerate还可以接收第二个参数，用于指定索引起始值，如：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1, 1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">1 这</span><br><span class="line">2 是</span><br><span class="line">3 一个</span><br><span class="line">4 测试</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如果要统计文件的行数，可以这样写：</p><blockquote><p>count = len(open(filepath, ‘r’).readlines())<br>这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。</p></blockquote><p>可以利用enumerate()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">for index, line in enumerate(open(filepath,&apos;r&apos;))： </span><br><span class="line">    count += 1</span><br></pre></td></tr></table></figure></p><h2 id="python-字符串查找的4个方法"><a href="#python-字符串查找的4个方法" class="headerlink" title="python 字符串查找的4个方法"></a>python 字符串查找的4个方法</h2><h3 id="1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"><a href="#1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1" class="headerlink" title="1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"></a>1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1</h3><p>info = ‘abca’<br>print info.find(‘a’)##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</p><p>info = ‘abca’<br>print info.find(‘a’,1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3</p><p>info = ‘abca’<br>print info.find(‘333’)##返回-1,查找不到返回-1</p><h3 id="2-index-方法："><a href="#2-index-方法：" class="headerlink" title="2 index()方法："></a>2 index()方法：</h3><p>python 的index方法是在字符串里查找子串第一次出现的位置，类似字符串的find方法，不过比find方法更好的是，如果查找不到子串，会抛出异常，而不是返回-1</p><p>info = ‘abca’<br>print info.index(‘a’)<br>print info.index(‘33’)</p><h3 id="3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"><a href="#3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。" class="headerlink" title="3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"></a>3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。</h3><p>如果查找全部，可以先找到第一个，然后从当前为起点继续查找。另外一种方法就是正则表达式。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://hankin2015.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="DataFrame" scheme="https://hankin2015.github.io/tags/DataFrame/"/>
    
      <category term="Pandas" scheme="https://hankin2015.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法总结[置顶]</title>
    <link href="https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/"/>
    <id>https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/</id>
    <published>2222-04-24T02:47:41.000Z</published>
    <updated>2018-08-11T16:42:21.942Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">参考：@移动开发小冉</a></p><blockquote><p>算法虐我千百遍，我待算法如初恋</p></blockquote><p>这里的内容是我学习算法过程的一些记录，希望能一直坚持下去。</p><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul><li>把所有经典算法写一遍  </li><li>看算法有关源码   </li><li>加入算法学习社区，相互鼓励学习   </li><li>看经典书籍  </li><li>刷题   </li></ul><h2 id="基本数据结构和算法"><a href="#基本数据结构和算法" class="headerlink" title="基本数据结构和算法"></a>基本数据结构和算法</h2><p>这些算法全部自己敲一遍：</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表</li><li>双向链表</li></ul><h3 id="哈希表-散列表-Hash-Table"><a href="#哈希表-散列表-Hash-Table" class="headerlink" title="哈希表/散列表 (Hash Table)"></a>哈希表/散列表 (Hash Table)</h3><ul><li>散列函数</li><li>碰撞解决</li></ul><h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><ul><li>排序</li><li>查找<ul><li>BF算法  </li><li>KMP算法  </li><li>BM算法  </li></ul></li><li>正则表达式</li><li>数据压缩</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>二叉树    </li><li>二叉查找树   </li><li>伸展树(splay tree 分裂树)   </li><li>平衡二叉树AVL    </li><li>红黑树  </li><li>B树,B+,B*  </li><li>R树  </li><li>Trie树(前缀树)  </li><li>后缀树  </li><li>最优二叉树(赫夫曼树) </li><li>二叉堆 （大根堆，小根堆）   </li><li>二项树    </li><li>二项堆  </li><li>斐波那契堆(Fibonacci Heap)   </li></ul><h3 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h3><ul><li>图的存储结构和基本操作（建立，遍历，删除节点，添加节点）   </li><li>最小生成树  </li><li>拓扑排序  </li><li>关键路径  </li><li>最短路径: Floyd,Dijkstra,bellman-ford,spfa  </li></ul><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>交换排序算法</strong></p><ul><li>冒泡排序</li><li>插入排序    </li><li>选择排序    </li><li>希尔排序</li><li>快排   </li><li>归并排序  </li><li>堆排序</li></ul><p><strong>线性排序算法</strong></p><ul><li>桶排序 </li></ul><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul><li>顺序表查找：顺序查找  </li><li>有序表查找：二分查找  </li><li>分块查找： 块内无序，块之间有序；可以先二分查找定位到块，然后再到<code>块</code>中顺序查找  </li><li>动态查找:  二叉排序树，AVL树，B- ，B+    （这里之所以叫 <code>动态查找表</code>，是因为表结构是查找的过程中动态生成的）</li><li>哈希表：  O(1)     </li></ul><h3 id="15个经典基础算法"><a href="#15个经典基础算法" class="headerlink" title="15个经典基础算法"></a>15个经典基础算法</h3><ul><li>Hash  </li><li>快速排序 </li><li>快递选择SELECT </li><li>BFS/DFS （广度/深度优先遍历）    </li><li>红黑树 （一种自平衡的<code>二叉查找树</code>）  </li><li>KMP    字符串匹配算法</li><li>DP (动态规划 dynamic programming)   </li><li>A*寻路算法： 求解最短路径 </li><li>Dijkstra：最短路径算法 （八卦下：Dijkstra是荷兰的计算机科学家,提出”信号量和PV原语“,”解决哲学家就餐问题”,”死锁“也是它提出来的） </li><li>遗传算法  </li><li>启发式搜索   </li><li>图像特征提取之SIFT算法  </li><li>傅立叶变换  </li><li>SPFA(shortest path faster algorithm)  单元最短路径算法  </li></ul><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li>Hash映射/分而治之</li><li>Bitmap</li><li>Bloom filter(布隆过滤器)</li><li>Trie树</li><li>数据库索引</li><li>倒排索引(Inverted Index)</li><li>双层桶划分</li><li>外排序</li><li>simhash算法</li><li>分布处理之Mapreduce</li></ul><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ul><li>迭代法  </li><li>穷举搜索法  </li><li>递推法  </li><li>动态规划  </li><li>贪心算法  </li><li>回溯  </li><li>分治算法  </li></ul><h2 id="算法问题选编"><a href="#算法问题选编" class="headerlink" title="算法问题选编"></a>算法问题选编</h2><p>这是一个算法题目合集，题目是我从网络和书籍之中整理而来，部分题目已经做了思路整理。问题分类包括：</p><ul><li>字符串</li><li>堆和栈</li><li>链表</li><li>数值问题</li><li>数组和数列问题</li><li>矩阵问题</li><li>二叉树</li><li>图</li><li>海量数据处理</li><li>智力思维训练</li><li>系统设计</li></ul><p>还有部分来自算法网站和书籍：</p><ul><li>九度OJ</li><li>leetcode</li><li>剑指offer</li></ul><h2 id="开源项目中的算法"><a href="#开源项目中的算法" class="headerlink" title="开源项目中的算法"></a>开源项目中的算法</h2><ul><li>YYCache</li><li>cocos2d-objc</li><li>…</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="刷题必备"><a href="#刷题必备" class="headerlink" title="刷题必备"></a>刷题必备</h3><p>《剑指offer》<br>《编程之美》<br>《编程之法:面试和算法心得》<br>《算法谜题》 都是思维题 </p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>《编程珠玑》Programming Pearls<br>《编程珠玑(续)》<br>《数据结构与算法分析》<br>《Algorithms》 这本近千页的书只有6章,其中四章分别是排序，查找，图，字符串，足见介绍细致     </p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>《算法设计与分析基础》<br>《算法引论》 告诉你如何创造算法   断货<br>《Algorithm Design Manual》算法设计手册 红皮书  </p><p>《算法导论》 是一本对算法介绍比较全面的经典书籍   </p><p>《Algorithms on Strings,Trees and Sequences》<br>《Advanced Data Structures》 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树  600块    </p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>《深入理解计算机系统》<br>《TCP/IP详解三卷》<br>《UNIX网络编程二卷》<br>《UNIX环境高级编程：第2版》  </p><p>《The practice of programming》   Brian Kernighan和Rob Pike<br>《writing efficient programs》  优化<br>《The science of programming》 证明代码段的正确性   800块一本   </p><h2 id="参考链接和学习网站"><a href="#参考链接和学习网站" class="headerlink" title="参考链接和学习网站"></a>参考链接和学习网站</h2><h3 id="July-博客"><a href="#July-博客" class="headerlink" title="July 博客"></a><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">July 博客</a></h3><p>《数学建模十大经典算法》<br>《数据挖掘领域十大经典算法》<br>《十道海量数据处理面试题》<br>《数字图像处理领域的二十四个经典算法》<br>《精选微软等公司经典的算法面试100题》 </p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">The-Art-Of-Programming-By-July</a><br><a href="http://blog.csdn.net/column/details/ms100.html" target="_blank" rel="noopener">微软面试100题</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6460494" target="_blank" rel="noopener">程序员编程艺术</a>   </p><h3 id="基本算法演示"><a href="#基本算法演示" class="headerlink" title="基本算法演示"></a>基本算法演示</h3><p><a href="http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html" target="_blank" rel="noopener">http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html</a><br><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">http://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a>  </p><h3 id="编程网站"><a href="#编程网站" class="headerlink" title="编程网站"></a>编程网站</h3><p><a href="http://leetcode.com/" target="_blank" rel="noopener">leetcode</a><br><a href="http://openjudge.cn/" target="_blank" rel="noopener">openjudge</a>  开放在线程序评测平台，可以床架自己的OJ小组<br><a href="http://ac.jobdu.com/index.php" target="_blank" rel="noopener">九度OJ</a>     </p><p>这有个<a href="http://www.java3z.com/cwbwebhome/article/article19/res041.html" target="_blank" rel="noopener">ACM训练方案</a>   </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/" target="_blank" rel="noopener">高级数据结构和算法</a>  北大教授张铭老师在coursera上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie树、AVL树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然coursera上也还有很多其它算法方面的视频课程。</p><p><a href="https://class.coursera.org/algorithms-001/lecture" target="_blank" rel="noopener">算法设计与分析 Design and Analysis of Algorithms</a> 由北大教授Wanling Qu在coursera讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf文件）以便阅读和复习。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构算法" scheme="https://hankin2015.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://hankin2015.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅的机器学习笔记</title>
    <link href="https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/"/>
    <id>https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/</id>
    <published>2019-04-21T02:47:41.000Z</published>
    <updated>2018-08-12T17:35:33.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html" target="_blank" rel="noopener">李宏毅机器学习深度学习资料</a><br><a href="https://www.bilibili.com/video/av10590361?from=search&amp;seid=8971112424275201304" target="_blank" rel="noopener">李宏毅2017机器学习视频</a><br><a href="https://www.52ml.net/" target="_blank" rel="noopener">我爱机器学习</a><br><a href="https://www.lintcode.com/" target="_blank" rel="noopener">周sir推荐lintcode</a><br><a href="https://www.jiqizhixin.com/articles/02111" target="_blank" rel="noopener">邓miss推荐李沫动手学深度学习</a></p><h1 id="1、Introduction-of-this-course"><a href="#1、Introduction-of-this-course" class="headerlink" title="1、Introduction of this course"></a>1、Introduction of this course</h1><p>人工智慧目标-》机器学习手段-》深度学习方法<br>之前的智慧：人类设定好的天生本能</p><ul><li>河狸生物的本能筑水坝</li><li>Chat_bot和漫画智能机器人多个if调侃AI<a id="more"></a><h2 id="3步Machine-Learning-is-so-simple-……"><a href="#3步Machine-Learning-is-so-simple-……" class="headerlink" title="3步Machine Learning is so simple ……"></a>3步Machine Learning is so simple ……</h2>Step 1: define a set of function<br>Step 2: goodness of function<br>Step 3: pick the best function<br>就好像吧大象放进冰箱……</li></ul><h2 id="Learning-Map-scenario-task-method"><a href="#Learning-Map-scenario-task-method" class="headerlink" title="Learning Map: scenario task method"></a>Learning Map: scenario task method</h2><ul><li>Supervised Learning<ul><li>Regression</li><li>Classification<ul><li>Linear Model</li><li>Non-linear Model<ul><li>Deep Learning</li><li>SVM, decision tree, K-NN …</li></ul></li></ul></li><li>Structured Learning</li></ul></li><li>Semi-supervised Learning</li><li>Transfer Learning</li><li>Unsupervised Learning</li><li>Reinforcement Learning</li></ul><h1 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h1><p>saddle point鞍点<br>local minima极点</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅机器学习深度学习资料&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.bilibili.com/video/av10590361?from=search&amp;amp;seid=8971112424275201304&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅2017机器学习视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.52ml.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我爱机器学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.lintcode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;周sir推荐lintcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/02111&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;邓miss推荐李沫动手学深度学习&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、Introduction-of-this-course&quot;&gt;&lt;a href=&quot;#1、Introduction-of-this-course&quot; class=&quot;headerlink&quot; title=&quot;1、Introduction of this course&quot;&gt;&lt;/a&gt;1、Introduction of this course&lt;/h1&gt;&lt;p&gt;人工智慧目标-》机器学习手段-》深度学习方法&lt;br&gt;之前的智慧：人类设定好的天生本能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;河狸生物的本能筑水坝&lt;/li&gt;
&lt;li&gt;Chat_bot和漫画智能机器人多个if调侃AI
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习笔记</title>
    <link href="https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/"/>
    <id>https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/</id>
    <published>2019-01-15T02:47:41.000Z</published>
    <updated>2018-09-25T01:53:46.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="http://zh.gluon.ai/index.html#" target="_blank" rel="noopener">动手学深度学习</a><br>这是一个深度学习的教学项目。我们将使用 Apache MXNet (incubating) 的最新 gluon 接口来演示如何从0开始实现深度学习的各个算法。我们的将利用 Jupyter notebook 能将文档，代码，公式和图形统一在一起的优势，提供一个交互式的学习体验。这个项目可以作为一本书，上课用的材料，现场演示的案例，和一个可以尽情拷贝的代码库。据我们所知，目前并没有哪个项目能既覆盖全面深度学习，又提供交互式的可执行代码。我们将尝试弥补这个空白。</p><p>第一季十九课视频汇总<br>可打印的PDF版本在这里<br>课程源代码在Github （亲，给个好评加颗星）<br>请使用 <a href="http://discuss.gluon.ai/" target="_blank" rel="noopener">http://discuss.gluon.ai/</a> 来进行讨论</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="主要符号一览"><a href="#主要符号一览" class="headerlink" title="主要符号一览"></a>主要符号一览</h2><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><h3 id="1、用代码编程和用数据编程"><a href="#1、用代码编程和用数据编程" class="headerlink" title="1、用代码编程和用数据编程"></a>1、用代码编程和用数据编程</h3><p>这个例子灵感来自 Joel Grus 的一次 应聘面试. 面试官让他写个程序来玩Fizz Buzz. 这是一个小孩子游戏。玩家从1数到100，如果数字被3整除，那么喊’fizz’，如果被5整除就喊’buzz’，如果两个都满足就喊’fizzbuzz’，不然就直接说数字。这个游戏玩起来就像是：</p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 …</p></blockquote><p>传统的实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [1]:</span><br><span class="line">res = []</span><br><span class="line">for i in range(1, 101):</span><br><span class="line">    if i % 15 == 0:</span><br><span class="line">        res.append(&apos;fizzbuzz&apos;)</span><br><span class="line">    elif i % 3 == 0:</span><br><span class="line">        res.append(&apos;fizz&apos;)</span><br><span class="line">    elif i % 5 == 0:</span><br><span class="line">        res.append(&apos;buzz&apos;)</span><br><span class="line">    else:</span><br><span class="line">        res.append(str(i))</span><br><span class="line">print(&apos; &apos;.join(res))</span><br></pre></td></tr></table></figure></p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz b</p></blockquote><p>对于经验丰富的程序员来说这个太不够一颗赛艇了。所以Joel尝试用机器学习来实现这个。为了让程序能学，他需要准备下面这个数据集：</p><ul><li>数据 X [1, 2, 3, 4, …] 和标注Y [‘fizz’, ‘buzz’, ‘fizzbuzz’, identity]</li><li>训练数据，也就是系统输入输出的实例。例如 [(2, 2), (6, fizz), (15, fizzbuzz), (23, 23), (40, buzz)]</li><li>从输入数据中抽取的特征，例如 x -&gt; [(x % 3), (x % 5), (x % 15)].</li></ul><p>有了这些，Jeol利用TensorFlow写了一个分类器。对于不按常理出牌的Jeol，面试官一脸黑线。而且这个分类器不是总是对的。</p><h3 id="2、机器学习最简要素"><a href="#2、机器学习最简要素" class="headerlink" title="2、机器学习最简要素"></a>2、机器学习最简要素</h3><p>成功的机器学习有四个要素：数据、转换数据的模型、衡量模型好坏的损失函数和一个调整模型权重来最小化损失函数的算法。</p><h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><h4 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h4><ul><li>训练误差（training error）：这是模型在用于训练的数据集上的误差。类似于考试前我们在模拟试卷上拿到的分数。有一定的指向性，但不一定保证真实考试分数。</li><li>测试误差（test error）：这是模型在没见过的新数据上的误差，可能会跟训练误差很不一样（统计上称之为过拟合）。类似于考前模考次次拿高分，但实际考起来却失误了。</li></ul><h4 id="Optimization-Algorithms"><a href="#Optimization-Algorithms" class="headerlink" title="Optimization Algorithms"></a>Optimization Algorithms</h4><h3 id="3、Supervised-Learning"><a href="#3、Supervised-Learning" class="headerlink" title="3、Supervised Learning"></a>3、Supervised Learning</h3><p>简单概括，学习过程看起来是这样的：在一大组数据中随机地选择样本输入，并获得其真实（ground-truth）的标注（label）；这些输入和标注（即期望的结果）构成了训练集（training set）。我们把训练集放入一个监督学习算法（supervised learning algorithm）。算法的输入是训练集，输出则是学得模型（learned model）。基于这个学得模型，我们输入之前未见过的测试数据，并预测相应的标注。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zh.gluon.ai/_images/supervised-learning.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="3-1、Regression"><a href="#3-1、Regression" class="headerlink" title="3-1、Regression"></a>3-1、Regression</h4><p>在该项任务里，输入是任意离散或连续的、单一或多个的变量，而输出是连续的数值。</p><p>一条经验就是，问题中如果包含“多少？”，这类问题一般是回归问题。“这次手术需要几个小时？”……回归分析。“这张照片里有几只狗？”……回归分析。不过，如果问题能够转化为“这是一个<em>__</em>吗？”，那这很有可能是一个分类，或者属于其余我们将会谈及的问题。</p><p>如果我们把模型预测的输出值和真实的输出值之间的差别定义为残差，常见的回归分析的损失函数包括训练数据的残差的平方和或者绝对值的和。机器学习的任务是找到一组模型参数使得损失函数最小化。</p><h4 id="3-2、Classification"><a href="#3-2、Classification" class="headerlink" title="3-2、Classification"></a>3-2、Classification</h4><p>回归分析所关注的预测可以解答输出为连续数值 的问题。当预测的输出是离散的 类别时，这个监督学习任务就叫做分类。</p><h2 id="使用NDArray来处理数据"><a href="#使用NDArray来处理数据" class="headerlink" title="使用NDArray来处理数据"></a>使用NDArray来处理数据</h2><p>使用autograd来自动求导<br>深度学习模型基础<br>线性回归——从零开始<br>线性回归——使用Gluon<br>多类逻辑回归——从零开始<br>多类逻辑回归——使用Gluon<br>多层感知机——从零开始<br>多层感知机——使用Gluon<br>欠拟合和过拟合<br>正则化——从零开始<br>正则化——使用Gluon<br>丢弃法（Dropout）——从零开始<br>丢弃法（Dropout）——使用Gluon<br>正向传播和反向传播<br>实战Kaggle比赛——使用Gluon预测房价和K折交叉验证<br>深度学习计算基础<br>模型构造<br>模型参数<br>自定义层<br>读取和存储<br>GPU计算<br>卷积神经网络<br>卷积神经网络 — 从0开始<br>卷积神经网络 — 使用Gluon<br>批量归一化 — 从0开始<br>批量归一化 — 使用Gluon<br>深度卷积神经网络和AlexNet<br>VGG：使用重复元素的非常深的网络<br>网络中的网络<br>更深的卷积神经网络：GoogLeNet<br>ResNet：深度残差网络<br>DenseNet：稠密连接的卷积神经网络<br>循环神经网络<br>循环神经网络 — 从0开始<br>通过时间反向传播<br>门控循环单元（GRU）— 从0开始<br>长短期记忆（LSTM）— 从0开始<br>循环神经网络 — 使用Gluon<br>优化算法<br>优化算法概述<br>梯度下降和随机梯度下降——从零开始<br>梯度下降和随机梯度下降——使用Gluon<br>动量法——从零开始<br>动量法——使用Gluon<br>Adagrad——从零开始<br>Adagrad——使用Gluon<br>RMSProp——从零开始<br>RMSProp——使用Gluon<br>Adadelta——从零开始<br>Adadelta——使用Gluon<br>Adam——从零开始<br>Adam——使用Gluon<br>计算性能<br>命令式和符号式混合编程<br>惰性计算<br>自动并行计算<br>多GPU训练模型——从零开始<br>多GPU训练模型——使用Gluon<br>计算机视觉<br>图片增广<br>Fine-tuning: 通过微调来迁移学习<br>使用卷积神经网络的物体检测<br>SSD — 使用Gluon<br>YOLO — 使用Gluon<br>语义分割：FCN<br>样式迁移<br>实战Kaggle比赛——使用Gluon对原始图像文件分类（CIFAR-10）<br>实战Kaggle比赛——使用Gluon识别120种狗 (ImageNet Dogs)<br>自然语言处理<br>词向量 — word2vec<br>词向量 — GloVe和fastText<br>使用预训练的词向量<br>编码器—解码器（seq2seq）和注意力机制<br>神经机器翻译<br>附录<br>安装和使用<br>GPU购买指南<br>在AWS上运行教程<br>数学基础<br>本教程的英文版本 （注意：中文版本根据社区的反馈做了比较大的更改，我们还在努力的将改动同步到英文版）</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
  <entry>
    <title>判断一个点是否在一个多边形内</title>
    <link href="https://hankin2015.github.io/2018/11/03/20181103poly/"/>
    <id>https://hankin2015.github.io/2018/11/03/20181103poly/</id>
    <published>2018-11-03T03:48:41.000Z</published>
    <updated>2018-11-03T11:54:27.313Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。</p><a id="more"></a><h1 id="简单的特例：三角形"><a href="#简单的特例：三角形" class="headerlink" title="简单的特例：三角形"></a>简单的特例：三角形</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>比较常用的算法是射线法，以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。<br>若有偶数个交点则在形外，否则在形内。<br>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>面积法：海伦公式、向量公式</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>向量法</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://hihocoder.com/contest/hiho225/problem/1" target="_blank" rel="noopener">http://hihocoder.com/contest/hiho225/problem/1</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">在三角形内部的点形成的都是钝角三角形</span><br><span class="line">点在x,y的中间并不能判断</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long double</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">LL Heron(LL a, LL b, LL c)</span><br><span class="line">&#123;</span><br><span class="line">    return 0.25 * sqrt((a + b + c) * (a + b - c) * (a + c - b) * (b + c - a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Distance(LL x1, LL y1, LL x2, LL y2)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        LL x[4], y[4];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        LL s = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; 4; j++) &#123;</span><br><span class="line">                LL a = Distance(x[0], y[0], x[i], y[i]), b = Distance(x[0], y[0], x[j], y[j]), c = Distance(x[i], y[i], x[j], y[j]);</span><br><span class="line">                s += Heron(a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Distance(x[1], y[1], x[2], y[2]), b = Distance(x[1], y[1], x[3], y[3]), c = Distance(x[2], y[2], x[3], y[3]);</span><br><span class="line">        //cout &lt;&lt; s &lt;&lt; &apos; &apos; &lt;&lt; Heron(a, b, c) &lt;&lt; endl;</span><br><span class="line">        if (abs(s - Heron(a, b, c)) &lt; eps) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入的都是整数，三角形面积计算s=0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">所有面积里都有这个0.5，去掉这个0.5对结果不影响，于是面积计算出来就是整数，没有精度问题了。</span><br><span class="line">向量法求面积。</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">LL area(LL x1,LL y1,LL x2,LL y2,LL x3,LL y3)</span><br><span class="line">&#123;</span><br><span class="line">    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LL Px, Py, Ax, Ay, Bx, By, Cx, Cy;</span><br><span class="line">    LL S, S1, S2, S3;</span><br><span class="line">    LL t;</span><br><span class="line">    for(cin&gt;&gt;t;t&gt;0;t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;Px&gt;&gt;Py&gt;&gt;Ax&gt;&gt;Ay&gt;&gt;Bx&gt;&gt;By&gt;&gt;Cx&gt;&gt;Cy;</span><br><span class="line">        S  = area(Ax, Ay, Bx, By, Cx, Cy);</span><br><span class="line">        S1 = area(Px, Py, Ax, Ay, Bx, By);</span><br><span class="line">        S2 = area(Px, Py, Ax, Ay, Cx, Cy);</span><br><span class="line">        S3 = area(Px, Py, Bx, By, Cx, Cy);</span><br><span class="line">        if(S1+S2+S3&lt;=S)cout&lt;&lt;&quot;YES\n&quot;;else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">还有个简单的方法，判断三条边的向量与P跟三个点连接的向量的叉积，如果三个叉积值同正负，则在三角形内。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define G(v,_) scanf(&quot;%ld&quot;,&amp;v),v-=_;</span><br><span class="line">main(T)&#123;long p,P,a,A,b,B,c,C,x,y,z;for(G(T,0)T--;puts(((-x|-y|-z)&amp;(x|y|z))&lt;0?&quot;NO&quot;:&quot;YES&quot;))&#123;G(p,0)G(P,0)G(a,p)G(A,P)G(b,p)G(B,P)G(c,p)G(C,P)x=a*B-b*A;y=b*C-c*B;z=c*A-a*C;&#125;return 0;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四边形特例：矩形"><a href="#四边形特例：矩形" class="headerlink" title="四边形特例：矩形"></a>四边形特例：矩形</h1><p>（1）面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。<br>（2）夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。<br>（3）引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</p><p><a href="https://blog.csdn.net/u283056051/article/details/53980832" target="_blank" rel="noopener">https://blog.csdn.net/u283056051/article/details/53980832</a><br>1、射线法理论：从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。<br>2、特殊情况特殊处理：</p><pre><code>1. 点在多边形的边上 ：判断点与边端点连线斜率是否相同。2. 点和多边形的顶点重合 ：直接hash。3. 射线经过多边形顶点：只需要规定被射线穿越的点都算作其中一侧。 4. 射线刚好经过多边形的一条边：上面的特例，经过两个顶点。射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。</code></pre><h1 id="多边形代码（射线法和回转数法）"><a href="#多边形代码（射线法和回转数法）" class="headerlink" title="多边形代码（射线法和回转数法）"></a>多边形代码（射线法和回转数法）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">测试题：http://hihocoder.com/problemset/problem/1450?sid=1416458</span><br><span class="line">射线法没有过，回转数法连样例都不了，还弄不明白哪里错了。</span><br><span class="line">参考：https://blog.csdn.net/u283056051/article/details/53980832</span><br><span class="line">*/</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1e3 + 5;</span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">const double PI = atan(1) * 4;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 射线法</span><br><span class="line">string RayCasting(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey)) return &quot;on&quot;;</span><br><span class="line">        // 2、做一条水平射线，判断边两断点是否在射线两侧，并令穿过顶点的点在上端</span><br><span class="line">        if ((sy &lt; p.y &amp;&amp; ey &gt;= p.y) || (sy &gt;= p.y &amp;&amp; ey &lt; p.y)) &#123;</span><br><span class="line">            // 3、判断p点是否在多边形边上，斜率公式或者三角形比例公式（方便）</span><br><span class="line">            double x = sx + (p.y - sy) * (ex - sx) * 1.0 / (ey - sy);</span><br><span class="line">            if (abs(x - p.x) &lt; eps) return &quot;on&quot;;</span><br><span class="line">            // 水平向右作的射线，穿过一次就变换</span><br><span class="line">            if (x &gt; p.x) flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? &quot;in&quot; : &quot;out&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回转数法</span><br><span class="line">string WindingNumber(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0;  // 回转度数和</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合或在多边形边上</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey) || (p.x - sx) * (ey - sy) == (p.y - sy) * (ex - sx)) return &quot;on&quot;;</span><br><span class="line">        // 2、求夹角</span><br><span class="line">        double angle = atan((sy - p.y) * 1.0 / (sx - p.x)) - atan((ey - p.y) * 1.0 / (ex - p.x));</span><br><span class="line">        cout &lt;&lt; angle &lt;&lt; endl;</span><br><span class="line">        // 3、确保夹角不超过取值范围（-PI到PI）</span><br><span class="line">        if (angle &gt;= PI) angle -= 2 * PI;</span><br><span class="line">        else if (angle &lt;= -PI) angle += 2 * PI;</span><br><span class="line">        sum += angle;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    // 4、计算回转数</span><br><span class="line">    return round(sum / PI) == 0 ? &quot;out&quot; : &quot;in&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node p, poly[maxn];</span><br><span class="line">    int n = 3, T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        cin &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; poly[i].x &gt;&gt; poly[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        string res1 = RayCasting(p, poly, 3);</span><br><span class="line">        string res2 = WindingNumber(p, poly, 3);</span><br><span class="line">        if (res1 != res2) cout &lt;&lt; &quot;Wrong&quot; &lt;&lt; endl;</span><br><span class="line">        else if (res1 == &quot;out&quot;) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="https://hankin2015.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="凸包" scheme="https://hankin2015.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://hankin2015.github.io/2018/10/31/20181031topo/"/>
    <id>https://hankin2015.github.io/2018/10/31/20181031topo/</id>
    <published>2018-10-31T03:48:41.000Z</published>
    <updated>2018-11-03T12:22:40.474Z</updated>
    
    <content type="html"><![CDATA[<p>Face++面试中遇到的问题，手写一个拓扑排序函数，数据按照链式存储，即每个点链表存储出度的点。<br>当时想出了一种解决方法，不过看了其他解法，感觉自己的方法有点复杂，不过时间复杂度都是O(n^2)。</p><p>我当时的想法：正序没法找到拓扑的前后顺序，但是反过来就迎刃而解。从结束点（出度为0）开始，入队列。然后将入度当前点的点加入队列中。这样就找到了反序的拓扑序列，然后利用栈的特点反转就得到答案了。<br>当时面试官还和我谈论验证这个解法，但我觉得没啥问题。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">提示：跟一般的排序不一样，这个用于有向无环图</span><br><span class="line"></span><br><span class="line">对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，</span><br><span class="line">使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。</span><br><span class="line"></span><br><span class="line">拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某</span><br><span class="line">些工程执行后才可以执行。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span><br><span class="line">//优先队列的话，会按照数值大小有顺序的输出</span><br><span class="line">//此处为了理解，暂时就用简单队列</span><br><span class="line">int topo()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(indegree[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);  // 起点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=q.front();// 如果是优先队列，这里可以是top()</span><br><span class="line">        printf(&quot;%d-&gt;&quot;,temp);</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)// 遍历从temp出发的每一条边，入度--</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[temp][i])</span><br><span class="line">            &#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                if(indegree[i]==0)q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Face++面试中遇到的问题，手写一个拓扑排序函数，数据按照链式存储，即每个点链表存储出度的点。&lt;br&gt;当时想出了一种解决方法，不过看了其他解法，感觉自己的方法有点复杂，不过时间复杂度都是O(n^2)。&lt;/p&gt;
&lt;p&gt;我当时的想法：正序没法找到拓扑的前后顺序，但是反过来就迎刃而解。从结束点（出度为0）开始，入队列。然后将入度当前点的点加入队列中。这样就找到了反序的拓扑序列，然后利用栈的特点反转就得到答案了。&lt;br&gt;当时面试官还和我谈论验证这个解法，但我觉得没啥问题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="拓扑排序" scheme="https://hankin2015.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序" scheme="https://hankin2015.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>python中os模块</title>
    <link href="https://hankin2015.github.io/2018/10/27/20181027os/"/>
    <id>https://hankin2015.github.io/2018/10/27/20181027os/</id>
    <published>2018-10-27T03:48:41.000Z</published>
    <updated>2018-11-03T14:07:00.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判读文件和文件夹是否存在"><a href="#判读文件和文件夹是否存在" class="headerlink" title="判读文件和文件夹是否存在"></a>判读文件和文件夹是否存在</h1><p>文件能直接保存创建，但文件夹不行，需要先创建文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">if not os.path.exists(&apos;name&apos;):  # 能判断文件和文件夹</span><br><span class="line">os.mkdir(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">os.path.isfile(&apos;name&apos;)  # 只能判断文件</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用os.access()方法判断文件是否可进行读写操作。</p><p>语法：os.access(path, mode)</p><p>path为文件路径，mode为操作模式，有这么几种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.F_OK: 检查文件是否存在;</span><br><span class="line">os.R_OK: 检查文件是否可读;</span><br><span class="line">os.W_OK: 检查文件是否可以写入;</span><br><span class="line">os.X_OK: 检查文件是否可以执行.</span><br><span class="line"></span><br><span class="line">if not os.access(&apos;name&apos;, os.F_OK):</span><br><span class="line">os.mkdir(&apos;name&apos;)</span><br></pre></td></tr></table></figure></p><p>try语句也能，但尽量少用。<br>os.makedirs(path) 多层创建目录</p><h1 id="获取当前文件夹下所有文件"><a href="#获取当前文件夹下所有文件" class="headerlink" title="获取当前文件夹下所有文件"></a>获取当前文件夹下所有文件</h1><p>使用os.walk()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dataPath = &apos;./Unprocessed/&apos; </span><br><span class="line">def ListFile(fileDir):   </span><br><span class="line">    ret = []   </span><br><span class="line">    for root, dirs, files in os.walk(fileDir):  </span><br><span class="line">        for file in files:  </span><br><span class="line">            if os.path.splitext(file)[1] == &apos;.txt&apos;:   #其中os.path.splitext()函数将路径拆分为文件名+扩展名</span><br><span class="line">                ret.append(os.path.join(root, file))  </span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line">files = ListFile(dataPath)</span><br></pre></td></tr></table></figure></p><h1 id="使用os模块进行分类整理"><a href="#使用os模块进行分类整理" class="headerlink" title="使用os模块进行分类整理"></a>使用os模块进行分类整理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">path = &apos;./&apos;</span><br><span class="line">files = os.listdir(path)</span><br><span class="line"></span><br><span class="line">for file in files:</span><br><span class="line">folderName = &apos;./&apos; + file.split(&apos;.&apos;)[-1]</span><br><span class="line">if not os.path.exists(folderName):</span><br><span class="line">os.makedirs(folderName)</span><br><span class="line">shutil.move(file, folderName)</span><br><span class="line"></span><br><span class="line">print(&apos;done&apos;)</span><br></pre></td></tr></table></figure><h1 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;&apos;key1&apos; : [&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;a&apos;],</span><br><span class="line">    &apos;key2&apos; : [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;],</span><br><span class="line">    &apos;data1&apos; : np.random.randint(0, 9),</span><br><span class="line">    &apos;data2&apos; : np.random.randint(0, 9)&#125;)</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使数据data1列按照key1进行分组</span><br><span class="line">grouped = df[&apos;data1&apos;].groupby(df[&apos;key1&apos;])  # 需要注意grouped的数据类型，它不在是一个数据框，而是一个GroupBy对象。</span><br><span class="line">grouped</span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line">for name, group in grouped:</span><br><span class="line">    print(name)</span><br><span class="line">    print(group)</span><br><span class="line"></span><br><span class="line"># 做其他计算</span><br><span class="line">grouped.mean()</span><br></pre></td></tr></table></figure><h1 id="nunique"><a href="#nunique" class="headerlink" title="nunique"></a>nunique</h1><p>nuinque()是查看该序列(axis=0/1对应着列或行)的不同值的数量。用这个函数可以查看数据有多少个不同值。</p><h1 id="stack-、hstack-、vstack"><a href="#stack-、hstack-、vstack" class="headerlink" title="stack()、hstack()、vstack()"></a>stack()、hstack()、vstack()</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack()"></a>stack()</h2><p>stack的意思是堆叠，堆积，unstack即“不要堆叠”，我对两个函数是这样理解和区分的。<br><a href="https://www.cnblogs.com/bambipai/p/7658311.html" target="_blank" rel="noopener">https://www.cnblogs.com/bambipai/p/7658311.html</a></p><h2 id="hstack"><a href="#hstack" class="headerlink" title="hstack()"></a>hstack()</h2><p>水平(按列顺序)把数组给堆叠起来，vstack()函数正好和它相反。</p><h2 id="vstack"><a href="#vstack" class="headerlink" title="vstack()"></a>vstack()</h2><p>垂直（按照行顺序）的把数组给堆叠起来。</p><h1 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h1><p>str.replace(old, new[, max])<br>参数<br>old – 将被替换的子字符串。<br>new – 新字符串，用于替换old子字符串。<br>max – 可选字符串, 替换不超过 max 次</p><h1 id="This-is-beacause…"><a href="#This-is-beacause…" class="headerlink" title="This is beacause…"></a>This is beacause…</h1><p> It/This/That is because……，该句型是because 引导的表语从句。</p><p> 通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><h1 id="first和firstly的区别是什么"><a href="#first和firstly的区别是什么" class="headerlink" title="first和firstly的区别是什么?"></a>first和firstly的区别是什么?</h1><p>first：可以做名词，副词，形容词，第一，首先。除了用于开场白，还有第一的意思 。firstly ：形容词，强调第一个（做完的），最先的。</p><p>注意事项：<br>当first和firstly作副词用的时侯，如果“用于分开并依次列举所述各点”时，是没有什么区别的，可以替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判读文件和文件夹是否存在&quot;&gt;&lt;a href=&quot;#判读文件和文件夹是否存在&quot; class=&quot;headerlink&quot; title=&quot;判读文件和文件夹是否存在&quot;&gt;&lt;/a&gt;判读文件和文件夹是否存在&lt;/h1&gt;&lt;p&gt;文件能直接保存创建，但文件夹不行，需要先创建文件夹。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if not os.path.exists(&amp;apos;name&amp;apos;):  # 能判断文件和文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	os.mkdir(&amp;apos;name&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.path.isfile(&amp;apos;name&amp;apos;)  # 只能判断文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="https://hankin2015.github.io/categories/PYTHON/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="Os" scheme="https://hankin2015.github.io/tags/Os/"/>
    
      <category term="Groupby" scheme="https://hankin2015.github.io/tags/Groupby/"/>
    
      <category term="Replace" scheme="https://hankin2015.github.io/tags/Replace/"/>
    
      <category term="stack" scheme="https://hankin2015.github.io/tags/stack/"/>
    
      <category term="vstack" scheme="https://hankin2015.github.io/tags/vstack/"/>
    
      <category term="hstack" scheme="https://hankin2015.github.io/tags/hstack/"/>
    
  </entry>
  
  <entry>
    <title>删除字符串指针中空格和统计文章中的最频繁词</title>
    <link href="https://hankin2015.github.io/2018/10/26/20181026DeleteSpace/"/>
    <id>https://hankin2015.github.io/2018/10/26/20181026DeleteSpace/</id>
    <published>2018-10-26T09:25:41.000Z</published>
    <updated>2018-10-27T02:57:37.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针函数和函数指针的区别"><a href="#指针函数和函数指针的区别" class="headerlink" title="指针函数和函数指针的区别"></a>指针函数和函数指针的区别</h1><p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p><p><a href="https://baijiahao.baidu.com/s?id=1580218358235866033&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">百度搜索特效：搜索黑洞，屏幕真的出现了黑洞一样的画面</a></p><a id="more"></a><h1 id="删除字符串指针中空格"><a href="#删除字符串指针中空格" class="headerlink" title="删除字符串指针中空格"></a>删除字符串指针中空格</h1><ul><li>原始字符串不能是指针字符串，因不能对其本身进行修改</li><li>必须需要两个指针</li><li>末尾需置”\0”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">DeleteSpace</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = str, *q = str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">while</span> (*q != <span class="string">'\0'</span>) &#123;  <span class="comment">// 指针字符串没有"\0"，但char数组有</span></span><br><span class="line">        <span class="keyword">if</span> (*q != <span class="string">' '</span>) &#123;</span><br><span class="line">            *p = *q;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char* str = "  he jian  ";   // 不能写成指针字符串，指针不能对其值进行修改</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"  he jian  "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; DeleteSpace(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="assert进行样例调试"><a href="#assert进行样例调试" class="headerlink" title="assert进行样例调试"></a>assert进行样例调试</h1><ul><li>报错会出现Assertion failed: fun(5) == 6, file C:\Users\Administrator\Desktop\腾讯.cpp, line 41</li><li>不报错正常运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    assert(fun(5) == 6);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="统计文章中的最频繁K个词"><a href="#统计文章中的最频繁K个词" class="headerlink" title="统计文章中的最频繁K个词"></a>统计文章中的最频繁K个词</h1><ul><li>hash + 优先队列</li><li>堆<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//出现次数最多的是个单词  </span><br><span class="line">void top_k_words()  </span><br><span class="line">&#123;  </span><br><span class="line">    timer t;  </span><br><span class="line">    ifstream fin;  </span><br><span class="line">    fin.open(&quot;modern c.txt&quot;);  </span><br><span class="line">    if (!fin)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;can nont open file&quot;&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    string s;  </span><br><span class="line">    hash_map&lt;string,int&gt; countwords;  </span><br><span class="line">    while (true)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fin&gt;&gt;s;  </span><br><span class="line">        if (fin.eof())  </span><br><span class="line">        &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        countwords[s]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;&quot;单词总数 （重复的不计数）:&quot;&lt;&lt;countwords.size()&lt;&lt;endl;  </span><br><span class="line">    priority_queue&lt;pair&lt;int,string&gt;,vector&lt;pair&lt;int,string&gt;&gt;,greater&lt;pair&lt;int,string&gt;&gt;&gt; countmax;  </span><br><span class="line">    for(hash_map&lt;string,int&gt;::const_iterator i=countwords.begin();  </span><br><span class="line">        i!=countwords.end();i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        countmax.push(make_pair(i-&gt;second,i-&gt;first));  </span><br><span class="line">        if (countmax.size()&gt;10)  </span><br><span class="line">        &#123;  </span><br><span class="line">            countmax.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    while(!countmax.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;countmax.top().second&lt;&lt;&quot; &quot;&lt;&lt;countmax.top().first&lt;&lt;endl;  </span><br><span class="line">        countmax.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;&quot;time elapsed &quot;&lt;&lt;t.elapsed()&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><ul><li>top</li><li>size</li><li>empty</li><li>push</li><li>pop<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">void PQueue()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;   // 按照元素从小到大的顺序出队</span><br><span class="line">    //priority_queue&lt;pair&lt;int,string&gt;,vector&lt;pair&lt;int,string&gt;&gt;,greater&lt;pair&lt;int,string&gt;&gt;&gt; countMax;</span><br><span class="line"></span><br><span class="line">    int A[] = &#123;7, 5, 2, 1, 3, 4, 6&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">        Q.push(A[i]);</span><br><span class="line">        int tmp = Q.top();</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PQueue();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针函数和函数指针的区别&quot;&gt;&lt;a href=&quot;#指针函数和函数指针的区别&quot; class=&quot;headerlink&quot; title=&quot;指针函数和函数指针的区别&quot;&gt;&lt;/a&gt;指针函数和函数指针的区别&lt;/h1&gt;&lt;p&gt;指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。&lt;br&gt;函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1580218358235866033&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度搜索特效：搜索黑洞，屏幕真的出现了黑洞一样的画面&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="Char" scheme="https://hankin2015.github.io/tags/Char/"/>
    
      <category term="指针" scheme="https://hankin2015.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="优先队列" scheme="https://hankin2015.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>bat和vbs脚本</title>
    <link href="https://hankin2015.github.io/2018/10/22/20181022bat_vbs/"/>
    <id>https://hankin2015.github.io/2018/10/22/20181022bat_vbs/</id>
    <published>2018-10-22T09:43:41.000Z</published>
    <updated>2018-10-27T02:56:48.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bat和vbs脚本"><a href="#bat和vbs脚本" class="headerlink" title="bat和vbs脚本"></a>bat和vbs脚本</h1><p>bat脚本是依赖于cmd命令窗口的一种脚本语言。vbs脚本是使用vbasic语言编写的脚本语言，基于wscript.exe程序来运行。两者语法上相差很大.vbs脚本功能更加地强大，他能调用dll动态库完成一些bat不能完成的功能。同时bat与vbs可以互相调用。</p><p>bat是批处文件，实际上是一条条dos命令的集合，由命令行调用。vbs是vb脚本文件，当然还有java脚本文件，vbs由vb语言写成，但他不需要vb那样的编译环境，只要是文本编辑器都可以，他由系统的脚本解释器执行，一般vbs脚本都用在网页中，用于显示一些特效或特殊的用途。<br><a id="more"></a></p><h1 id="自动关机脚本-bat"><a href="#自动关机脚本-bat" class="headerlink" title="自动关机脚本(bat)"></a>自动关机脚本(bat)</h1><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -s -t <span class="number">60</span></span><br><span class="line"></span><br><span class="line">取消 shutdown -a</span><br></pre></td></tr></table></figure><h1 id="隐藏文件-bat"><a href="#隐藏文件-bat" class="headerlink" title="隐藏文件(bat)"></a>隐藏文件(bat)</h1><p>可以将两个不同格式的文件合在一起。<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>/b 何健.jpg+皂片.rar=out.jpg</span><br></pre></td></tr></table></figure></p><h1 id="语音助手-vbs"><a href="#语音助手-vbs" class="headerlink" title="语音助手(vbs)"></a>语音助手(vbs)</h1><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateObject</span>(<span class="string">"SAPI.SpVoice"</span>).speak<span class="string">"机器学习中，如果参数过多，模型过于复杂，容易造成过拟合（overfit）。即模型在训练样本数据上表现的很好，但在实际测试样本上表现的较差，不具备良好的泛化能力。为了避免过拟合，最常用的一种方法是使用使用正则化，例如 L1 和 L2 正则化。但是，正则化项是如何得来的？其背后的数学原理是什么？L1 正则化和 L2 正则化之间有何区别？本文将给出直观的解释。"</span></span><br></pre></td></tr></table></figure><h1 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GodMode.&#123;ED7BA470-8E54-465E-825C-99712043E01C&#125;</span><br><span class="line">新建文件夹-》用上面代码重命名</span><br><span class="line"></span><br><span class="line">隐藏的一个文件夹窗口，包含几乎所有系统的设置。</span><br></pre></td></tr></table></figure><h1 id="黑客帝国中的数字雨"><a href="#黑客帝国中的数字雨" class="headerlink" title="黑客帝国中的数字雨"></a>黑客帝国中的数字雨</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/qq_36238595/article/details/56682261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU st[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//出现位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hout;</span><br><span class="line">    COORD pos;</span><br><span class="line">    pos.X = x;</span><br><span class="line">    pos.Y = y;</span><br><span class="line"></span><br><span class="line">    hout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    SetConsoleCursorPosition(hout, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐藏光标*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_cursor</span><span class="params">(<span class="keyword">int</span> hide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONSOLE_CURSOR_INFO cciCursor;</span><br><span class="line">    HANDLE hout;</span><br><span class="line"></span><br><span class="line">    hout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    <span class="keyword">if</span>(GetConsoleCursorInfo(hout, &amp;cciCursor))</span><br><span class="line">    &#123;</span><br><span class="line">        cciCursor.bVisible = hide;</span><br><span class="line">        SetConsoleCursorInfo(hout, &amp;cciCursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置颜色*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">show_cursor(<span class="number">0</span>);</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i].x = rand()%<span class="number">80</span>;</span><br><span class="line">st[i].y = rand()%<span class="number">20</span>;</span><br><span class="line">st[i].ch = rand()%(<span class="number">49</span><span class="number">-47</span>)+<span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">gotoxy(st[i].x,st[i].y);</span><br><span class="line">set_color(<span class="number">0x2</span>);</span><br><span class="line"><span class="built_in">putchar</span>(st[i].ch);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-5</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">st[i].y++;</span><br><span class="line">st[i].ch = rand()%(<span class="number">49</span><span class="number">-47</span>)+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">if</span> (st[i].y<span class="number">-5</span>&gt;=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-3</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st[i].y &gt; <span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">st[i].x = rand()%<span class="number">80</span>;</span><br><span class="line">st[i].y = rand()%<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">gotoxy(st[i].x,st[i].y);</span><br><span class="line">set_color(<span class="number">0xA</span>);</span><br><span class="line"><span class="built_in">putchar</span>(st[i].ch);</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;bat和vbs脚本&quot;&gt;&lt;a href=&quot;#bat和vbs脚本&quot; class=&quot;headerlink&quot; title=&quot;bat和vbs脚本&quot;&gt;&lt;/a&gt;bat和vbs脚本&lt;/h1&gt;&lt;p&gt;bat脚本是依赖于cmd命令窗口的一种脚本语言。vbs脚本是使用vbasic语言编写的脚本语言，基于wscript.exe程序来运行。两者语法上相差很大.vbs脚本功能更加地强大，他能调用dll动态库完成一些bat不能完成的功能。同时bat与vbs可以互相调用。&lt;/p&gt;
&lt;p&gt;bat是批处文件，实际上是一条条dos命令的集合，由命令行调用。vbs是vb脚本文件，当然还有java脚本文件，vbs由vb语言写成，但他不需要vb那样的编译环境，只要是文本编辑器都可以，他由系统的脚本解释器执行，一般vbs脚本都用在网页中，用于显示一些特效或特殊的用途。&lt;br&gt;
    
    </summary>
    
      <category term="OTHER" scheme="https://hankin2015.github.io/categories/OTHER/"/>
    
    
      <category term="Vbs" scheme="https://hankin2015.github.io/tags/Vbs/"/>
    
      <category term="Bat" scheme="https://hankin2015.github.io/tags/Bat/"/>
    
      <category term="抖音" scheme="https://hankin2015.github.io/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>精通Python爬虫框架Scrapy</title>
    <link href="https://hankin2015.github.io/2018/10/05/20181005Scrapy/"/>
    <id>https://hankin2015.github.io/2018/10/05/20181005Scrapy/</id>
    <published>2018-10-05T15:47:41.000Z</published>
    <updated>2018-10-03T02:53:00.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、个人曾经的爬虫"><a href="#0、个人曾经的爬虫" class="headerlink" title="0、个人曾经的爬虫"></a>0、个人曾经的爬虫</h1><p>Requests库、Beautiful Soup。<br>本科毕业设计：微博爬虫。</p><h1 id="1、Scrapy"><a href="#1、Scrapy" class="headerlink" title="1、Scrapy"></a>1、Scrapy</h1><p>&emsp;&emsp;Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。<br>&emsp;&emsp;Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。<br>&emsp;&emsp;Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。外号小刮刮。<br><a id="more"></a></p><h1 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h1><p>语言无关论者<br>数据格式：csv、json、xml、txt<br>数据库：mongodb、sqlalchemy、postges<br>前端：html、css、js、squery</p><p>Beautiful Soup、lxml、XPath、selectors。<br><a href="https://stackoverflow.com/questions/tagged/scrapy" target="_blank" rel="noopener">https://stackoverflow.com/questions/tagged/scrapy</a><br><a href="https://scrapy.org/community/" target="_blank" rel="noopener">https://scrapy.org/community/</a></p><p>最小可行产品(Minimum Viable Product, MVP)<br>初创公司、精益创业</p><h1 id="3、认识Scrapy"><a href="#3、认识Scrapy" class="headerlink" title="3、认识Scrapy"></a>3、认识Scrapy</h1><p>数据清晰、格式化、装饰以及存储到数据库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0、个人曾经的爬虫&quot;&gt;&lt;a href=&quot;#0、个人曾经的爬虫&quot; class=&quot;headerlink&quot; title=&quot;0、个人曾经的爬虫&quot;&gt;&lt;/a&gt;0、个人曾经的爬虫&lt;/h1&gt;&lt;p&gt;Requests库、Beautiful Soup。&lt;br&gt;本科毕业设计：微博爬虫。&lt;/p&gt;
&lt;h1 id=&quot;1、Scrapy&quot;&gt;&lt;a href=&quot;#1、Scrapy&quot; class=&quot;headerlink&quot; title=&quot;1、Scrapy&quot;&gt;&lt;/a&gt;1、Scrapy&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。&lt;br&gt;&amp;emsp;&amp;emsp;Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。&lt;br&gt;&amp;emsp;&amp;emsp;Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。外号小刮刮。&lt;br&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="爬虫" scheme="https://hankin2015.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天乐</title>
    <link href="https://hankin2015.github.io/2018/10/03/20181003GuoQin/"/>
    <id>https://hankin2015.github.io/2018/10/03/20181003GuoQin/</id>
    <published>2018-10-03T02:48:41.000Z</published>
    <updated>2018-10-23T07:24:43.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、英语单词"><a href="#0、英语单词" class="headerlink" title="0、英语单词"></a>0、英语单词</h1><p>Scaler定标器<br>ensemble（合奏）集成<br>perturb-and-combine干扰<br>interval间隔<br>tuning调参<br>estimate估计<br>bag<br>cross交叉</p><a id="more"></a><h1 id="1、学习计划"><a href="#1、学习计划" class="headerlink" title="1、学习计划"></a>1、学习计划</h1><ul><li>制作简历</li><li>数据分析</li><li>特征选择</li><li>归一化</li><li>泰坦尼克号、鸢尾花数据集、</li><li>python爬虫</li><li>GitHub提交</li><li>研究生项目管理和总结</li><li>深度学习</li><li>python刷题</li><li>隐马尔可夫模型（HMM）</li></ul><h1 id="2、ipnb展示"><a href="#2、ipnb展示" class="headerlink" title="2、ipnb展示"></a>2、ipnb展示</h1><p>先cmd到指定文件夹，然后输入jupyter notebook。或者到指定文件夹下，shift+右键打开powershell，输入jupyter notebook。</p><ul><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/模板/数据分析模板%5B泰坦尼克号%5D.ipynb" target="_blank" rel="noopener">数据分析模板</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/LintCode/泰坦尼克号/泰坦尼克号.ipynb" target="_blank" rel="noopener">泰坦尼克号</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/iris%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.ipynb" target="_blank" rel="noopener">鸢尾花数据集</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/Santander%20Customer%20Satisfaction/桑坦德客户满意度.ipynb" target="_blank" rel="noopener">桑坦德客户满意度</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/Santander%20Customer%20Satisfaction/SantanderCustomerSatisfaction数据诊断.ipynb" target="_blank" rel="noopener">慕课网的Santander Customer Satisfaction数据诊断</a></li><li><a href="">IJCAI-18 阿里妈妈搜索广告转化预测</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/航空公司用户价值分析/航空公司客户价值分析.ipynb" target="_blank" rel="noopener">航空公司客户价值分析</a></li><li><a href="">印象盐城·数创未来大数据竞赛 - 乘用车零售量预测</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/简单的文本特征分类/简单的文本特征分类.ipynb" target="_blank" rel="noopener">简单的文本分类（字符串的拆分）</a></li></ul><h1 id="3、文章"><a href="#3、文章" class="headerlink" title="3、文章"></a>3、文章</h1><ul><li><a href="https://hankin2015.github.io/2018/09/29/20180821MyPython/">python使用中解决技巧</a></li><li><a href="https://hankin2015.github.io/2018/09/29/20180929DA-template/">数据分析之模板</a></li><li><a href="https://hankin2015.github.io/2018/09/25/20180925MXNet/">动手学深度学习【个人版】</a></li><li><a href="https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/">数据分析之数据可视化</a></li><li><a href="https://hankin2015.github.io/2018/09/23/20180923/">学习python机器学习2018.9.23</a></li><li><a href="https://hankin2015.github.io/2018/09/23/20180923DA/">python数据分析【个人版】</a></li><li><a href="https://hankin2015.github.io/2013/01/04/20130104ILoveML/">转岗算法工程师日程</a></li><li><a href="https://www.cnblogs.com/tornadomeet/p/3395593.html" target="_blank" rel="noopener">机器学习&amp;数据挖掘笔记_16（常见面试之机器学习算法思想简单梳理）</a></li><li><a href="http://lib.csdn.net/article/python/62942" target="_blank" rel="noopener">Python装饰器的通俗理解</a></li><li><a href="">python中format函数</a></li></ul><p>装饰器就是闭包。</p><h1 id="4、西瓜书"><a href="#4、西瓜书" class="headerlink" title="4、西瓜书"></a>4、西瓜书</h1><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经元、输入层、隐藏层、输出层<br>隐藏层比较多（大于2）的神经网络叫做深度神经网络。而深度学习，就是使用深层架构（比如，深度神经网络）的机器学习方法。<br>为了拟合一个函数，要么使用一个浅而宽的网络，要么使用一个深而窄的网络。而后者往往更节约资源。</p><p>深层网络也有劣势，就是它不太容易训练。简单的说，你需要大量的数据，很多的技巧才能训练好一个深层网络。这是个手艺活。</p><h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><p>神经元也叫做感知器。</p><h2 id="机器学习名字的由来"><a href="#机器学习名字的由来" class="headerlink" title="机器学习名字的由来"></a>机器学习名字的由来</h2><p>阿瑟·萨缪尔研制西洋跳棋程序。</p><p>错误率error rate<br>精度accuracy = 1-错误率<br>误差error<br>训练误差或者经验误差<br>泛化误差：新样本上的误差<br>过拟合overfitting：泛化性能下降<br>欠拟合underfitting<br>分层采样：保留类别比例的而采样方式</p><p>##<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同学您好！非常感谢您参加了华为公司2019届应届生招聘。经过我们慎重的考虑和认真的评估，非常抱歉地通知您未能通过本次面试。我们对您在面试过程中所表现出来的积极努力和认真参与，致以由衷的敬意和真诚的感谢！勇敢新世界，再次感谢您的参与！</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>hr您好！非常感谢您邀请我参加贵公司2019届应届生招聘。经过我慎重的考虑和认真的评估，非常抱歉地通知您未能通过我的筛选。我对您在面试过程中对我的认可，致以由衷的敬意和真诚的感谢！2018，再次感谢认识您！</p><p>Jaccard系数<br>Jaccard index , 又称为Jaccard相似系数（Jaccard similarity coefficient）用于比较有限样本集之间的相似性与差异性。Jaccard系数值越大，样本相似度越高。</p><p>作者：望其向北<br>链接：<a href="https://www.nowcoder.com/discuss/125413?type=0&amp;order=0&amp;pos=21&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/125413?type=0&amp;order=0&amp;pos=21&amp;page=1</a><br>来源：牛客网</p><p>二叉查找树，查找公共父节点<br>TCP，UDP<br>http报文格式，手写<br>bigdecimal大数实现加减运算<br>大学最自豪最印象深刻的事<br>向我提问，意向地(面试官介绍了武汉，南京部门)<br>还有几个问题记不清了，二面加油！😃</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0、英语单词&quot;&gt;&lt;a href=&quot;#0、英语单词&quot; class=&quot;headerlink&quot; title=&quot;0、英语单词&quot;&gt;&lt;/a&gt;0、英语单词&lt;/h1&gt;&lt;p&gt;Scaler定标器&lt;br&gt;ensemble（合奏）集成&lt;br&gt;perturb-and-combine干扰&lt;br&gt;interval间隔&lt;br&gt;tuning调参&lt;br&gt;estimate估计&lt;br&gt;bag&lt;br&gt;cross交叉&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python使用中解决技巧</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180821MyPython/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180821MyPython/</id>
    <published>2018-09-29T11:48:41.000Z</published>
    <updated>2018-10-15T10:03:09.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、格式化输出"><a href="#1、格式化输出" class="headerlink" title="1、格式化输出"></a>1、格式化输出</h1><p><a href="https://www.cnblogs.com/fat39/p/7159881.html" target="_blank" rel="noopener">【Python笔记】1、格式化输出（%用法和format用法）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;%d + %d = %d&apos; % (a, b, c))</span><br></pre></td></tr></table></figure><h1 id="2、Pandas的DataFrame输出截断和省略问题"><a href="#2、Pandas的DataFrame输出截断和省略问题" class="headerlink" title="2、Pandas的DataFrame输出截断和省略问题"></a>2、Pandas的DataFrame输出截断和省略问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.set_option(&apos;display.width&apos;,200)</span><br><span class="line">pd.set_option(&apos;display.max_colwidth&apos;,100)</span><br></pre></td></tr></table></figure><p>同样，我们还可以控制max_row，max_column等参数，使得我们根据实际数据的显示要求进行设置。更多的设置项详见：<br><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.set_option.html" target="_blank" rel="noopener">https://pandas.pydata.org/pandas-docs/stable/generated/pandas.set_option.html</a></p><h1 id="3、jupyter-notebook中美化pandas中DataFrame的输出"><a href="#3、jupyter-notebook中美化pandas中DataFrame的输出" class="headerlink" title="3、jupyter notebook中美化pandas中DataFrame的输出"></a>3、jupyter notebook中美化pandas中DataFrame的输出</h1><p><a href="https://blog.csdn.net/xiaodongxiexie/article/details/71202279" target="_blank" rel="noopener">https://blog.csdn.net/xiaodongxiexie/article/details/71202279</a></p><h1 id="4、Python-Jupyter-Notebook显示行号"><a href="#4、Python-Jupyter-Notebook显示行号" class="headerlink" title="4、Python Jupyter Notebook显示行号"></a>4、Python Jupyter Notebook显示行号</h1><p>Jupyter Notebook默认不显示行号，不方便我们调试排错。操作如下：<br>找到菜单View找到Toggle Line Numbers<br>好了，那我继续调错了……/(ㄒoㄒ)/~~</p><h1 id="5、保留三位小数"><a href="#5、保留三位小数" class="headerlink" title="5、保留三位小数"></a>5、保留三位小数</h1><p>print(round(3.1415926, 3))   # 四舍五入保留3位小数<br>print( format(x*0.4463,’0.1f’))</p><h1 id="6、文件传入参数"><a href="#6、文件传入参数" class="headerlink" title="6、文件传入参数"></a>6、文件传入参数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.argv[<span class="number">0</span>]) <span class="comment"># 当前文件的绝对路径</span></span><br><span class="line"><span class="comment"># print(sys.argv[1]) # 空参数</span></span><br></pre></td></tr></table></figure><h1 id="7、取整操作"><a href="#7、取整操作" class="headerlink" title="7、取整操作"></a>7、取整操作</h1><p><a href="https://www.jb51.net/article/102248.htm" target="_blank" rel="noopener">https://www.jb51.net/article/102248.htm</a><br>双斜杠：53 // 8</p><h1 id="8、输入操作"><a href="#8、输入操作" class="headerlink" title="8、输入操作"></a>8、输入操作</h1><p>学到了：h1, m1, h2, m2 = map(int, input().split())<br>datetime.timedelta似乎<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">s = input().split()</span><br><span class="line"></span><br><span class="line">t1 = datetime.datetime(2018, 10, 2, int(s[0]), int(s[1]))</span><br><span class="line">t2 = datetime.datetime(2018, 10, 2, int(s[2]), int(s[3]))</span><br><span class="line">seconds = (t2 - t1).seconds</span><br><span class="line">print(seconds // 3600, seconds % 3600 // 60)</span><br></pre></td></tr></table></figure></p><h1 id="1、sklearn的train-test-split函数用法"><a href="#1、sklearn的train-test-split函数用法" class="headerlink" title="1、sklearn的train_test_split函数用法"></a>1、sklearn的train_test_split函数用法</h1><p><a href="https://blog.csdn.net/sinat_23338865/article/details/80248599" target="_blank" rel="noopener">https://blog.csdn.net/sinat_23338865/article/details/80248599</a><br>用于将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签。</p><h1 id="2、工欲善其事必先利其器（sublime）"><a href="#2、工欲善其事必先利其器（sublime）" class="headerlink" title="2、工欲善其事必先利其器（sublime）"></a>2、工欲善其事必先利其器（sublime）</h1><p>使用sublime运行python：</p><ul><li>1、添加python环境变量，即可ctrl+B运行python</li><li>2、sublime无法解决输入问题，方法有二：<ul><li>cmd窗口输入设置</li><li>安装sublimeREPL</li></ul></li><li>3、添加快捷键（f5键）</li></ul><p>有时候ctrl+B后会出现控制台，但是关闭有些麻烦，快捷键ctrl+`。</p><h1 id="3、Python-zip-函数"><a href="#3、Python-zip-函数" class="headerlink" title="3、Python zip() 函数"></a>3、Python zip() 函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><h1 id="4、范数"><a href="#4、范数" class="headerlink" title="4、范数"></a>4、范数</h1><p><a href="https://blog.csdn.net/Yaphat/article/details/53304255" target="_blank" rel="noopener">范数&amp;距离</a><br><a href="https://blog.csdn.net/shijing_0214/article/details/51757564" target="_blank" rel="noopener">几种范数的简单介绍</a></p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</p><p>说白了：常用欧式距离，即平方差（方差）就是L2范数。</p><ul><li>L1范数:  ||x|| 为x向量各个元素绝对值之和。 </li><li>L2范数:  ||x||为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或者Frobenius范数 </li><li>Lp范数:  ||x||为x向量各个元素绝对值p次方和的1/p次方 </li><li>L∞范数:  ||x||为x向量各个元素绝对值最大那个元素的绝对值</li></ul><h1 id="5、支持度、置信度、提升度"><a href="#5、支持度、置信度、提升度" class="headerlink" title="5、支持度、置信度、提升度"></a>5、支持度、置信度、提升度</h1><p><a href="https://www.jianshu.com/p/dc053deb94f2" target="_blank" rel="noopener">数据挖掘关联分析中的支持度、置信度和提升度</a></p><ul><li>联系：关联规则或频繁项集</li><li>关联分析：两个变量之间A、B</li><li>项在事务中出现比不出现更重要，因此项是非对称的的二元变量。</li><li>事务的宽度：事务中出现的项的个数</li><li>A对B的置信度：做了A事务的人有多少概率也会做B事务。</li><li>为啥有提升度：查看A、B是否联系-相关、排斥、无关</li><li>提升度受零事务影响大</li><li>KULC度量+不平衡比（IR） 。它们可以有效的降低零事务造成的影响。</li><li>KULC = 两个置信度的均值</li><li>IR = 两个置信度的比值</li><li>置信度就是贝叶斯公式啊</li></ul><p>Support（支持度）：表示同时包含A和B的事务占所有事务的比例。如果用P(A)表示使用A事务的比例，那么Support=P(A&amp;B)</p><p>Confidence（置信度）：表示使用包含A的事务中同时包含B事务的比例，即同时包含A和B的事务占包含A事务的比例。公式表达：Confidence=P(A&amp;B)/P(A)=P(B|A)</p><p>Lift（提升度）：表示“包含A的事务中同时包含B事务的比例”与“包含B事务的比例”的比值。公式表达：Lift=( P(A&amp;B)/P(A))/P(B)=P(A&amp;B)/P(A)/P(B)。</p><p>提升度反映了关联规则中的A与B的相关性，提升度&gt;1且越高表明正相关性越高，提升度&lt;1且越低表明负相关性越高，提升度=1表明没有相关性。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h2 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h2><p>获得一个区间，例如，对这个问题的一个可能的答案是：「我 95％ 相信在美国足球爱好者的比例是 58％ 至 62％」。这就是置信区间名字的来源，我们有一个区间，并且我们对它此一定的信心。</p><h1 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h1><p>贝叶斯定理由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。按照乘法法则，可以立刻导出：P(A∩B) = P(A)<em>P(B|A)=P(B)</em>P(A|B)。如上公式也可变形为：P(B|A) = P(A|B)*P(B) / P(A)。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ul><li>pd.set_option(‘display.max_columns’, None)   强制显示所有属性值</li><li>label = df[‘TARGET’]    dataframe对大小写非常敏感，写成TARGeT就会报错</li><li>axis = 1是对列进行操作</li><li>drop函数删除相应的行和列</li><li>iloc表示下标访问，loc是条件访问<br>df.loc[df[‘a’]&gt;3, ‘a’] = df[‘a’] / 3<br>print(df)</li><li>apply函数和lambda函数常常一起使用</li><li>reset_index()重构索引，重构索引后会自动增加一列index(原始)，需要删除</li></ul><p># </p><h1 id="6、数据诊断"><a href="#6、数据诊断" class="headerlink" title="6、数据诊断"></a>6、数据诊断</h1><p>数量（样本）、值数量（范围）、是否有零值、数据类型、mean平均数值、median中位数、mode众数、mode_percent众数比例</p><p>零值、异常值</p><p>了解特征的分布、缺失和异常的情况。<br>缺失值填充：-1、0、1、中位数、众数、平均值</p><p>numpy:数组、列表<br>pandas:把数据读成dataframe形式，读写<br>scipy:计算，函数，众数等计算</p><p>导入division确保一个数除以另外一个数不等于0，返回值是一个浮点型的数<br>导入pd，np，scipy中的stats函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">依赖包的导入</span><br><span class="line"># coding:utf-8</span><br><span class="line">from __future__ import division</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy import stats</span><br></pre></td></tr></table></figure><p>统计指标介绍：</p><ul><li>均值/中位数/最大值/最小值等</li><li>计数类：多少0值，多少1值，多少缺失值…..</li><li>缺失值/方差等：当某个特征的方差为0，则这个特征无效基本相同；缺失值过多可删除</li><li>分位点/值的频数等：</li></ul><p>##1.Basic Analysis##</p><p>#(1)Missing Value#<br>missSet = [np.nan, 9999999999, -999999]</p><p>#(2)Count distinct#<br>len(df.iloc[:, 0].unique())<br>count_un = df.iloc[:,0:3].apply(lambda x:len(x.unique()))</p><p>#(3)Zero Values#<br>np.sum(df.iloc[:0] == 0)<br>count_zero = df.iloc[:, 0:3].apply(lambda x:np.sum(x == 0))</p><h1 id="describe-函数"><a href="#describe-函数" class="headerlink" title="describe()函数"></a>describe()函数</h1><p><a href="https://blog.csdn.net/g_66_hero/article/details/72899377" target="_blank" rel="noopener">https://blog.csdn.net/g_66_hero/article/details/72899377</a><br>生成描述性统计，总结数据集分布的中心趋势，分散和形状，不包括NaN值。<br>对于数值数据，结果的索引将包括计数，平均值，标准差，最小值，最大值以及较低的百分位数和50。默认情况下，较低的百分位数为25，较高的百分位数为75.50百分位数与中位数相同。</p><p>对于对象数据（例如字符串或时间戳），结果的索引将包括count，unique，top和freq。顶部是最常见的价值。频率是最常见的频率。时间戳还包括第一个和最后一个项目。</p><p>可以使用include和exclude参数来限制DataFrame中哪些列被分析输出。分析系列时，参数将被忽略。</p><p>describe()函数自动计算的字段有count（非空值数）、unique（唯一值数）、top（频数最高者）、freq（最高频数）、mean（平均值）、std（方差）、min（最小值）、50%（中位数）、max（最大值</p><h1 id="Series和Dataframe的区别"><a href="#Series和Dataframe的区别" class="headerlink" title="Series和Dataframe的区别"></a>Series和Dataframe的区别</h1><p><a href="https://geektutu.com/post/pandas-dataframe-series.html" target="_blank" rel="noopener">https://geektutu.com/post/pandas-dataframe-series.html</a><br>DataFrame和Series是pandas中最常见的2种数据结构。DataFrame可以理解为Excel中的一张表，Series可以理解为一张Excel表的一行或一列数据。<br>Series可以理解为一维数组numpy.array，它和一维数组的区别，在于Series具有索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1=pd.Series([1,2,4,6,7,2])</span><br><span class="line">s2=pd.Series([4,3,1,57,8],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br></pre></td></tr></table></figure></p><p>定长的字典。<br>DataFrame相当于表格，有行表头和列表头。<br>series可以看做一个一维的字典，而dataframe可以看作是一个多维的字典。</p><h1 id="astype、dtype"><a href="#astype、dtype" class="headerlink" title="astype、dtype"></a>astype、dtype</h1><ul><li>ndim返回的是数组的维度，返回的只有一个数，该数即表示数组的维度。</li><li>shape：表示各位维度大小的元组。返回的是一个元组。</li><li>dtype：一个用于说明数组数据类型的对象。返回的是该数组的数据类型。由于图中的数据都为整型，所以返回的都是int32。如果数组中有数据带有小数点，那么就会返回float64。</li><li>astype：转换数组的数据类型。</li></ul><h1 id="factorize-函数"><a href="#factorize-函数" class="headerlink" title="factorize()函数"></a>factorize()函数</h1><p>factorize函数可以将Series中的标称型数据映射称为一组数字，相同的标称型映射为相同的数字。<br>factorize函数的返回值是一个tuple（元组），元组中包含两个元素。<br>第一个元素是一个array，其中的元素是标称型元素映射为的数字(从0开始)；<br>第二个元素是Index类型，其中的元素是所有标称型元素，没有重复。</p><h1 id="标称型数据和数值型数据"><a href="#标称型数据和数值型数据" class="headerlink" title="标称型数据和数值型数据"></a>标称型数据和数值型数据</h1><p>在学习机器学习的工程中，发现有一种名为标称型的数据，具体如下：</p><p>标称型：一般在有限的数据中取，而且只存在‘是’和‘否’两种不同的结果（一般用于分类）</p><p>数值型：可以在无限的数据中取，而且数值比较具体化，例如4.02,6.23这种值（一般用于回归分析）</p><h1 id="判断两个数是否相等用异或运算啊"><a href="#判断两个数是否相等用异或运算啊" class="headerlink" title="判断两个数是否相等用异或运算啊"></a>判断两个数是否相等用异或运算啊</h1><h1 id="判断一个数是否为奇数-amp-1"><a href="#判断一个数是否为奇数-amp-1" class="headerlink" title="判断一个数是否为奇数&amp;1"></a>判断一个数是否为奇数&amp;1</h1><h1 id="一个数乘以或者除以2则左移右移"><a href="#一个数乘以或者除以2则左移右移" class="headerlink" title="一个数乘以或者除以2则左移右移"></a>一个数乘以或者除以2则左移右移</h1><h1 id="future模块"><a href="#future模块" class="headerlink" title="future模块"></a><strong>future</strong>模块</h1><p>从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用’xxx’表示str，Unicode字符串用u’xxx’表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u’xxx’和’xxx’是完全一致的，而在2.x中以’xxx’表示的str就必须写成b’xxx’，以此表示“二进制字符串”。</p><p>要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。</p><p>Python提供了<strong>future</strong>模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。</p><h1 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h1><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。 在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类相比较计算的。</p><h1 id="范数-1"><a href="#范数-1" class="headerlink" title="范数"></a>范数</h1><p>范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。</p><h1 id="凡是出现-1-IND00-基本可以肯定是发生了除0错误。"><a href="#凡是出现-1-IND00-基本可以肯定是发生了除0错误。" class="headerlink" title="凡是出现-1.#IND00.基本可以肯定是发生了除0错误。"></a>凡是出现-1.#IND00.基本可以肯定是发生了除0错误。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、格式化输出&quot;&gt;&lt;a href=&quot;#1、格式化输出&quot; class=&quot;headerlink&quot; title=&quot;1、格式化输出&quot;&gt;&lt;/a&gt;1、格式化输出&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fat39/p/7159881.h
      
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>手记</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929Note/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929Note/</id>
    <published>2018-09-29T11:47:41.000Z</published>
    <updated>2018-10-03T02:58:13.417Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之模板</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929DA-template/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929DA-template/</id>
    <published>2018-09-29T11:43:41.000Z</published>
    <updated>2018-10-21T12:37:11.862Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.kesci.com/home/project/5b3b3ed771a61726e13833e3" target="_blank" rel="noopener">数据分析（业务向）技能总结</a></p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  # 数学</span><br><span class="line">import pandas as pd</span><br><span class="line">from sklearn import datasets  #用数据库去学习，或者把数据库放到tenserflow模块练习</span><br><span class="line">from sklearn.model_selection import train_test_split # 数据集测试集分离</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier   # 会选择邻近几个点作为他的邻居，综合临近几个点模拟出数据的预测值</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import warnings </span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line">import seaborn as sns</span><br><span class="line">import os</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>&lt;–!more–&gt;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, we'll import pandas, a data processing and CSV file I/O library</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># We'll also import seaborn, a Python graphing library</span></span><br><span class="line"><span class="keyword">import</span> warnings <span class="comment"># current version of seaborn generates a bunch of warnings that we'll ignore</span></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sns.set(style=<span class="string">"white"</span>, color_codes=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Next, we'll load the Iris flower dataset, which is in the "../input/" directory</span></span><br><span class="line">iris = pd.read_csv(<span class="string">"../input/Iris.csv"</span>) <span class="comment"># the iris dataset is now a Pandas DataFrame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's see what's in the iris data - Jupyter notebooks print the result of the last thing you do</span></span><br><span class="line">iris.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Press shift+enter to execute this cell</span></span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/chennai1101/article/details/59483438/" target="_blank" rel="noopener">Python 打印语句</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.kesci.com/home/project/5b3b3ed771a61726e13833e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据分析（业务向）技能总结&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;头文件&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之数据可视化</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/</id>
    <published>2018-09-29T05:47:41.000Z</published>
    <updated>2018-10-03T02:50:21.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、数据集的来源"><a href="#1、数据集的来源" class="headerlink" title="1、数据集的来源"></a>1、数据集的来源</h1><ul><li><a href="https://blog.csdn.net/brucewong0516/article/details/79011562" target="_blank" rel="noopener">numpy之random库简单的随机数据生成</a></li><li><a href="https://blog.csdn.net/tmb8z9vdm66wh68vx1/article/details/79212888" target="_blank" rel="noopener">教你在Python中用Scikit生成测试数据集</a><a id="more"></a></li><li>1、np.random.rand(d0, d1, …, dn)<br>np.random.rand(3,2) #生成3行2列的随机数组<br>np.random.rand(3,2,2) #生产3维的随机数组</li><li>2、randn(d0, d1, …, dn)返回一个样本，具有标准正态分布。</li><li>3、randint(low[, high, size])<ul><li>返回随机整数，范围区间为[low,high），包含low，不包含high</li><li>参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int</li><li>high没有填写时，默认生成随机数的范围是[0，low)</li></ul></li><li>4、np.random.random([size])生成[0,1)之间的浮点数,与np.random.rand()功能类似</li><li>5、numpy.random.choice(a[, size, replace, p])生成一个随机样本，从一个给定的一维数组a中随机选取</li><li>6、numpy.random.seed()生成随机数的种子，使得每次生成随机数相同</li></ul><p><strong>注意</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(2) # 种子和随机函数放在一起运行才能使随机数不变</span><br><span class="line">np.random.rand(3)</span><br></pre></td></tr></table></figure></p><h1 id="2、画散点图看分布"><a href="#2、画散点图看分布" class="headerlink" title="2、画散点图看分布"></a>2、画散点图看分布</h1><h1 id="3、资料满满"><a href="#3、资料满满" class="headerlink" title="3、资料满满"></a>3、资料满满</h1><p><a href="https://blog.csdn.net/suzyu12345/article/details/69029106" target="_blank" rel="noopener">python seaborn画图</a><br><a href="https://www.cnblogs.com/gczr/p/6767175.html" target="_blank" rel="noopener">Python数据可视化-seaborn</a></p><p><a href="https://www.kaggle.com/benhamner/python-data-visualizations/notebook" target="_blank" rel="noopener">Python data visualizations on the Iris dataset</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、数据集的来源&quot;&gt;&lt;a href=&quot;#1、数据集的来源&quot; class=&quot;headerlink&quot; title=&quot;1、数据集的来源&quot;&gt;&lt;/a&gt;1、数据集的来源&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/brucewong0516/article/details/79011562&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numpy之random库简单的随机数据生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/tmb8z9vdm66wh68vx1/article/details/79212888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教你在Python中用Scikit生成测试数据集&lt;/a&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习[个人版]</title>
    <link href="https://hankin2015.github.io/2018/09/25/20180925MXNet/"/>
    <id>https://hankin2015.github.io/2018/09/25/20180925MXNet/</id>
    <published>2018-09-25T02:47:41.000Z</published>
    <updated>2018-10-23T02:38:06.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、学习深度须知"><a href="#1、学习深度须知" class="headerlink" title="1、学习深度须知"></a>1、学习深度须知</h1><h2 id="DL"><a href="#DL" class="headerlink" title="DL???"></a>DL???</h2><ul><li>纸上得来终觉浅，绝知此事要躬行。</li><li>通俗来说，机器学习是一门讨论各式各样适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。</li><li>裁剪平均值的雏形：去掉最高分和最低分。</li><li>绝大多数神经网络的核心原则：<ul><li>交替使用线性与非线性处理单元，经常被称为“层”。</li><li>使用链式法则（即反向传播）来更新网络的参数。<a id="more"></a></li></ul></li></ul><h2 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet???"></a>MXNet???</h2><ul><li>MXNet 是一个开源的<strong>深度学习框架</strong>。它是 AWS（亚马逊云计算服务）首选的深度学习框架，并且也许是最优秀的库【百度百科评价】。</li><li>对 Python 的支持只是其冰山一角—MXNet 同样提供了对 R、Julia、C++、Scala、Matlab，和 Javascript 的接口。</li><li>MXNet 的ndarray、autograd、gluon等模块的基础功能，所以gluon仅仅是一个模块，而不是框架。</li></ul><h2 id="GPU【图像处理器】和CPU【中央处理器】的区别"><a href="#GPU【图像处理器】和CPU【中央处理器】的区别" class="headerlink" title="GPU【图像处理器】和CPU【中央处理器】的区别"></a>GPU【图像处理器】和CPU【中央处理器】的区别</h2><ul><li>CPU擅长逻辑控制和通用类型数据运算</li><li>GPU擅长的是大规模并发计算</li></ul><p>深度学习训练通常需要大量的计算资源。GPU 目前是深度学习最常使用的计算加速硬件。相对于 CPU 来说，GPU 更便宜且计算更加密集。一方面，相同计算能力的 GPU 的价格一般是 CPU 价格的十分之一。另一方面，一台服务器通常可以搭载 8 块或者 16 块 GPU。因此，GPU 数量可以看作是衡量一台服务器的深度学习计算能力的一个标准。</p><p>目前独立 GPU 主要有 AMD 和 Nvidia 两家厂商。其中 Nvidia 在深度学习布局较早，对深度学习框架支持更好。因此，目前大家主要会选择 Nvidia 的 GPU。</p><h1 id="2、数据操作"><a href="#2、数据操作" class="headerlink" title="2、数据操作"></a>2、数据操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://zh.gluon.ai/chapter_prerequisite/install.html" target="_blank" rel="noopener">获取代码并安装运行环境</a><br>conda config –prepend channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>下载存储地址：’D:\Program Files\Anaconda\envs\gluon’</p><p>小问题：我使用anaconda安装的，首先关于python和Linux的安装都需要先升级工具为最新版本。然而gluon模块安装完成后会有jupyter notebook版本，点击后闪退无果。<br>正确的打开方式：打开cmd=》激活gluon（activate gluon）=》jupyter notebook</p><p>还可以直接安装pip install mxnet.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>NDArray 和 NumPy 的多维数组非常类似。然而，NDArray 提供 GPU 计算和自动求梯度等更多功能，这些使得 NDArray 更加适合深度学习。</p><p><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/MXNet1.ipynb" target="_blank" rel="noopener">mxnet的简单使用</a></p><h1 id="3、深度学习基础"><a href="#3、深度学习基础" class="headerlink" title="3、深度学习基础"></a>3、深度学习基础</h1><p>单层神经网络：线性回归和 Softmax 回归。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>权重weight、偏差bias、参数parameter。<br>预测（估计）</p><h3 id="模型训练三要素"><a href="#模型训练三要素" class="headerlink" title="模型训练三要素"></a>模型训练三要素</h3><p>训练数据：特征feature、标签label、样本sample、训练集<br>损失函数：平方误差函数也称平方损失（记得要乘以1/2，其中常数 1/2 使得对平方项求导后的常数系数为 1），然后求和后再取平均值。<br>优化算法：在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。</p><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫做解析解（analytical solution）。<br>只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫做数值解（numerical solution）。</p><p>批量大小和学习率的值是人为设定的，并不是通过模型训练学出的，因此叫做超参数（hyperparameter）。我们通常所说的“调参”指的正是调节超参数，例如通过反复试错来找到合适的超参数。少数情况下，超参数也可以通过模型训练学出。</p><p>这个网站主要还是讲的是深度学习，还是先入门机器学习为好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、学习深度须知&quot;&gt;&lt;a href=&quot;#1、学习深度须知&quot; class=&quot;headerlink&quot; title=&quot;1、学习深度须知&quot;&gt;&lt;/a&gt;1、学习深度须知&lt;/h1&gt;&lt;h2 id=&quot;DL&quot;&gt;&lt;a href=&quot;#DL&quot; class=&quot;headerlink&quot; title=&quot;DL???&quot;&gt;&lt;/a&gt;DL???&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/li&gt;
&lt;li&gt;通俗来说，机器学习是一门讨论各式各样适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。&lt;/li&gt;
&lt;li&gt;裁剪平均值的雏形：去掉最高分和最低分。&lt;/li&gt;
&lt;li&gt;绝大多数神经网络的核心原则：&lt;ul&gt;
&lt;li&gt;交替使用线性与非线性处理单元，经常被称为“层”。&lt;/li&gt;
&lt;li&gt;使用链式法则（即反向传播）来更新网络的参数。
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
  <entry>
    <title>python数据分析【个人版】</title>
    <link href="https://hankin2015.github.io/2018/09/23/20180923DA/"/>
    <id>https://hankin2015.github.io/2018/09/23/20180923DA/</id>
    <published>2018-09-23T13:47:41.000Z</published>
    <updated>2018-10-03T02:51:17.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、枚举指定文件夹中的所有指定格式文件并访问"><a href="#1、枚举指定文件夹中的所有指定格式文件并访问" class="headerlink" title="1、枚举指定文件夹中的所有指定格式文件并访问"></a>1、枚举指定文件夹中的所有指定格式文件并访问</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dirPath = <span class="string">'./'</span>   <span class="comment"># 文件夹路径 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListFile</span><span class="params">(fileDir)</span>:</span>   </span><br><span class="line">    ret = []   </span><br><span class="line"><span class="comment"># os.walk()函数返回根目录、</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(fileDir):  </span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:  </span><br><span class="line"><span class="comment">#其中os.path.splitext()函数将路径拆分为文件名+扩展名</span></span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(file)[<span class="number">1</span>] == <span class="string">'.txt'</span>:</span><br><span class="line">                ret.append(os.path.join(root, file))  </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">files = ListFile(dataPath)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    data = pd.read_table(file)</span><br><span class="line">    ret = data[data[<span class="string">'communities'</span>] == <span class="string">'at question'</span>]</span><br><span class="line">    <span class="keyword">if</span> (ret.shape[<span class="number">0</span>] != <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">'有异常数据的文件：'</span> + file)</span><br><span class="line">        print(ret)</span><br></pre></td></tr></table></figure><h1 id="2、对series和dataframe进行排序"><a href="#2、对series和dataframe进行排序" class="headerlink" title="2、对series和dataframe进行排序"></a>2、对series和dataframe进行排序</h1><ul><li>sort函数好像被淘汰，改为sort_values函数。</li><li>排序不是在源dataframe里进行，而是生成新的dataframe。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">df = df.sort_values(by=<span class="string">'internalReturn'</span>, ascending=<span class="keyword">False</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">frame.sort(columns = [<span class="string">'a'</span>],axis = <span class="number">0</span>,ascending = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#以下实现排序功能。</span></span><br><span class="line">series=pd.Series([<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>],index=[<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>])</span><br><span class="line">frame=pd.DataFrame([[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]],columns=[<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>],index=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>])</span><br><span class="line"><span class="keyword">print</span> frame</span><br><span class="line"><span class="keyword">print</span> series</span><br><span class="line"><span class="keyword">print</span> <span class="string">'series通过索引进行排序：'</span></span><br><span class="line"><span class="keyword">print</span> series.sort_index()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'series通过值进行排序:'</span></span><br><span class="line"><span class="keyword">print</span> series.sort_values()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'dataframe根据行索引进行降序排序（排序时默认升序，调节ascending参数）：'</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(ascending=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'dataframe根据列索引进行排序：'</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'dataframe根据值进行排序：'</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_values(by=<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'通过多个索引进行排序：'</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def use_svg_display():</span><br><span class="line">    # 用矢量图显示。</span><br><span class="line">    display.set_matplotlib_formats(&apos;svg&apos;)</span><br><span class="line"></span><br><span class="line">def set_figsize(figsize=(3.5, 2.5)):</span><br><span class="line">    use_svg_display()</span><br><span class="line">    # 设置图的尺寸。</span><br><span class="line">    plt.rcParams[&apos;figure.figsize&apos;] = figsize</span><br><span class="line"></span><br><span class="line">set_figsize()</span><br><span class="line">plt.scatter(features[:, 1].asnumpy(), labels.asnumpy(), 1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、枚举指定文件夹中的所有指定格式文件并访问&quot;&gt;&lt;a href=&quot;#1、枚举指定文件夹中的所有指定格式文件并访问&quot; class=&quot;headerlink&quot; title=&quot;1、枚举指定文件夹中的所有指定格式文件并访问&quot;&gt;&lt;/a&gt;1、枚举指定文件夹中的所有指定格式文件并
      
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="数据分析" scheme="https://hankin2015.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>学习python机器学习2018.9.23</title>
    <link href="https://hankin2015.github.io/2018/09/23/20180923/"/>
    <id>https://hankin2015.github.io/2018/09/23/20180923/</id>
    <published>2018-09-23T09:47:41.000Z</published>
    <updated>2018-10-29T14:17:24.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、学习资料"><a href="#0、学习资料" class="headerlink" title="0、学习资料"></a>0、学习资料</h1><p><a href="https://tianchi.aliyun.com/learn/index.htm?spm=5176.100066.5610778.9.4aa233afpZU3PP" target="_blank" rel="noopener">(天池)机器学习快速入门</a></p><p><a href="https://www.kaggle.com/" target="_blank" rel="noopener">kaggle</a><br><a href="">动手学习深度学习</a><br><a href="https://www.lintcode.com/ai/" target="_blank" rel="noopener">LintCode</a></p><p><a href="https://www.cnblogs.com/fengziwei/p/7750849.html" target="_blank" rel="noopener">背包问题：0-1背包、完全背包和多重背包</a></p><h1 id="1、PyPI"><a href="#1、PyPI" class="headerlink" title="1、PyPI"></a>1、PyPI</h1><p>PyPI（Python Package Index）是 Python 官方的第三方库的仓库，所有人都可以下载第三方库或上传自己开发的库到 PyPI。PyPI 推荐使用 pip 包管理器来下载第三方库。<br><a href="https://docs.python.org/3/library/" target="_blank" rel="noopener">https://docs.python.org/3/library/</a><br><a href="https://pypi.org/search/" target="_blank" rel="noopener">https://pypi.org/search/</a></p><h1 id="2、在GitHub上使用ipynb"><a href="#2、在GitHub上使用ipynb" class="headerlink" title="2、在GitHub上使用ipynb"></a>2、在GitHub上使用ipynb</h1><p>GitHub能直接看，但有时候可能加载慢或加载不出来，所以使用第三方工具。<br>网站：<a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">https://nbviewer.jupyter.org/</a><br>分享：<a href="http://nbviewer.ipython.org/github/" target="_blank" rel="noopener">http://nbviewer.ipython.org/github/</a><url></url></p><h1 id="3、机器学习算法"><a href="#3、机器学习算法" class="headerlink" title="3、机器学习算法"></a>3、机器学习算法</h1><p>机器学习最大的特点是利用数据而不是指令来进行各种工作，其学习过程主要包括：数据的特征提取、数据预处理、训练模型、测试模型、模型评估改进等几部分。</p><p>机器学习算法可以分为传统的机器学习算法和深度学习。传统机器学习算法主要包括以下五类：</p><p>回归：建立一个回归方程来预测目标值，用于连续型分布预测</p><p>分类：给定大量带标签的数据，计算出未知标签样本的标签取值</p><p>聚类：将不带标签的数据根据距离聚集成不同的簇，每一簇数据有共同的特征</p><p>关联分析：计算出数据之间的频繁项集合</p><p>降维：原高维空间中的数据点映射到低维度的空间中</p><p>人工神经网络<br>深度学习</p><h1 id="4、最小二乘法"><a href="#4、最小二乘法" class="headerlink" title="4、最小二乘法"></a>4、最小二乘法</h1><h1 id="5、常见的机器学习算法"><a href="#5、常见的机器学习算法" class="headerlink" title="5、常见的机器学习算法"></a>5、常见的机器学习算法</h1><h3 id="（1）线性回归：找到一条直线来预测目标值"><a href="#（1）线性回归：找到一条直线来预测目标值" class="headerlink" title="（1）线性回归：找到一条直线来预测目标值"></a>（1）线性回归：找到一条直线来预测目标值</h3><p>回归是指确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，通过建立一个回归方程（函数）来估计特征值对应的目标变量的可能取值。</p><h3 id="（2）逻辑回归：找到一条直线来分类数据"><a href="#（2）逻辑回归：找到一条直线来分类数据" class="headerlink" title="（2）逻辑回归：找到一条直线来分类数据"></a>（2）逻辑回归：找到一条直线来分类数据</h3><p>逻辑回归虽然名字叫回归，却是属于分类算法，是通过Sigmoid函数将线性函数的结果映射到Sigmoid函数中，预估事件出现的概率并分类。Sigmoid是归一化的函数，可以把连续数值转化为0到1的范围，提供了一种将连续型的数据离散化为离散型数据的方法。</p><p>因此，逻辑回归从直观上来说是画出了一条分类线。位于分类线一侧的数据，概率&gt;0.5,属于分类A；位于分类线另一侧的数据，概率&lt;0.5,属于分类B。</p><h3 id="（3）K-近邻：用距离度量最相邻的分类标签"><a href="#（3）K-近邻：用距离度量最相邻的分类标签" class="headerlink" title="（3）K-近邻：用距离度量最相邻的分类标签"></a>（3）K-近邻：用距离度量最相邻的分类标签</h3><h3 id="（4）朴素贝叶斯：选择后验概率最大的类为分类标签"><a href="#（4）朴素贝叶斯：选择后验概率最大的类为分类标签" class="headerlink" title="（4）朴素贝叶斯：选择后验概率最大的类为分类标签"></a>（4）朴素贝叶斯：选择后验概率最大的类为分类标签</h3><h1 id="L1范数和L2范数的区别"><a href="#L1范数和L2范数的区别" class="headerlink" title="L1范数和L2范数的区别"></a><a href="https://blog.csdn.net/pan060757/article/details/73321681" target="_blank" rel="noopener">L1范数和L2范数的区别</a></h1><p>L1正则化和L2正则化，或者L1范数和L2范数。可以看做是损失函数的惩罚项。对于线性回归模型，使用L1正则化的模型建叫做Lasso回归，使用L2正则化的模型叫做Ridge回归（岭回归）。</p><p>L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，因此可以用于特征选择。<br>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合。</p><h1 id="OneHotEncoder独热编码和-LabelEncoder标签编码"><a href="#OneHotEncoder独热编码和-LabelEncoder标签编码" class="headerlink" title="OneHotEncoder独热编码和 LabelEncoder标签编码"></a><a href="https://www.cnblogs.com/king-lps/p/7846414.html" target="_blank" rel="noopener">OneHotEncoder独热编码和 LabelEncoder标签编码</a></h1><p>OneHotEncoder：给特征的每个取值分配一个bit位。<br>LabelEncoder：给特征的每个取值分配下标从0开始，然后转换为相应的连续下标。</p><p>pd.set_option(‘display.max_columns’, None)    # 强制显示所有属性值<br>pd.to_datetime(data[‘FFP_DATE’])<br>d_ffp = pd.to_datetime(data[‘FFP_DATE’])<br>d_load = pd.to_datetime(data[‘LOAD_TIME’])<br>res = d_load - d_ffp  # 相减得天数<br>res.head()</p><p>np.map<br>np.filter</p><p>离散系数<br>离散系数又称变异系数，是统计学当中的常用统计指标。离散系数是测度数据离散程度的相对统计 量，主要是用于比较不同样本数据的离散程度。离散系数大，说明数据的离散程度也大；离散系数小，说明数据的离散程度也小。</p><p>离散系数是衡量资料中各观测值离散程度的一个统计量。当进行两个或多个资料离散程度的比较时，如果度量单位与平均数相同，可以直接利用标准差来比较。如果单位和（或）平均数不同时，比较其离散程度就不能采用标准差，而需采用标准差与平均数的比值（相对值）来比较。</p><p>标准分数<br>也叫z分数，是一种具有相等单位的量数。它是将原始分数与团体的平均数之差除以标准差所得的商数，是以标准差为单位度量原始分数离开其平均数的分数之上多少个标准差，或是在平均数之下多少个标准差。它是一个抽象值，不受原始测量单位的影响，并可接受进一步的统计处理。</p><p>标准分数是一种不受原始测量单位影响的数值。其作用除了能够表明原数据在其分布中的位置外，还能对未来不能直接比较的各种不同单位的数据进行比较。如比较各个学生的成绩在班级成绩中的位置或比较某个学生在两种或多种测验中所得分数的优劣。</p><p>主办方将对B榜获奖团队进行代码审核，代码需具有通用性和普适性，一旦发现作弊行为，即刻取消参赛及获奖资格。</p><p>a = [‘1’, ‘2’, ‘3’]<br>b = [‘4’, ‘5’]<br>c = a + b<br>c<br>列表相加是直接弄在一起</p><p>还有这种删除<br>del data[‘click’]</p><p>必须自己新建文件夹</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、学习资料&quot;&gt;&lt;a href=&quot;#0、学习资料&quot; class=&quot;headerlink&quot; title=&quot;0、学习资料&quot;&gt;&lt;/a&gt;0、学习资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://tianchi.aliyun.com/learn/index.htm?sp
      
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Weiszfeld 算法求中位中心</title>
    <link href="https://hankin2015.github.io/2018/09/22/20180922Weiszfeld/"/>
    <id>https://hankin2015.github.io/2018/09/22/20180922Weiszfeld/</id>
    <published>2018-09-22T02:47:41.000Z</published>
    <updated>2018-10-12T09:06:08.470Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/qianlinjun/article/details/53852306" target="_blank" rel="noopener">https://blog.csdn.net/qianlinjun/article/details/53852306</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定坐标系中有n个整数点的坐标，求一个中位整点到所有n点的距离和最小，输出最小距离。</p><p>1、求算术平均数中心（一开始以为这就是结果值）<br>2、根据公式进行迭代<br>3、通过自定义迭代优化的限值来让迭代停止。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定n个整数点的坐标，求一个中位整点到所有n点的距离和最小，输出最小距离。</span></span><br><span class="line"><span class="comment">n&lt;=10^5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：所有n点的x,y求平均值（错误）</span></span><br><span class="line"><span class="comment">正确的做法：Weiszfeld算法求中位中心</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n, x[maxn], y[maxn];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    LL sumX = <span class="number">0</span>, sumY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        sumX += x[i];</span><br><span class="line">        sumY += y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> X = sumX / n, Y = sumY / n;</span><br><span class="line">    <span class="keyword">int</span> preX = X, preY = Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>((x[i] - X) * (x[i] - X) + (y[i] - Y) * (y[i] - Y));</span><br><span class="line">            sum1 += x[i] / dis;</span><br><span class="line">            sum2 += y[i] / dis;</span><br><span class="line">            sum3 += <span class="number">1</span> / dis;</span><br><span class="line">        &#125;</span><br><span class="line">        preX = X, preY = Y;</span><br><span class="line">        X = sum1 / sum3;</span><br><span class="line">        Y = sum2 / sum3;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(X - preX) &gt; <span class="number">2</span> || <span class="built_in">abs</span>(Y - preY) &gt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>((x[i] - preX) * (x[i] - preX) + (y[i] - preY) * (y[i] - preY));</span><br><span class="line">        ans += dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例1:</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">样例2:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例1:</span></span><br><span class="line"><span class="comment">2.8284</span></span><br><span class="line"><span class="comment">样例2:</span></span><br><span class="line"><span class="comment">9.6410</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">爸爸当上领导后，从来不敢多说话，生怕给别人带来压力。上个月，爸爸的下属小李叔叔到我家来玩，爸爸随口说了句：“家里没空调，比较热，见笑了。”   </span><br><span class="line">第二天，小李叔叔带师傅给我家安装了5匹的大空调！怎么也不肯收钱。</span><br><span class="line">上个星期，爸爸看到老张伯伯在办公室吃午饭，其中有煎的鱼，随口说了句：“哎呦，真香！”！</span><br><span class="line">当天晚上。老张伯伯给我家送了一箱鲜鱼来。</span><br><span class="line">有天晚上在路上，碰到单位的小王叔叔和他老婆逛街，爸爸随口称赞道：“哎呦，小王，你媳妇真漂亮！”</span><br><span class="line">第二天晚上，妈妈不在家，突然听到有人敲门，打开门一看，小王叔叔的媳妇站在门口，见到爸爸就满脸的微笑说：“领导，我们家小王说嫂子不在家，让我来陪陪你！”</span><br><span class="line">当领导真好，我长大以后也要像爸爸一样当领导。</span><br><span class="line">当领导真好，怪不得那么多人喜欢当领导！ 儿子对他当局长的爸爸说：“我很喜欢楼下周副局长家的女儿！”</span><br><span class="line">局长偷偷说：“不行，那是你同父异母的妹妹！”</span><br><span class="line">儿子又说：“那我也喜欢隔壁王科长家的女儿！”</span><br><span class="line">局长又说：“那也不行，亦是你同父异母的妹妹，千万别对你妈说。”</span><br><span class="line">儿子只好偷偷跟妈妈说了。妈妈安慰儿子：“你喜欢谁就娶谁，别理他，市委黄书记才是你亲爹！</span><br><span class="line">天黑路滑，社会太复杂。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不是一家人，不入一个坑。大水淹了龙王庙，自家人掉自家坑。</span><br><span class="line">内行看门道，外行看热闹。</span><br><span class="line">飞鱼语录：当你为一千块钱发愁时，你就去用各种办法挣钱。洗盘子抗麻袋打零工，当你挣到这一千块时，你会发现你有了挣一万块的能力。而这时你也树立起了自己的第一个小目标：挣到第一个十万。</span><br><span class="line">平头白发银披风，一生都在征战中。豺狼虎豹全不怕，唯独不敢下广东。</span><br><span class="line">我不是在打架，就是在打架的路上。</span><br><span class="line">我的iPhone x被摔碎了，将碎片拼好之后，它竟然扇扇翅膀飞走了。仔细一看原来是我拼错，拼成了Phoenix。</span><br><span class="line">左手也疯狂。</span><br><span class="line">高不成低不就。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">女儿问爸爸，什么是爱情。</span><br><span class="line">爸爸说：“爱情就是爸爸什么都没有，妈妈依然嫁给了爸爸。”</span><br><span class="line">女儿又问：“什么是亲情呢？”</span><br><span class="line">爸爸说：“亲情就是妈妈绝不会让你嫁给一个什么都没有的人。” </span><br><span class="line">女儿又问妈妈，什么是爱情，</span><br><span class="line">妈妈说：“爱情就是爸爸什么都有了依然爱妈妈。”</span><br><span class="line">女儿又问：“什么是亲情？”</span><br><span class="line">妈妈说：“亲情就是爸爸绝对不会让你嫁给一个什么都有却不爱你的人。“</span><br></pre></td></tr></table></figure><h1 id="黎曼猜想"><a href="#黎曼猜想" class="headerlink" title="黎曼猜想"></a>黎曼猜想</h1><p><a href="https://weibo.com/tv/v/GAYSnAy95?fid=1034:4288133395864422" target="_blank" rel="noopener">李永乐老师讲解黎曼猜想</a><br>全体自然数的和是否等于-1/12。</p><h1 id="黎曼假设"><a href="#黎曼假设" class="headerlink" title="黎曼假设"></a>黎曼假设</h1><p>黎曼假设（或称黎曼猜想）是关于黎曼ζ函数ζ(s)的零点分布的猜想，由数学家波恩哈德·黎曼于1859年提出。德国数学家戴维·希尔伯特在第二届国际数学家大会上提出了20世纪数学家应当努力解决的23个数学问题，其中便包括黎曼假设。现今克雷数学研究所悬赏的世界七大数学难题中也包括黎曼假设。 [1]<br>虽然在知名度上，黎曼猜想不及费尔马猜想和哥德巴赫猜想，但它在数学上的重要性要远远超过后两者，是当今数学界最重要的数学难题，当今数学文献中已有超过一千条数学命题以黎曼猜想（或其推广形式）的成立为前提。<br>2018年9月，迈克尔·阿蒂亚声明证明黎曼猜想，将于9月24日海德堡获奖者论坛上宣讲。 [1-4]  9月24日，迈克尔·阿蒂亚贴出了他证明黎曼假设（猜想）的预印本。</p><h1 id="解析延拓"><a href="#解析延拓" class="headerlink" title="解析延拓"></a>解析延拓</h1><p>假定函数f1(z)与f2(z)分别在区域D1与D2中解析，D1与D2有一公共部分，在其上f1(z)=f2z)成立。于是将f1(z)与f2(z)在D1及D2内的全体点上的数值集合看成一个解析函数f(z)，则f(z)在D=D1+D2中解析，在D1中f(z)=f2(z)，而在D2中f(z)=f2(z)。<br>函数f2(z)可以看成由拓展f1(z)的定义区域所得，故称它为f1(z)的解析延拓。当然，根据同样理由，f1(z)是f2(z)的解析延拓，这种拓展原给函数定义的方法称为解析延拓。</p><h1 id="假如黎曼猜想被证明，对数学或其他领域有何重大影响？"><a href="#假如黎曼猜想被证明，对数学或其他领域有何重大影响？" class="headerlink" title="假如黎曼猜想被证明，对数学或其他领域有何重大影响？"></a>假如黎曼猜想被证明，对数学或其他领域有何重大影响？</h1><p>　　卢昌海：如前所述，当今数学文献中有1，000条以上的数学命题是以黎曼猜想或其推广形式的成立为前提的。因此，黎曼猜想及其推广形式一旦被证明，数学中将史无前例地于“一夜间”新增1，000多条定理，这将对数学的面貌产生非同小可的影响。所有直接间接用到那些命题的领域也将程度不等地受到影响。</p><p>定理，用推理的方法判断为真的命题叫做定理。<br>定律，是为实践和事实所证明，反映事物在一定条件下发展变化的客观规律的论断。<br>公理，是指依据人类理性的不证自明的基本事实，经过人类长期反复实践的考验，不需要再加证明的基本命题。</p><h1 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h1><p>素数又被称为质数，其含义就是除了数字一和本身之外不能被其他任何的数字除尽，根据算术基本定理，每一个比1大的整数，要么本身是一个质数，要么可以写成一系列质数的乘积，最小的素数是2。而素数定理能够准确的描述素数的分布，素数分布规律，以36N（N+1）为单位，随着N的增大，素数的个数发波浪形式渐渐增多。素数定理可以给出第n个素数p(n)的渐近估计： 它也给出从整数中抽到素数的概率。从不大于n的自然数随机选一个，它是素数的概率大约是1/ln n。</p><p>“我跟导师聊起阿蒂亚证明黎曼假说的事。他说每个人，不管 (前一秒) 是在带孩子，还是在呼吸，还是在干嘛，都纷纷放下手上的事，开始证明黎曼假说了。”</p><p>妄自解读了一下这条评论，大概是说，这样就能证明的话，是人都能证明了。</p><h1 id="精细结构常数"><a href="#精细结构常数" class="headerlink" title="精细结构常数"></a>精细结构常数</h1><p>精细结构常数，是物理学中一个重要的无量纲数，常用希腊字母α表示。精细结构常数表示电子在第一玻尔轨道上的运动速度和真空中光速的比值，计算公式为 α=e2/(4πε0cħ)（其中e是电子的电荷，ε0 是真空介电常数， ħ是约化普朗克常数，c 是真空中的光速）。<br>精细结构常数是一个数字,量纲为1(或说是无单位)1/α≈137(更近似为137.03599976)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qianlinjun/article/details/53852306&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qianlinjun/article/details/53852306&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定坐标系中有n个整数点的坐标，求一个中位整点到所有n点的距离和最小，输出最小距离。&lt;/p&gt;
&lt;p&gt;1、求算术平均数中心（一开始以为这就是结果值）&lt;br&gt;2、根据公式进行迭代&lt;br&gt;3、通过自定义迭代优化的限值来让迭代停止。&lt;br&gt;
    
    </summary>
    
      <category term="ALGORITHM" scheme="https://hankin2015.github.io/categories/ALGORITHM/"/>
    
    
      <category term="数学" scheme="https://hankin2015.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="坐标系" scheme="https://hankin2015.github.io/tags/%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux中各种后缀格式安装包的安装总结</title>
    <link href="https://hankin2015.github.io/2018/08/16/20180816InstallType/"/>
    <id>https://hankin2015.github.io/2018/08/16/20180816InstallType/</id>
    <published>2018-08-15T16:50:41.000Z</published>
    <updated>2018-08-15T16:59:35.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、-tar"><a href="#1、-tar" class="headerlink" title="1、 tar"></a>1、 tar</h1><h1 id="2、-bash"><a href="#2、-bash" class="headerlink" title="2、 bash"></a>2、 bash</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、-tar&quot;&gt;&lt;a href=&quot;#1、-tar&quot; class=&quot;headerlink&quot; title=&quot;1、 tar&quot;&gt;&lt;/a&gt;1、 tar&lt;/h1&gt;&lt;h1 id=&quot;2、-bash&quot;&gt;&lt;a href=&quot;#2、-bash&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="LINUX" scheme="https://hankin2015.github.io/categories/LINUX/"/>
    
    
      <category term="Linux" scheme="https://hankin2015.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
