<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HanKin的博客</title>
  
  <subtitle>聪明出于勤奋，天才在于积累。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hankin2015.github.io/"/>
  <updated>2018-11-26T14:02:25.077Z</updated>
  <id>https://hankin2015.github.io/</id>
  
  <author>
    <name>HanKin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据处理常用基础操作(清洗、可视化、特征工程)[置顶]</title>
    <link href="https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/"/>
    <id>https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/</id>
    <published>2222-11-10T13:47:41.000Z</published>
    <updated>2018-11-26T14:02:25.077Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h1 id="一、数据挖掘之pandas-DataFrame"><a href="#一、数据挖掘之pandas-DataFrame" class="headerlink" title="一、数据挖掘之pandas.DataFrame"></a>一、数据挖掘之pandas.DataFrame</h1><p><a href="http://www.jianshu.com/p/682c24aef525" target="_blank" rel="noopener">用python做数据分析4|pandas库介绍之DataFrame基本操作</a><br><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://old.sebug.net/paper/books/scipydoc/index.html#" target="_blank" rel="noopener">用Python做科学计算</a></p><p>数据地址：github.com<br>源代码地址：github.com</p><h2 id="1、jupyter-notebook显示plot图像"><a href="#1、jupyter-notebook显示plot图像" class="headerlink" title="1、jupyter notebook显示plot图像"></a>1、jupyter notebook显示plot图像</h2><blockquote><p>%matplotlib inline</p></blockquote><h2 id="2、处理excel数据"><a href="#2、处理excel数据" class="headerlink" title="2、处理excel数据"></a>2、处理excel数据</h2><p>后缀为xls或者xlsx</p><blockquote><p>import pandas as pd<br>data.to_excel(‘data.xlsx’, index=False)</p></blockquote><h2 id="3、处理csv数据"><a href="#3、处理csv数据" class="headerlink" title="3、处理csv数据"></a>3、处理csv数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_csv(‘./data.csv’, sep=’\t’)  #按照相应的间隔符读取数据，默认空格或者tab符</p></blockquote><h2 id="‘utf-8’-codec-can’t-decode-byte-0xd1-in-position-9-invalid-continuation-byte"><a href="#‘utf-8’-codec-can’t-decode-byte-0xd1-in-position-9-invalid-continuation-byte" class="headerlink" title="‘utf-8’ codec can’t decode byte 0xd1 in position 9: invalid continuation byte"></a>‘utf-8’ codec can’t decode byte 0xd1 in position 9: invalid continuation byte</h2><p>意思是utf-8编码不行，需要其他类型编码格式，默认应该是utf-8或者None。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(&apos;air_tianjin_2017.csv&apos;, engine=&apos;python&apos;, encoding=&apos;gbk&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="有中文路径问题"><a href="#有中文路径问题" class="headerlink" title="有中文路径问题"></a>有中文路径问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path = &apos;文件/data数据.csv&apos;</span><br><span class="line">path = unicode(path, &apos;utf8&apos;)</span><br><span class="line"></span><br><span class="line">pd.read_csv( &apos;文件/data数据.csv&apos;, &apos;rb&apos;)</span><br><span class="line"></span><br><span class="line">file = open(path)</span><br><span class="line">pd.read_csv(file)</span><br></pre></td></tr></table></figure><h2 id="字符串前面添加u-r-b的含义"><a href="#字符串前面添加u-r-b的含义" class="headerlink" title="字符串前面添加u,r,b的含义"></a>字符串前面添加u,r,b的含义</h2><p>u/U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf8</p><p>r/R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p><p>b:bytes<br>python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes<br>python2.x里, b前缀没什么具体意义， 只是为了兼容python3.x的这种写法</p><h2 id="4、处理txt数据"><a href="#4、处理txt数据" class="headerlink" title="4、处理txt数据"></a>4、处理txt数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_table(‘./data.txt’)<br>data.to_csv(‘data.txt’, sep=’\t’, index=False)</p></blockquote><h2 id="5、数据可视化"><a href="#5、数据可视化" class="headerlink" title="5、数据可视化"></a>5、数据可视化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#marker为形状、s为形状大小，线条没有，c为颜色，也可以写全称size、color</span></span><br><span class="line"><span class="comment">#scatter为散点图、plot为折线图</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x轴数据, y轴数据, marker = <span class="string">'o'</span>, s=<span class="number">200</span>, c=<span class="string">'red'</span>, label=标签名) </span><br><span class="line">plt.plot(x轴数据, y轴数据, marker = <span class="string">'x'</span>, c=<span class="string">'black'</span>, label=<span class="string">'Comprehensive'</span>)</span><br><span class="line">plt.legend()  <span class="comment"># 让图例生效</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(x轴名称)</span><br><span class="line">plt.ylabel(y轴名称)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def scatter(X, Y):</span><br><span class="line">    #产生测试数据  </span><br><span class="line">    x = np.arange(1,10)  </span><br><span class="line">    y = x  </span><br><span class="line">    fig = plt.figure()  </span><br><span class="line">    ax = fig.add_subplot(111)   # 设置子图</span><br><span class="line">    #设置标题  </span><br><span class="line">    ax.set_title(&apos;Scatter Plot&apos;)  </span><br><span class="line">    #设置X轴标签  </span><br><span class="line">    plt.xlabel(&apos;X&apos;)  </span><br><span class="line">    #设置Y轴标签  </span><br><span class="line">    plt.ylabel(&apos;Y&apos;)  </span><br><span class="line">    #添加批注</span><br><span class="line">    for i in range(4):    # xy表示批注点位置，xxtext表示批注文字位置，arrowprops加箭头</span><br><span class="line">        ax.annotate(Y[i],xy=(X[i,0],X[i,1]), xytext=(X[i,0],X[i,1]), arrowprops=dict(facecolor=&apos;black&apos;, shrink=0.05))</span><br><span class="line">    #画散点图  </span><br><span class="line">    ax.scatter(X[:,0],X[:,1],s = 75,c = &apos;r&apos;,marker = &apos;o&apos;,alpha=.5)  </span><br><span class="line">    #设置图标  </span><br><span class="line">    plt.legend(&apos;X&apos;)  </span><br><span class="line">    #显示所画的图  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="画函数曲线"><a href="#画函数曲线" class="headerlink" title="画函数曲线"></a>画函数曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(0, 12)</span><br><span class="line">y1 = 2 * x + 5   #直线函数</span><br><span class="line">y2 = x ** 2 + 5  #曲线函数</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1, c=&apos;yellow&apos;)</span><br><span class="line">plt.plot(x, y2, c=&apos;red&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="6、dataframe增加一行数据或者一列数据"><a href="#6、dataframe增加一行数据或者一列数据" class="headerlink" title="6、dataframe增加一行数据或者一列数据"></a>6、dataframe增加一行数据或者一列数据</h2><h3 id="增加一行"><a href="#增加一行" class="headerlink" title="增加一行"></a>增加一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(columns=[&apos;name&apos;,&apos;sex&apos;,&apos;age&apos;, &apos;other&apos;])</span><br><span class="line"># 方法1(必须加列名)  居然无效???</span><br><span class="line">df.append(&#123;&apos;name&apos;: &apos;hejian&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;age&apos;: 24, &apos;other&apos;: &apos;handsome&apos;&#125;, ignore_index=True, verify_integrity=False)</span><br><span class="line"></span><br><span class="line">#方法2</span><br><span class="line">df.loc[2] = [&apos;hejian&apos;,  &apos;man&apos;,  24, &apos;handsome&apos;]</span><br></pre></td></tr></table></figure><h2 id="7、排序"><a href="#7、排序" class="headerlink" title="7、排序"></a>7、排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sorted([5, 2, 3, 1, 4])</span><br><span class="line">a = [5, 2, 3, 1, 4]</span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line">sorted(res, key = lambda x:x[0])</span><br><span class="line">df.sort_values(by=)</span><br></pre></td></tr></table></figure><h2 id="8、输出格式"><a href="#8、输出格式" class="headerlink" title="8、输出格式"></a>8、输出格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = [1, 2, 3, 4]</span><br><span class="line">res = []</span><br><span class="line">for elem in ans:</span><br><span class="line">    res.append(str(elem))</span><br><span class="line">print(&apos; &apos;.join(res))  #按照空格间隔输出</span><br><span class="line">print(&apos;*&apos;.join(res))  #按照星号间隔输出</span><br></pre></td></tr></table></figure><h2 id="9、基本操作"><a href="#9、基本操作" class="headerlink" title="9、基本操作"></a>9、基本操作</h2><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randint(0,10,(4, 3)), columns=list(&apos;bde&apos;), index=range(4))</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([1, 2, 3, 4, 5], columns=[&apos;cols&apos;], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">df.index</span><br><span class="line">df.columns</span><br><span class="line">df = pd.DataFrame(np.random.randint(low=0, high=10, size=(5, 5)), columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br><span class="line">df = pd.DataFrame(data=d, dtype=np.int8)</span><br><span class="line">df = pd.DataFrame(&#123;&apos;x&apos;:x, &apos;y&apos;:y&#125;, columns=[&apos;x&apos;, &apos;y&apos;])</span><br></pre></td></tr></table></figure><h3 id="根据索引查看数据"><a href="#根据索引查看数据" class="headerlink" title="根据索引查看数据"></a>根据索引查看数据</h3><blockquote><p>df.loc[‘a’]   # 索引为ａ这一行的数据<br>df.iloc[0]      #跟上面的操作等价，一个是根据索引名，一个是根据数字索引访问数据</p></blockquote><h3 id="对每个元素乘以２"><a href="#对每个元素乘以２" class="headerlink" title="对每个元素乘以２"></a>对每个元素乘以２</h3><blockquote><p>print df.apply(lambda x:x*2)</p></blockquote><h3 id="对每个元素求平方-支持ndarray一样的向量化操作"><a href="#对每个元素求平方-支持ndarray一样的向量化操作" class="headerlink" title="对每个元素求平方(支持ndarray一样的向量化操作)"></a>对每个元素求平方(支持ndarray一样的向量化操作)</h3><blockquote><p>print df**2</p></blockquote><h3 id="默认合并之接受索引已经存在的值"><a href="#默认合并之接受索引已经存在的值" class="headerlink" title="默认合并之接受索引已经存在的值"></a>默认合并之接受索引已经存在的值</h3><p>通过指定参数 how，指定合并的方式：inner(交集)、outer(并集)</p><blockquote><p>print dfb.join(df_a,how=’inner’)   # 合并两个DataFrame对象的交集</p></blockquote><h3 id="对DataFrame对象进行列扩充"><a href="#对DataFrame对象进行列扩充" class="headerlink" title="对DataFrame对象进行列扩充"></a>对DataFrame对象进行列扩充</h3><blockquote><p>df[‘col4’] = [‘cnn’,’rnn’]      #直接添加一列数据</p></blockquote><h3 id="字段类型转换"><a href="#字段类型转换" class="headerlink" title="字段类型转换"></a>字段类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">arr = np.array([1, 2, 3])</span><br><span class="line">print(type(arr))</span><br><span class="line">print(arr.dtype)</span><br><span class="line">brr = arr.astype(np.float64)</span><br><span class="line">print(type(brr))</span><br><span class="line">print(brr.dtype)</span><br><span class="line">print(arr)</span><br><span class="line">print(brr)</span><br><span class="line">crr = arr.astype(str)</span><br><span class="line">print(type(crr))</span><br><span class="line">print(crr.dtype)</span><br><span class="line">crr</span><br></pre></td></tr></table></figure><h2 id="10、连接合并多个dataframe"><a href="#10、连接合并多个dataframe" class="headerlink" title="10、连接合并多个dataframe"></a>10、连接合并多个dataframe</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = df1.append(df2, ignore_index=True)  # 需要重新index</span><br><span class="line">df</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="11、增删改查"><a href="#11、增删改查" class="headerlink" title="11、增删改查"></a>11、增删改查</h2><p><a href="">基本操作</a></p><h1 id="二、基础的特征工程"><a href="#二、基础的特征工程" class="headerlink" title="二、基础的特征工程"></a>二、基础的特征工程</h1><h2 id="1、查看数据类型和一些值"><a href="#1、查看数据类型和一些值" class="headerlink" title="1、查看数据类型和一些值"></a>1、查看数据类型和一些值</h2><blockquote><p>df.info()<br>df.describe()</p><h2 id="2、查看是否有缺失值"><a href="#2、查看是否有缺失值" class="headerlink" title="2、查看是否有缺失值"></a>2、查看是否有缺失值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isnull</span><br><span class="line">isna</span><br><span class="line">isin(values)</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、良-恶性乳腺癌肿瘤预测实例"><a href="#3、良-恶性乳腺癌肿瘤预测实例" class="headerlink" title="3、良/恶性乳腺癌肿瘤预测实例"></a>3、良/恶性乳腺癌肿瘤预测实例</h2><p><a href="">ipython notebook分析</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 创建特征列表。</span><br><span class="line">column_names = [&apos;Sample code number&apos;, &apos;Clump Thickness&apos;, &apos;Uniformity of Cell Size&apos;, &apos;Uniformity of Cell Shape&apos;, &apos;Marginal Adhesion&apos;, &apos;Single Epithelial Cell Size&apos;, &apos;Bare Nuclei&apos;, &apos;Bland Chromatin&apos;, &apos;Normal Nucleoli&apos;, &apos;Mitoses&apos;, &apos;Class&apos;]</span><br><span class="line"></span><br><span class="line"># 使用pandas.read_csv函数从互联网读取指定数据。</span><br><span class="line">data = pd.read_csv(&apos;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&apos;, names = column_names )</span><br><span class="line"></span><br><span class="line"># 将?替换为标准缺失值表示。</span><br><span class="line">data = data.replace(to_replace=&apos;?&apos;, value=np.nan)</span><br><span class="line"># 丢弃带有缺失值的数据（只要有一个维度有缺失）。</span><br><span class="line">data = data.dropna(how=&apos;any&apos;)</span><br><span class="line"></span><br><span class="line"># 输出data的数据量和维度。</span><br><span class="line">data.shape</span><br><span class="line"></span><br><span class="line"># 使用sklearn.cross_valiation里的train_test_split模块用于分割数据。</span><br><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line"></span><br><span class="line"># 随机采样25%的数据用于测试，剩下的75%用于构建训练集合。</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data[column_names[1:10]], data[column_names[10]], test_size=0.25, random_state=33)</span><br><span class="line"></span><br><span class="line"># 查验训练样本的数量和类别分布。</span><br><span class="line">y_train.value_counts()</span><br><span class="line"></span><br><span class="line"># 查验测试样本的数量和类别分布。</span><br><span class="line">y_test.value_counts()</span><br><span class="line"></span><br><span class="line"># 从sklearn.preprocessing里导入StandardScaler。</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"># 从sklearn.linear_model里导入LogisticRegression与SGDClassifier。</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.linear_model import SGDClassifier</span><br><span class="line"></span><br><span class="line"># 标准化数据，保证每个维度的特征数据方差为1，均值为0。使得预测结果不会被某些维度过大的特征值而主导。</span><br><span class="line">ss = StandardScaler()</span><br><span class="line">X_train = ss.fit_transform(X_train)</span><br><span class="line">X_test = ss.transform(X_test)</span><br><span class="line"></span><br><span class="line"># 初始化LogisticRegression与SGDClassifier。</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">sgdc = SGDClassifier()</span><br><span class="line"></span><br><span class="line"># 调用LogisticRegression中的fit函数/模块用来训练模型参数。</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型lr对X_test进行预测，结果储存在变量lr_y_predict中。</span><br><span class="line">lr_y_predict = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 调用SGDClassifier中的fit函数/模块用来训练模型参数。</span><br><span class="line">sgdc.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型sgdc对X_test进行预测，结果储存在变量sgdc_y_predict中。</span><br><span class="line">sgdc_y_predict = sgdc.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 从sklearn.metrics里导入classification_report模块。</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line"># 使用逻辑斯蒂回归模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuracy of LR Classifier:&apos;, lr.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得LogisticRegression其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, lr_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br><span class="line"></span><br><span class="line"> # 使用随机梯度下降模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuarcy of SGD Classifier:&apos;, sgdc.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得SGDClassifier其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, sgdc_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br></pre></td></tr></table></figure></p><h2 id="4、召回率、精确率和F1值"><a href="#4、召回率、精确率和F1值" class="headerlink" title="4、召回率、精确率和F1值"></a>4、召回率、精确率和F1值</h2><p>假设我们手上有60个正样本，40个负样本，我们要找出所有的正样本，系统查找出50个，其中只有40个是真正的正样本，计算上述各指标。</p><p>TP: 将正类预测为正类数  40<br>FN: 将正类预测为负类数  20<br>FP: 将负类预测为正类数  10<br>TN: 将负类预测为负类数  30</p><p>准确率(accuracy) = 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN) = 70%<br>精确率(precision) = TP/(TP+FP) = 80%<br>召回率(recall) = TP/(TP+FN) = 2/3<br>F值  = 正确率 <em> 召回率 </em> 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）<br>白话：精确率就是在所有预测为正例中有多少是预测正确的，召回率就是在全部本身就是正样本中有多少预测正确。</p><h2 id="5、sklearn-model-selection-train-test-split随机划分训练集和测试集"><a href="#5、sklearn-model-selection-train-test-split随机划分训练集和测试集" class="headerlink" title="5、sklearn.model_selection.train_test_split随机划分训练集和测试集"></a>5、sklearn.model_selection.train_test_split随机划分训练集和测试集</h2><p>train_test_split是交叉验证中常用的函数，功能是从样本中随机的按比例选取train data和testdata，形式为：</p><blockquote><p>X_train,X_test, y_train, y_test =<br>cross_validation.train_test_split(train_data,train_target,test_size=0.4, random_state=0)</p></blockquote><p>参数解释：<br>train_data：所要划分的样本特征集<br>train_target：所要划分的样本结果<br>test_size：样本占比，如果是整数的话就是样本的数量<br>random_state：是随机数的种子。</p><p>随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。<br>随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：<br>种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><h1 id="三、实例篇"><a href="#三、实例篇" class="headerlink" title="三、实例篇"></a>三、实例篇</h1><p>数据文件：data.csv   data.txt  data.xlsx<br>数据内容(高中成绩)：</p><table><thead><tr><th style="text-align:center">Date</th><th style="text-align:center">Chinese</th><th style="text-align:center">Math</th><th style="text-align:center">English</th><th style="text-align:center">Comprehensive </th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">111</td><td style="text-align:center">130</td><td style="text-align:center">127</td><td style="text-align:center">269    </td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td style="text-align:center">159</td><td style="text-align:center">ok</td><td style="text-align:center">191</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">137</td><td style="text-align:center">119</td><td style="text-align:center">99</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">97</td><td style="text-align:center">149</td><td style="text-align:center">89</td><td style="text-align:center">235</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">120</td><td style="text-align:center">135</td><td style="text-align:center">116</td><td style="text-align:center">282 </td></tr></tbody></table><h2 id="1、生成数据并保存读取"><a href="#1、生成数据并保存读取" class="headerlink" title="1、生成数据并保存读取"></a>1、生成数据并保存读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    data = pd.DataFrame(columns=[&apos;Date&apos;,&apos;Chinese&apos;,&apos;Math&apos;, &apos;English&apos;, &apos;Comprehensive&apos;])</span><br><span class="line">    data.loc[0] = [7,  111, 130, 127, 269]</span><br><span class="line">    data.loc[1] = [8,  &apos;&apos;, 159, &apos;ok&apos;, 191]</span><br><span class="line">    data.loc[2] = [9, 137, 119, 99, 250]</span><br><span class="line">    data.loc[3] = [10, 97, 149, 89, 235]</span><br><span class="line">    data.loc[4] = [11, 120, 135, 116, 282]</span><br><span class="line"></span><br><span class="line">    data.to_csv(&apos;&apos;)</span><br></pre></td></tr></table></figure><h1 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h1><h2 id="去除警告"><a href="#去除警告" class="headerlink" title="去除警告"></a>去除警告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line"></span><br><span class="line">def ignore_warn(*arg, *swarg):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">warning.warn = ignore_warn</span><br></pre></td></tr></table></figure><h3 id="忽略命令行下警告错误的输出"><a href="#忽略命令行下警告错误的输出" class="headerlink" title="忽略命令行下警告错误的输出"></a>忽略命令行下警告错误的输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -W ignore yourscript.py</span><br><span class="line">with open as [for   ]</span><br></pre></td></tr></table></figure><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for i in range (len(list1)):</span><br><span class="line">    print i ,list1[i]</span><br><span class="line"></span><br><span class="line">上述方法有些累赘，利用enumerate()会更加直接和优美：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0 这</span><br><span class="line">1 是</span><br><span class="line">2 一个</span><br><span class="line">3 测试</span><br><span class="line"></span><br><span class="line">enumerate还可以接收第二个参数，用于指定索引起始值，如：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1, 1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">1 这</span><br><span class="line">2 是</span><br><span class="line">3 一个</span><br><span class="line">4 测试</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如果要统计文件的行数，可以这样写：</p><blockquote><p>count = len(open(filepath, ‘r’).readlines())<br>这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。</p></blockquote><p>可以利用enumerate()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">for index, line in enumerate(open(filepath,&apos;r&apos;))： </span><br><span class="line">    count += 1</span><br></pre></td></tr></table></figure></p><h2 id="python-字符串查找的4个方法"><a href="#python-字符串查找的4个方法" class="headerlink" title="python 字符串查找的4个方法"></a>python 字符串查找的4个方法</h2><h3 id="1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"><a href="#1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1" class="headerlink" title="1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"></a>1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1</h3><p>info = ‘abca’<br>print info.find(‘a’)##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</p><p>info = ‘abca’<br>print info.find(‘a’,1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3</p><p>info = ‘abca’<br>print info.find(‘333’)##返回-1,查找不到返回-1</p><h3 id="2-index-方法："><a href="#2-index-方法：" class="headerlink" title="2 index()方法："></a>2 index()方法：</h3><p>python 的index方法是在字符串里查找子串第一次出现的位置，类似字符串的find方法，不过比find方法更好的是，如果查找不到子串，会抛出异常，而不是返回-1</p><p>info = ‘abca’<br>print info.index(‘a’)<br>print info.index(‘33’)</p><h3 id="3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"><a href="#3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。" class="headerlink" title="3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"></a>3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。</h3><p>如果查找全部，可以先找到第一个，然后从当前为起点继续查找。另外一种方法就是正则表达式。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://hankin2015.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="DataFrame" scheme="https://hankin2015.github.io/tags/DataFrame/"/>
    
      <category term="Pandas" scheme="https://hankin2015.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法总结[置顶]</title>
    <link href="https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/"/>
    <id>https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/</id>
    <published>2222-04-24T02:47:41.000Z</published>
    <updated>2018-08-11T16:42:21.942Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">参考：@移动开发小冉</a></p><blockquote><p>算法虐我千百遍，我待算法如初恋</p></blockquote><p>这里的内容是我学习算法过程的一些记录，希望能一直坚持下去。</p><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul><li>把所有经典算法写一遍  </li><li>看算法有关源码   </li><li>加入算法学习社区，相互鼓励学习   </li><li>看经典书籍  </li><li>刷题   </li></ul><h2 id="基本数据结构和算法"><a href="#基本数据结构和算法" class="headerlink" title="基本数据结构和算法"></a>基本数据结构和算法</h2><p>这些算法全部自己敲一遍：</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表</li><li>双向链表</li></ul><h3 id="哈希表-散列表-Hash-Table"><a href="#哈希表-散列表-Hash-Table" class="headerlink" title="哈希表/散列表 (Hash Table)"></a>哈希表/散列表 (Hash Table)</h3><ul><li>散列函数</li><li>碰撞解决</li></ul><h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><ul><li>排序</li><li>查找<ul><li>BF算法  </li><li>KMP算法  </li><li>BM算法  </li></ul></li><li>正则表达式</li><li>数据压缩</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>二叉树    </li><li>二叉查找树   </li><li>伸展树(splay tree 分裂树)   </li><li>平衡二叉树AVL    </li><li>红黑树  </li><li>B树,B+,B*  </li><li>R树  </li><li>Trie树(前缀树)  </li><li>后缀树  </li><li>最优二叉树(赫夫曼树) </li><li>二叉堆 （大根堆，小根堆）   </li><li>二项树    </li><li>二项堆  </li><li>斐波那契堆(Fibonacci Heap)   </li></ul><h3 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h3><ul><li>图的存储结构和基本操作（建立，遍历，删除节点，添加节点）   </li><li>最小生成树  </li><li>拓扑排序  </li><li>关键路径  </li><li>最短路径: Floyd,Dijkstra,bellman-ford,spfa  </li></ul><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>交换排序算法</strong></p><ul><li>冒泡排序</li><li>插入排序    </li><li>选择排序    </li><li>希尔排序</li><li>快排   </li><li>归并排序  </li><li>堆排序</li></ul><p><strong>线性排序算法</strong></p><ul><li>桶排序 </li></ul><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul><li>顺序表查找：顺序查找  </li><li>有序表查找：二分查找  </li><li>分块查找： 块内无序，块之间有序；可以先二分查找定位到块，然后再到<code>块</code>中顺序查找  </li><li>动态查找:  二叉排序树，AVL树，B- ，B+    （这里之所以叫 <code>动态查找表</code>，是因为表结构是查找的过程中动态生成的）</li><li>哈希表：  O(1)     </li></ul><h3 id="15个经典基础算法"><a href="#15个经典基础算法" class="headerlink" title="15个经典基础算法"></a>15个经典基础算法</h3><ul><li>Hash  </li><li>快速排序 </li><li>快递选择SELECT </li><li>BFS/DFS （广度/深度优先遍历）    </li><li>红黑树 （一种自平衡的<code>二叉查找树</code>）  </li><li>KMP    字符串匹配算法</li><li>DP (动态规划 dynamic programming)   </li><li>A*寻路算法： 求解最短路径 </li><li>Dijkstra：最短路径算法 （八卦下：Dijkstra是荷兰的计算机科学家,提出”信号量和PV原语“,”解决哲学家就餐问题”,”死锁“也是它提出来的） </li><li>遗传算法  </li><li>启发式搜索   </li><li>图像特征提取之SIFT算法  </li><li>傅立叶变换  </li><li>SPFA(shortest path faster algorithm)  单元最短路径算法  </li></ul><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li>Hash映射/分而治之</li><li>Bitmap</li><li>Bloom filter(布隆过滤器)</li><li>Trie树</li><li>数据库索引</li><li>倒排索引(Inverted Index)</li><li>双层桶划分</li><li>外排序</li><li>simhash算法</li><li>分布处理之Mapreduce</li></ul><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ul><li>迭代法  </li><li>穷举搜索法  </li><li>递推法  </li><li>动态规划  </li><li>贪心算法  </li><li>回溯  </li><li>分治算法  </li></ul><h2 id="算法问题选编"><a href="#算法问题选编" class="headerlink" title="算法问题选编"></a>算法问题选编</h2><p>这是一个算法题目合集，题目是我从网络和书籍之中整理而来，部分题目已经做了思路整理。问题分类包括：</p><ul><li>字符串</li><li>堆和栈</li><li>链表</li><li>数值问题</li><li>数组和数列问题</li><li>矩阵问题</li><li>二叉树</li><li>图</li><li>海量数据处理</li><li>智力思维训练</li><li>系统设计</li></ul><p>还有部分来自算法网站和书籍：</p><ul><li>九度OJ</li><li>leetcode</li><li>剑指offer</li></ul><h2 id="开源项目中的算法"><a href="#开源项目中的算法" class="headerlink" title="开源项目中的算法"></a>开源项目中的算法</h2><ul><li>YYCache</li><li>cocos2d-objc</li><li>…</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="刷题必备"><a href="#刷题必备" class="headerlink" title="刷题必备"></a>刷题必备</h3><p>《剑指offer》<br>《编程之美》<br>《编程之法:面试和算法心得》<br>《算法谜题》 都是思维题 </p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>《编程珠玑》Programming Pearls<br>《编程珠玑(续)》<br>《数据结构与算法分析》<br>《Algorithms》 这本近千页的书只有6章,其中四章分别是排序，查找，图，字符串，足见介绍细致     </p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>《算法设计与分析基础》<br>《算法引论》 告诉你如何创造算法   断货<br>《Algorithm Design Manual》算法设计手册 红皮书  </p><p>《算法导论》 是一本对算法介绍比较全面的经典书籍   </p><p>《Algorithms on Strings,Trees and Sequences》<br>《Advanced Data Structures》 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树  600块    </p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>《深入理解计算机系统》<br>《TCP/IP详解三卷》<br>《UNIX网络编程二卷》<br>《UNIX环境高级编程：第2版》  </p><p>《The practice of programming》   Brian Kernighan和Rob Pike<br>《writing efficient programs》  优化<br>《The science of programming》 证明代码段的正确性   800块一本   </p><h2 id="参考链接和学习网站"><a href="#参考链接和学习网站" class="headerlink" title="参考链接和学习网站"></a>参考链接和学习网站</h2><h3 id="July-博客"><a href="#July-博客" class="headerlink" title="July 博客"></a><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">July 博客</a></h3><p>《数学建模十大经典算法》<br>《数据挖掘领域十大经典算法》<br>《十道海量数据处理面试题》<br>《数字图像处理领域的二十四个经典算法》<br>《精选微软等公司经典的算法面试100题》 </p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">The-Art-Of-Programming-By-July</a><br><a href="http://blog.csdn.net/column/details/ms100.html" target="_blank" rel="noopener">微软面试100题</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6460494" target="_blank" rel="noopener">程序员编程艺术</a>   </p><h3 id="基本算法演示"><a href="#基本算法演示" class="headerlink" title="基本算法演示"></a>基本算法演示</h3><p><a href="http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html" target="_blank" rel="noopener">http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html</a><br><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">http://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a>  </p><h3 id="编程网站"><a href="#编程网站" class="headerlink" title="编程网站"></a>编程网站</h3><p><a href="http://leetcode.com/" target="_blank" rel="noopener">leetcode</a><br><a href="http://openjudge.cn/" target="_blank" rel="noopener">openjudge</a>  开放在线程序评测平台，可以床架自己的OJ小组<br><a href="http://ac.jobdu.com/index.php" target="_blank" rel="noopener">九度OJ</a>     </p><p>这有个<a href="http://www.java3z.com/cwbwebhome/article/article19/res041.html" target="_blank" rel="noopener">ACM训练方案</a>   </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/" target="_blank" rel="noopener">高级数据结构和算法</a>  北大教授张铭老师在coursera上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie树、AVL树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然coursera上也还有很多其它算法方面的视频课程。</p><p><a href="https://class.coursera.org/algorithms-001/lecture" target="_blank" rel="noopener">算法设计与分析 Design and Analysis of Algorithms</a> 由北大教授Wanling Qu在coursera讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf文件）以便阅读和复习。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构算法" scheme="https://hankin2015.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://hankin2015.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hankin2015.github.io/2019/08/28/20180819NetEase2019/"/>
    <id>https://hankin2015.github.io/2019/08/28/20180819NetEase2019/</id>
    <published>2019-08-27T16:46:50.175Z</published>
    <updated>2018-08-18T17:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/92989?type=2&amp;order=3&amp;pos=63&amp;page=3" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/92989?type=2&amp;order=3&amp;pos=63&amp;page=3</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, column, cnt[1005];</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; column;</span><br><span class="line">        cnt[column]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *min_element(cnt + 1, cnt + n + 1) &lt;&lt; endl;   // 列数从1开始 </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/92989?type=2&amp;amp;order=3&amp;amp;pos=63&amp;amp;page=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hankin2015.github.io/2019/08/28/20180813SizeofType/"/>
    <id>https://hankin2015.github.io/2019/08/28/20180813SizeofType/</id>
    <published>2019-08-27T16:46:50.171Z</published>
    <updated>2018-08-12T16:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short num1 = 65535u;</span><br><span class="line">    unsigned short num2 = 0xFFFFU;           //0~65535</span><br><span class="line">    signed short n1 = (signed short)(num1);</span><br><span class="line">    signed short n2 = (signed short)(num2);  //-32767~32767</span><br><span class="line">    cout &lt;&lt; n1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; n2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    short n = -1;</span><br><span class="line">    unsigned short un = (unsigned short)(n);</span><br><span class="line">    cout &lt;&lt; un &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    unsigned short num = 0x8001U;           //0~65535</span><br><span class="line">    signed short tmp = (signed short)(num); //-32767~32767</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sizeof(char) &lt;&lt; endl;//1</span><br><span class="line">    cout &lt;&lt; sizeof(short) &lt;&lt; endl;//2</span><br><span class="line">    cout &lt;&lt; sizeof(long) &lt;&lt; endl;//4</span><br><span class="line">    cout &lt;&lt; sizeof(int) &lt;&lt; endl;//4</span><br><span class="line">    cout &lt;&lt; sizeof(float) &lt;&lt; endl;//</span><br><span class="line">    cout &lt;&lt; sizeof(long long) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(double) &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sizeof(unsigned char) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(unsigned short) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;</span><br><span class="line">    //cout &lt;&lt; sizeof(unsigned float) &lt;&lt; endl;</span><br><span class="line">    //cout &lt;&lt; sizeof(unsigned double) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(unsigned long long) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sizeof(unsigned long int) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; LONG_LONG_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; LONG_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (numeric_limits&lt;long&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (numeric_limits&lt;short&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (numeric_limits&lt;long long&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (numeric_limits&lt;float&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (numeric_limits&lt;double&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (numeric_limits&lt;long double&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    //cout &lt;&lt; (numeric_limits&lt;long long double&gt;::max)() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hankin2015.github.io/2019/08/28/20180805SegmentTree/"/>
    <id>https://hankin2015.github.io/2019/08/28/20180805SegmentTree/</id>
    <published>2019-08-27T16:46:50.159Z</published>
    <updated>2018-08-05T12:40:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DBLP数据集提取</title>
    <link href="https://hankin2015.github.io/2019/06/18/20190621DBLP/"/>
    <id>https://hankin2015.github.io/2019/06/18/20190621DBLP/</id>
    <published>2019-06-18T13:47:41.000Z</published>
    <updated>2019-06-25T10:24:16.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>数据集出现一个顶点有重复属性：词形还原后没有去重</li><li>异常的home和pag：查看xml发现会有作者的home page出现在title块中，page变成pag是因为我去掉了最后一个字符</li></ul><p># </p><h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><p>dblp网站：<a href="https://dblp.uni-trier.de/" target="_blank" rel="noopener">https://dblp.uni-trier.de/</a><br>数据集网站：<a href="https://dblp.org/xml/" target="_blank" rel="noopener">https://dblp.org/xml/</a><br>数据集：dblp-2018-04-01.xml.gz</p><p>仔细看看会发现dblp数据集网站会添加每天的数据，所以会实时更新数据。所以在下载资料的时候不要下载实时更新的数据集。查看release/文件夹发现，一般会把一个月的稳定版本在1-3日，最好是下载release版本，实时更新的数据集会被覆盖，再也下载不到那种独一无二的数据集。所以推荐下载release版本，方便后面找回。我就遇到了这种问题，当初我用的版本是实时版本，再也找不回数据集了。</p><p>由于我的版本数据集找不到xml了，决定使用师姐的数据集dblp-2018-04-01.xml.gz。</p><h2 id="1、解压后用snap的库解析程序"><a href="#1、解压后用snap的库解析程序" class="headerlink" title="1、解压后用snap的库解析程序"></a>1、解压后用snap的库解析程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">/*************************************************************************************************</span><br><span class="line">函 数 名: SplitStr</span><br><span class="line">功能描述: 将字符串按指定分隔符进行分割</span><br><span class="line">输入参数:</span><br><span class="line">输出参数:</span><br><span class="line">返 回 值:</span><br><span class="line">调用函数:</span><br><span class="line">被调函数:</span><br><span class="line">修改历史:</span><br><span class="line">1.日期: 2017年11月11日</span><br><span class="line">  作者: 何健</span><br><span class="line">      修改: 创建文件</span><br><span class="line">2.日期: 2019年01月07日</span><br><span class="line">  作者: 何健</span><br><span class="line">  修改: 忽略了以“-”等分隔的单词</span><br><span class="line">*************************************************************************************************/</span><br><span class="line">inline void SplitStr(string&amp; s, vector&lt;string&gt;&amp; v, const string&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">string title;</span><br><span class="line">transform(s.begin(), s.end(), back_inserter(title), ::tolower);  // 全部变为小写字母</span><br><span class="line">s = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; title.size(); i++) &#123;</span><br><span class="line">if (title[i] &gt;= &apos;a&apos; &amp;&amp; title[i] &lt;= &apos;z&apos;) &#123;  </span><br><span class="line">s += title[i];</span><br><span class="line">&#125;</span><br><span class="line">else s += c;</span><br><span class="line">&#125;</span><br><span class="line">string::size_type pos1, pos2;</span><br><span class="line">pos2 = s.find(c);</span><br><span class="line">pos1 = 0;</span><br><span class="line">while (string::npos != pos2) &#123;</span><br><span class="line">string str = s.substr(pos1, pos2 - pos1);</span><br><span class="line">string word = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; str.size(); i++) &#123;  // 去掉非法字符</span><br><span class="line">if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) word += str[i];</span><br><span class="line">&#125;</span><br><span class="line">if (word.size() != 0) v.push_back(word);  // 不能为空</span><br><span class="line"></span><br><span class="line">pos1 = pos2 + c.size();</span><br><span class="line">pos2 = s.find(c, pos1);</span><br><span class="line">&#125;</span><br><span class="line">if (pos1 != s.length()) &#123;</span><br><span class="line">string str = s.substr(pos1);</span><br><span class="line">string word = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; str.size(); i++) &#123;</span><br><span class="line">if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) word += str[i];</span><br><span class="line">&#125;</span><br><span class="line">if (word.size() != 0) v.push_back(word);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern map&lt;string, int&gt; keyword_in;</span><br><span class="line"></span><br><span class="line">inline void InvalidKeyword()</span><br><span class="line">&#123;</span><br><span class="line">string stopwords[] = &#123; &quot;i&quot;, &quot;me&quot;, &quot;my&quot;, &quot;myself&quot;, &quot;we&quot;, &quot;our&quot;, &quot;ours&quot;, &quot;ourselves&quot;, &quot;you&quot;, &quot;you’re&quot;,\</span><br><span class="line">&quot;you&apos;ve&quot;, &quot;you&apos;ll&quot;, &quot;you&apos;d&quot;, &quot;your&quot;, &quot;yours&quot;, &quot;yourself&quot;, &quot;yourselves&quot;, &quot;he&quot;, &quot;him&quot;, &quot;his&quot;, &quot;himself&quot;,\</span><br><span class="line">&quot;she&quot;, &quot;she&apos;s&quot;, &quot;her&quot;, &quot;hers&quot;, &quot;herself&quot;, &quot;it&quot;, &quot;it&apos;s&quot;, &quot;its&quot;, &quot;itself&quot;, &quot;they&quot;, &quot;them&quot;, &quot;their&quot;,\</span><br><span class="line">&quot;theirs&quot;, &quot;themselves&quot;, &quot;what&quot;, &quot;which&quot;, &quot;who&quot;, &quot;whom&quot;, &quot;this&quot;, &quot;that&quot;, &quot;that&apos;ll&quot;, &quot;these&quot;,\</span><br><span class="line">&quot;those&quot;, &quot;am&quot;, &quot;is&quot;, &quot;are&quot;, &quot;was&quot;, &quot;were&quot;, &quot;be&quot;, &quot;been&quot;, &quot;being&quot;, &quot;have&quot;, &quot;has&quot;, &quot;had&quot;, &quot;having&quot;,\</span><br><span class="line">&quot;do&quot;, &quot;does&quot;, &quot;did&quot;, &quot;doing&quot;, &quot;a&quot;, &quot;an&quot;, &quot;the&quot;, &quot;and&quot;, &quot;but&quot;, &quot;if&quot;, &quot;or&quot;, &quot;because&quot;, &quot;as&quot;, &quot;until&quot;,\</span><br><span class="line">&quot;while&quot;, &quot;of&quot;, &quot;at&quot;, &quot;by&quot;, &quot;for&quot;, &quot;with&quot;, &quot;about&quot;, &quot;against&quot;, &quot;between&quot;, &quot;into&quot;, &quot;through&quot;, &quot;during&quot;,\</span><br><span class="line">&quot;before&quot;, &quot;after&quot;, &quot;above&quot;, &quot;below&quot;, &quot;to&quot;, &quot;from&quot;, &quot;up&quot;, &quot;down&quot;, &quot;in&quot;, &quot;out&quot;, &quot;on&quot;, &quot;off&quot;, &quot;over&quot;,\</span><br><span class="line">&quot;under&quot;, &quot;again&quot;, &quot;further&quot;, &quot;then&quot;, &quot;once&quot;, &quot;here&quot;, &quot;there&quot;, &quot;when&quot;, &quot;where&quot;, &quot;why&quot;, &quot;how&quot;, &quot;all&quot;,\</span><br><span class="line">&quot;any&quot;, &quot;both&quot;, &quot;each&quot;, &quot;few&quot;, &quot;more&quot;, &quot;most&quot;, &quot;other&quot;, &quot;some&quot;, &quot;such&quot;, &quot;no&quot;, &quot;nor&quot;, &quot;not&quot;, &quot;only&quot;, &quot;own&quot;,\</span><br><span class="line">&quot;same&quot;, &quot;so&quot;, &quot;than&quot;, &quot;too&quot;, &quot;very&quot;, &quot;s&quot;, &quot;t&quot;, &quot;can&quot;, &quot;will&quot;, &quot;just&quot;, &quot;don&quot;, &quot;don&apos;t&quot;, &quot;should&quot;, &quot;should&apos;ve&quot;,\</span><br><span class="line">&quot;now&quot;, &quot;d&quot;, &quot;ll&quot;, &quot;m&quot;, &quot;o&quot;, &quot;re&quot;, &quot;ve&quot;, &quot;y&quot;, &quot;ain&quot;, &quot;aren&quot;, &quot;aren&apos;t&quot;, &quot;couldn&quot;, &quot;couldn&apos;t&quot;, &quot;didn&quot;,\</span><br><span class="line">&quot;didn&apos;t&quot;, &quot;doesn&quot;, &quot;doesn&apos;t&quot;, &quot;hadn&quot;, &quot;hadn&apos;t&quot;, &quot;hasn&quot;, &quot;hasn&apos;t&quot;, &quot;haven&quot;, &quot;haven&apos;t&quot;, &quot;isn&quot;, &quot;isn&apos;t&quot;,\</span><br><span class="line">&quot;ma&quot;, &quot;mightn&quot;, &quot;mightn&apos;t&quot;, &quot;mustn&quot;, &quot;mustn&apos;t&quot;, &quot;needn&quot;, &quot;needn&apos;t&quot;, &quot;shan&quot;, &quot;shan&apos;t&quot;, &quot;shouldn&quot;, &quot;shouldn&apos;t&quot;,\</span><br><span class="line">&quot;wasn&quot;, &quot;wasn&apos;t&quot;, &quot;weren&quot;, &quot;weren&apos;t&quot;, &quot;won&quot;, &quot;won&apos;t&quot;, &quot;wouldn&quot;, &quot;wouldn&apos;t&quot;, &quot;without&quot; &#125;;</span><br><span class="line">int len = sizeof(stopwords) / sizeof(string);</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">keyword_in[stopwords[i]] = 1;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool Check(string keyword)</span><br><span class="line">&#123;</span><br><span class="line">if (keyword_in[keyword] == 1) return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void DblpGenerate(char* file_in, char* ungraph_out, char* vertex_out, char* original_out)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">PWgtNet Net = TWgtNet::New();</span><br><span class="line">TWgtNet DBL;</span><br><span class="line">const TStr db = &quot;./DataSets/dblp.xml&quot;;</span><br><span class="line">DBL.LoadDblpCoAuth(&quot;ds&quot;);</span><br><span class="line">DBL.LoadDblpCoAuth(db);</span><br><span class="line">TDblpLoader *dblp = new TDblpLoader(TStr(&quot;./DataSets/dblp.xml&quot;));</span><br><span class="line">*/</span><br><span class="line">cout &lt;&lt; &quot;Start Process dblp Dataset.....&quot; &lt;&lt; endl;</span><br><span class="line">TDblpLoader dblp(file_in);</span><br><span class="line">dblp.GetFPosStr();</span><br><span class="line">int authorCount = 1;</span><br><span class="line">map&lt;string, int&gt; author_vertex;  //方便hash查找，从1开始，默认是0.  存储作者对应的顶点</span><br><span class="line">map&lt;string, vector&lt;string&gt; &gt; author_attributes;  //存储作者的全部属性</span><br><span class="line"></span><br><span class="line">int cnt = 0;</span><br><span class="line">InvalidKeyword();</span><br><span class="line">FILE* fout_ungraph = fopen(ungraph_out, &quot;w&quot;);</span><br><span class="line">vector&lt;string&gt; keywords;</span><br><span class="line">vector&lt;int&gt; nodes;</span><br><span class="line">PUNGraph graph = PUNGraph::New();  //添加图是为了去重边</span><br><span class="line">while (dblp.Next()) &#123;</span><br><span class="line">if (cnt++ % 10000 == 0) cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; dblp.Year &lt;&lt; endl;</span><br><span class="line">string titleName = dblp.Title.CStr();</span><br><span class="line"></span><br><span class="line">// 20190619改：利用最后是否为句号来去掉home page字段</span><br><span class="line">if (titleName[titleName.size() - 1] != &apos;.&apos;) continue;</span><br><span class="line"></span><br><span class="line">titleName[titleName.size() - 1] = &apos;\0&apos;;  //去掉末尾的句号</span><br><span class="line">//cout &lt;&lt; titleName &lt;&lt; endl;</span><br><span class="line">keywords.clear();</span><br><span class="line">SplitStr(titleName, keywords, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">nodes.clear();</span><br><span class="line">for (int i = 0; i &lt; dblp.AuthorV.Len(); i++) &#123;    //当前文章的所有作者</span><br><span class="line">string authorName = dblp.AuthorV[i].CStr();</span><br><span class="line">//cout &lt;&lt; authorName &lt;&lt; endl;</span><br><span class="line">if (author_vertex[authorName] == 0) &#123;  //如果当前作者第一次出现，给他分配一个顶点值</span><br><span class="line">graph-&gt;AddNode(authorCount);</span><br><span class="line">author_vertex[authorName] = authorCount++;</span><br><span class="line">&#125;</span><br><span class="line">nodes.push_back(author_vertex[authorName]);</span><br><span class="line">for (string keyword : keywords) &#123;</span><br><span class="line">if (keyword != &quot; &quot; &amp;&amp; keyword != &quot;&quot;) &#123;</span><br><span class="line">if (Check(keyword)) &#123;</span><br><span class="line">//cout &lt;&lt; keyword &lt;&lt; endl;</span><br><span class="line">author_attributes[authorName].push_back(keyword);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (nodes.size() &gt; 1) &#123;</span><br><span class="line">for (int i : nodes) &#123;</span><br><span class="line">for (int j : nodes) &#123;</span><br><span class="line">if (i != j) &#123;  // 去掉自环边</span><br><span class="line">//if (!graph-&gt;IsEdge(i, j)) &#123;   // 去掉了重边</span><br><span class="line">fprintf(fout_ungraph, &quot;%d\t%d\n&quot;, i, j);</span><br><span class="line">//graph-&gt;AddEdge(i, j);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">graph.Clr();</span><br><span class="line">cout &lt;&lt; &quot;作者数量 = &quot; &lt;&lt; author_vertex.size() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; author_attributes.size() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;dblp_author_ungraph.txt over!&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">FILE* fout = fopen(vertex_out, &quot;w&quot;);</span><br><span class="line">map&lt;string, int&gt;::iterator it = author_vertex.begin();</span><br><span class="line">for (; it != author_vertex.end(); it++) &#123;</span><br><span class="line">fprintf(fout, &quot;%s&quot;, it-&gt;first.data());</span><br><span class="line">fprintf(fout, &quot;\t&quot;);</span><br><span class="line">fprintf(fout, &quot;%d\n&quot;, it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;dblp_author_vertex.txt over!&quot; &lt;&lt; endl;</span><br><span class="line">/*</span><br><span class="line">map&lt;string, int&gt; topAttributes;</span><br><span class="line">map&lt;string, vector&lt;string&gt; &gt; author_attrs;  //最好筛选出来的前20属性数据集</span><br><span class="line">for (map&lt;string, vector&lt;string&gt; &gt;::iterator it = author_attributes.begin(); it != author_attributes.end(); it++) &#123;</span><br><span class="line">//if (it-&gt;second.size() &lt;= 20) &#123;   //可能里面有重复的</span><br><span class="line">//author_attrs[it-&gt;first].assign(it-&gt;second.begin(), it-&gt;second.end());</span><br><span class="line">//continue;</span><br><span class="line">//&#125;</span><br><span class="line">topAttributes.clear();</span><br><span class="line">for (string attr : it-&gt;second) &#123;</span><br><span class="line">topAttributes[attr]++;</span><br><span class="line">&#125;</span><br><span class="line">//把map中元素转存到vector中</span><br><span class="line">vector&lt;PAIR&gt; topAttributes_vec(topAttributes.begin(), topAttributes.end());</span><br><span class="line"></span><br><span class="line">//对vector排序</span><br><span class="line">sort(topAttributes_vec.begin(), topAttributes_vec.end(), CmpByValue());</span><br><span class="line">for (int i = 0; i &lt; topAttributes_vec.size() &amp;&amp; i &lt; 20; i++) &#123;  //限制条件前20条，问题在于没有做词形还原，有点无意义</span><br><span class="line">author_attrs[it-&gt;first].push_back(topAttributes_vec[i].first);</span><br><span class="line">&#125;</span><br><span class="line">topAttributes_vec.clear();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">//对上面注释进行修改，先做词形还原，然后进行频繁排序，所以会把所有的属性存储下来，会很大</span><br><span class="line">FILE* fout_attrs = fopen(original_out, &quot;w&quot;);</span><br><span class="line">//map&lt;string, vector&lt;string&gt; &gt;::iterator itor = author_attrs.begin();</span><br><span class="line">map&lt;string, vector&lt;string&gt; &gt;::iterator itor = author_attributes.begin();</span><br><span class="line">for (; itor != author_attributes.end(); itor++) &#123;</span><br><span class="line">string authorName = itor-&gt;first;</span><br><span class="line">fprintf(fout_attrs, &quot;%d&quot;, author_vertex[authorName]);  // %-20s字符串左对齐占20个字符位置</span><br><span class="line">fprintf(fout_attrs, &quot;\t&quot;);</span><br><span class="line">bool flag = false;</span><br><span class="line">for (string str : itor-&gt;second) &#123;</span><br><span class="line">//if (str == &quot;&quot; || str == &quot; &quot;) continue;</span><br><span class="line">if (!flag) &#123;</span><br><span class="line">flag = true;</span><br><span class="line">fprintf(fout_attrs, &quot;%s&quot;, str.data());</span><br><span class="line">&#125;</span><br><span class="line">else fprintf(fout_attrs, &quot;,%s&quot;, str.data());</span><br><span class="line">&#125;</span><br><span class="line">fprintf(fout_attrs, &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;dblp_author_attr_original.txt over!&quot; &lt;&lt; endl;</span><br><span class="line">fclose(fout);</span><br><span class="line">fclose(fout_ungraph);</span><br><span class="line">fclose(fout_attrs);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6160001</span><br><span class="line">6170001</span><br><span class="line">作者数量 = 2081308</span><br><span class="line">2081295</span><br><span class="line">dblp_author_ungraph.txt over!</span><br><span class="line">dblp_author_vertex.txt over!</span><br><span class="line">dblp_author_attr_original.txt over!</span><br><span class="line">Generate Time:892.714000 s</span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>dblp_attr_original.txt   759M<br>dblp_ungraph.txt         504M<br>dblp_vertex.txt            47.3M</p><h2 id="2、去重边去自环边"><a href="#2、去重边去自环边" class="headerlink" title="2、去重边去自环边"></a>2、去重边去自环边</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char* input = &quot;dblp_ungraph.txt&quot;;</span><br><span class="line">    char* output = &quot;dblp100%_vertices.txt&quot;;</span><br><span class="line">    FILE* fin = fopen(input, &quot;r&quot;);</span><br><span class="line">    FILE* fout = fopen(output, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;input = &quot; &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;output = &quot; &lt;&lt; output &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Process Data....&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;pair&lt;int, int&gt; &gt; edges;</span><br><span class="line">    int maxn_vertex = -1;</span><br><span class="line">    int u, v, cnt = 0;</span><br><span class="line">while(!feof(fin)) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">fscanf(fin, &quot;%d\t%d\n&quot;, &amp;u, &amp;v);</span><br><span class="line">if(u &gt; v) swap(u, v);</span><br><span class="line">if(u != v) &#123;</span><br><span class="line">            edges.insert(make_pair(u, v));</span><br><span class="line">            if(v &gt; maxn_vertex) maxn_vertex = v;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt % 1000000 == 0) cout &lt;&lt; &quot;已完成&quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">for(auto edge : edges) &#123;</span><br><span class="line">        fprintf(fout, &quot;%d\t%d\n&quot;, edge.first, edge.second);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;原来图边的数量 = &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;处理后边的数量 = &quot; &lt;&lt; edges.size() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;最大的顶点值 = &quot; &lt;&lt; maxn_vertex &lt;&lt; endl;</span><br><span class="line">fclose(fin);</span><br><span class="line">fclose(fout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如题目，处理过后效果明显，504M-&gt;141M<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已完成34000000</span><br><span class="line">已完成35000000</span><br><span class="line">原来图边的数量 = 35205510</span><br><span class="line">处理后边的数量 = 9735108</span><br><span class="line">最大的顶点值 = 2081308</span><br></pre></td></tr></table></figure></p><h2 id="3、词形还原"><a href="#3、词形还原" class="headerlink" title="3、词形还原"></a>3、词形还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Mon Apr  9 22:02:33 2018</span><br><span class="line"></span><br><span class="line">@author: HanKin</span><br><span class="line"></span><br><span class="line">[Python nltk.WordNetLemmatizer() Examples](https://www.programcreek.com/python/example/81649/nltk.WordNetLemmatizer)</span><br><span class="line">词干提取和词形还原</span><br><span class="line">[在线词形还原](http://text-processing.com/demo/stem/)</span><br><span class="line">[nltk教程](http://textminingonline.com/dive-into-nltk-part-iv-stemming-and-lemmatization)</span><br><span class="line">https://www.cnblogs.com/itdyb/p/5914467.html</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import nltk</span><br><span class="line">from nltk.stem import WordNetLemmatizer </span><br><span class="line">from nltk.corpus import stopwords</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def crawl_lemmas(vocab):</span><br><span class="line">        &quot;&quot;&quot;Add Wordnet lemmas as definitions.&quot;&quot;&quot;</span><br><span class="line">        spwords=stopwords.words(&apos;english&apos;)</span><br><span class="line">        lemmatizer = nltk.WordNetLemmatizer()</span><br><span class="line">        ret = []</span><br><span class="line">        for word in vocab:</span><br><span class="line">            if len(word) &lt; 2:</span><br><span class="line">                continue</span><br><span class="line">            definitions = []</span><br><span class="line">            word = word.lower() # 变小写</span><br><span class="line">            try:</span><br><span class="line">                for part_of_speech in [&apos;a&apos;, &apos;s&apos;, &apos;r&apos;, &apos;n&apos;, &apos;v&apos;]:</span><br><span class="line">                    lemma = lemmatizer.lemmatize(word, part_of_speech)</span><br><span class="line">                    if lemma != word and not lemma in definitions:</span><br><span class="line">                        if lemma not in spwords:</span><br><span class="line">                            definitions.append(lemma)</span><br><span class="line">                            #print(lemma)</span><br><span class="line">                if len(definitions) == 0:</span><br><span class="line">                    #print(word)</span><br><span class="line">                    definitions.append(word)</span><br><span class="line">            except:</span><br><span class="line">                print(&apos;lemmatizer crashed&apos;)</span><br><span class="line">            if definitions:</span><br><span class="line">                #self._data[word] = definitions</span><br><span class="line">                for num in definitions:</span><br><span class="line">                    ret.append(num)</span><br><span class="line">        return ret</span><br><span class="line">        #self.save()</span><br><span class="line">        </span><br><span class="line">def file_open(filename):</span><br><span class="line">    with open(filename, &apos;r&apos;) as file_to_read:</span><br><span class="line">        #print(file_to_read.encoding) #文件编码</span><br><span class="line">        #print(file_to_read.mode) #打开模式</span><br><span class="line">        print(file_to_read.name) #文件名</span><br><span class="line">        while True:</span><br><span class="line">            line = file_to_read.readline()</span><br><span class="line">            if not line: break</span><br><span class="line">            content = line.split(&apos;\t&apos;)</span><br><span class="line">            print(content)</span><br><span class="line">        pass #Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</span><br><span class="line">    #当你在编写一个程序时，执行语句部分思路还没有完成，这时你可以用pass语句来占位，也可以当做是一个标记，是要过后来完成的代码。</span><br><span class="line">    #file_to_read.close()  python的with语句能处理异常并且会自动关闭文件句柄</span><br><span class="line">    </span><br><span class="line">def dblp_process(file_in, file_out):</span><br><span class="line">    with open(file_out, &apos;w&apos;) as fout:</span><br><span class="line">        with open(file_in, &apos;r&apos;) as fin:</span><br><span class="line">            print(&apos;fin: &apos; + fin.name)</span><br><span class="line">            print(&apos;fout: &apos; + fout.name)</span><br><span class="line">            print(&apos;start lemmas......&apos;)</span><br><span class="line">            schedule = 0;</span><br><span class="line">            while True:</span><br><span class="line">                line = fin.readline()</span><br><span class="line">                if not line: break</span><br><span class="line">                #print(line)</span><br><span class="line">                content = line.split(&apos;\t&apos;)</span><br><span class="line">                fout.write(content[0] + &apos;\t&apos;)  # content[0]表示顶点</span><br><span class="line">                #print(len(content))</span><br><span class="line">                #print(content[1])</span><br><span class="line">                #print(content[1][:-1])</span><br><span class="line">                content[1] = content[1][:-1]</span><br><span class="line">                content = content[1].split(&apos;,&apos;)</span><br><span class="line">                #print(&apos;hejian&apos;)</span><br><span class="line">                content = crawl_lemmas(content)</span><br><span class="line">                #print(type(content))</span><br><span class="line">                #print(content)</span><br><span class="line">                </span><br><span class="line">                dic = &#123;&#125;</span><br><span class="line">                for attr in content:</span><br><span class="line">                    if attr in dic:</span><br><span class="line">                        dic[attr] += 1</span><br><span class="line">                    else:</span><br><span class="line">                        dic[attr] = 1</span><br><span class="line">                dic = sorted(dic.items(),key = lambda x:x[1],reverse = True)</span><br><span class="line">                </span><br><span class="line">                flag = True  #处理末尾不添加逗号</span><br><span class="line">                cnt = 0</span><br><span class="line">                for key, val in dic:</span><br><span class="line">                    if cnt == 20: break    #选取前20频繁属性</span><br><span class="line">                    cnt += 1</span><br><span class="line">                    if flag:</span><br><span class="line">                        fout.write(key)</span><br><span class="line">                        flag = False</span><br><span class="line">                    else:</span><br><span class="line">                        fout.write(&apos;,&apos; + key)</span><br><span class="line">                fout.write(&apos;\n&apos;)</span><br><span class="line">                schedule += 1</span><br><span class="line">                if schedule % 10000 == 0: </span><br><span class="line">                    print(schedule)      #显示进度</span><br><span class="line"> </span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">2019.1.10 添加进度条</span><br><span class="line">          去掉长度为1的属性单词(crawl_lemmas函数)  </span><br><span class="line">&apos;&apos;&apos;               </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    lis = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;d&apos;, &apos;c&apos;, &apos;a&apos;]</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    for elem in lis:</span><br><span class="line">        if elem in dic:</span><br><span class="line">            dic[elem] += 1</span><br><span class="line">        else:</span><br><span class="line">            dic[elem] = 1</span><br><span class="line">    print(sorted(dic.items(),key = lambda x:x[1],reverse = True))</span><br><span class="line">    dic = sorted(dic.items(),key = lambda x:x[1],reverse = True)</span><br><span class="line">    for key, val in dic:</span><br><span class="line">        print(key + &apos; &apos; + str(val))</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    </span><br><span class="line">    sestence = &apos;Stemming is funnier than a bummer says the sushi loving computer scientist doing nets are crying parsing problem affix grammars best better does were&apos;</span><br><span class="line">    words = sestence.split(&apos; &apos;)</span><br><span class="line">    #words = [&apos;stemming&apos;]</span><br><span class="line">    #print(words)</span><br><span class="line">    #crawl_lemmas(words)</span><br><span class="line">    </span><br><span class="line">    #NLTK词性tag含义https://blog.csdn.net/john159151/article/details/50255101</span><br><span class="line">    #print(nltk.help.upenn_tagset())</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    dblp_process(&apos;dblp_attr_original.txt&apos;, &apos;dblp_nltk_attributes.txt&apos;)</span><br><span class="line">    #dblp_process(&apos;fin.txt&apos;, &apos;fout.txt&apos;)</span><br><span class="line">    print(&apos;total time = %lf s&apos; %(time.time() - start_time)) </span><br><span class="line">    </span><br><span class="line">    #nltk.WordNetLemmatizer().lemmatize(&apos;mapping&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2060000</span><br><span class="line">2070000</span><br><span class="line">2080000</span><br><span class="line">total time = 2029.313343 s</span><br></pre></td></tr></table></figure><h2 id="检查词形还原后的结果"><a href="#检查词形还原后的结果" class="headerlink" title="检查词形还原后的结果"></a>检查词形还原后的结果</h2><p>包含自建字典，修改python没有修正过来的单词，如subfigures。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void SplitString(const string&amp; s, vector&lt;string&gt;&amp; v, const string&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">string::size_type pos1, pos2;</span><br><span class="line">pos2 = s.find(c);</span><br><span class="line">pos1 = 0;</span><br><span class="line">while (string::npos != pos2) &#123;</span><br><span class="line">v.push_back(s.substr(pos1, pos2 - pos1));</span><br><span class="line">pos1 = pos2 + c.size();</span><br><span class="line">pos2 = s.find(c, pos1);</span><br><span class="line">&#125;</span><br><span class="line">if (pos1 != s.length()) v.push_back(s.substr(pos1));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetPostfix(const char* fileName)</span><br><span class="line">&#123;</span><br><span class="line">int index = 1;</span><br><span class="line">FILE *attributeF = fopen(fileName, &quot;r&quot;);</span><br><span class="line">FILE *out = fopen(&quot;out.txt&quot;, &quot;w&quot;);</span><br><span class="line">while (!feof(attributeF)) &#123;</span><br><span class="line">    index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fscanf(attributeF, &quot;%d\t%s\n&quot;, &amp;node, &amp;attr);</span><br><span class="line">fprintf(out, &quot;%d\t&quot;, node);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">string str = string(attr);</span><br><span class="line">if (str.size() == 0) continue;</span><br><span class="line">SplitString(str, vec, &quot;,&quot;);</span><br><span class="line">for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            int len = vec[i].size();</span><br><span class="line">            if (vec[i][len - 1] == &apos;s&apos;) &#123;</span><br><span class="line">                fprintf(out, &quot;%s,&quot;, vec[i].data());</span><br><span class="line">            &#125;</span><br><span class="line">            else if (len &gt; 1 &amp;&amp; vec[i][len - 1] == &apos;d&apos; &amp;&amp; vec[i][len - 2] == &apos;e&apos;) &#123;</span><br><span class="line">                fprintf(out, &quot;%s,&quot;, vec[i].data());</span><br><span class="line">            &#125;</span><br><span class="line">            else if (len &gt; 2 &amp;&amp; vec[i][len - 1] == &apos;g&apos; &amp;&amp; vec[i][len - 2] == &apos;n&apos; &amp;&amp; vec[i][len - 3] == &apos;i&apos;) &#123;</span><br><span class="line">                fprintf(out, &quot;%s,&quot;, vec[i].data());</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">fprintf(out, &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fclose(attributeF);</span><br><span class="line">fclose(out);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;string, int&gt; attrCnt;</span><br><span class="line"></span><br><span class="line">void Vertex_Attribute(const char* fileName, const char* outFileName)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 1;</span><br><span class="line">FILE *attributeF = fopen(fileName, &quot;r&quot;);</span><br><span class="line">while (!feof(attributeF)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fscanf(attributeF, &quot;%d\t%s\n&quot;, &amp;node, &amp;attr);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">string str = string(attr);</span><br><span class="line">if (str.size() == 0) continue;</span><br><span class="line">SplitString(str, vec, &quot;,&quot;);</span><br><span class="line">for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            attrCnt[vec[i]]++;   // 计数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    index = 1;</span><br><span class="line">FILE *in = fopen(fileName, &quot;r&quot;);</span><br><span class="line">FILE *out = fopen(outFileName, &quot;w&quot;);</span><br><span class="line">while (!feof(in)) &#123;</span><br><span class="line">    index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; &quot;进度=&quot; &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fscanf(in, &quot;%d\t%s\n&quot;, &amp;node, &amp;attr);</span><br><span class="line">fprintf(out, &quot;%d\t&quot;, node);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">string str = string(attr);</span><br><span class="line">if (str.size() == 0) continue;</span><br><span class="line">SplitString(str, vec, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; ss;</span><br><span class="line">for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            int len = vec[i].size();</span><br><span class="line">            string tmp = vec[i];</span><br><span class="line">            if (vec[i][len - 1] == &apos;s&apos;) &#123;  // 自建字典，如果去掉s的2倍数量大于加s的单词就删除s</span><br><span class="line">                string s = vec[i].substr(0, len - 1);</span><br><span class="line">                if (attrCnt[s] * 2 &gt; attrCnt[vec[i]]) tmp = s;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (len &gt; 1 &amp;&amp; vec[i][len - 1] == &apos;d&apos; &amp;&amp; vec[i][len - 2] == &apos;e&apos;) &#123;</span><br><span class="line">                string s = vec[i].substr(0, len - 2);</span><br><span class="line">                if (attrCnt[s] * 2 &gt; attrCnt[vec[i]]) tmp = s;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (len &gt; 2 &amp;&amp; vec[i][len - 1] == &apos;g&apos; &amp;&amp; vec[i][len - 2] == &apos;n&apos; &amp;&amp; vec[i][len - 3] == &apos;i&apos;) &#123;</span><br><span class="line">                string s = vec[i].substr(0, len - 3);</span><br><span class="line">                if (attrCnt[s] * 2 &gt; attrCnt[vec[i]]) tmp = s;</span><br><span class="line">            &#125;</span><br><span class="line">            ss.insert(tmp);</span><br><span class="line">&#125;</span><br><span class="line">bool flag = true;</span><br><span class="line">for (string i : ss) &#123;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                fprintf(out, &quot;%s&quot;, i.data());</span><br><span class="line">            &#125;</span><br><span class="line">            else fprintf(out, &quot;,%s&quot;, i.data());</span><br><span class="line">&#125;</span><br><span class="line">fprintf(out, &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fclose(in);</span><br><span class="line">fclose(out);</span><br><span class="line">fclose(attributeF);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComputeFrequency(const char* fileName, const char* outFileName)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    double tmp;</span><br><span class="line">    int index = 0;</span><br><span class="line">FILE *attributeF = fopen(fileName, &quot;r&quot;);</span><br><span class="line">while (!feof(attributeF)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fscanf(attributeF, &quot;%d\t%s\n&quot;, &amp;node, &amp;attr);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">string str = string(attr);</span><br><span class="line">if (str.size() == 0) continue;</span><br><span class="line">SplitString(str, vec, &quot;,&quot;);</span><br><span class="line">int len = vec.size();</span><br><span class="line">sum += len;</span><br><span class="line"></span><br><span class="line">// ???单个顶点有重复的属性</span><br><span class="line">map&lt;string, int&gt; flag;</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            attrCnt[vec[i]]++;   // 计数</span><br><span class="line">            flag[vec[i]]++;</span><br><span class="line">            if (flag[vec[i]] &gt;= 2) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;顶点出现重复属性：&quot; &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    set&lt;pair&lt;int, string&gt;, greater&lt;pair&lt;int, string&gt; &gt; &gt; SET;</span><br><span class="line">    for (map&lt;string, int&gt;::iterator it = attrCnt.begin(); it != attrCnt.end(); it++) &#123;</span><br><span class="line">        SET.emplace(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt = SET.size();</span><br><span class="line">    FILE *out = fopen(outFileName, &quot;w&quot;);</span><br><span class="line">    tmp = sum * 1.0 / index;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    fprintf(out, &quot;顶点数量=%d\t属性总数量=%d\t平均数量=%.3f\t属性数量=%d\n&quot;, index, sum, tmp, cnt);</span><br><span class="line">    fprintf(out, &quot;\n属性\t出现次数\t占比例\n&quot;);</span><br><span class="line">    for (set&lt;pair&lt;int, string&gt; &gt;::iterator it = SET.begin(); it != SET.end(); it++) &#123;</span><br><span class="line">        //cout &lt;&lt; it-&gt;second &lt;&lt; &apos; &apos; &lt;&lt; it-&gt;first &lt;&lt; endl;</span><br><span class="line">        tmp = it-&gt;first * 1.0 / index;</span><br><span class="line">        fprintf(out, &quot;%s\t%d\t%.3f\n&quot;, (it-&gt;second).data(), it-&gt;first, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">fclose(out);</span><br><span class="line">fclose(attributeF);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Transform2Int(const char* fileName, const char* outFileName1, const char* outFileName2)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 1, attr_index = 1;  // 从1开始好些，0可以当作无</span><br><span class="line">    map&lt;string, int&gt; attribute_index;</span><br><span class="line">FILE *attributeF = fopen(fileName, &quot;r&quot;);</span><br><span class="line">FILE *out1 = fopen(outFileName1, &quot;w&quot;);</span><br><span class="line">while (!feof(attributeF)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        if (index % 100000 == 0) cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fscanf(attributeF, &quot;%d\t%s\n&quot;, &amp;node, &amp;attr);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">string str = string(attr);</span><br><span class="line">if (str.size() == 0) continue;</span><br><span class="line">SplitString(str, vec, &quot;,&quot;);</span><br><span class="line">int len = vec.size();</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            //把str转换成int</span><br><span class="line">            if (attribute_index[vec[i]] == 0) &#123;</span><br><span class="line">                attribute_index[vec[i]] = attr_index;</span><br><span class="line">                fprintf(out1, &quot;%s\t%d\n&quot;, vec[i].data(), attr_index);</span><br><span class="line">                attr_index++;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    index = 1;</span><br><span class="line">FILE *in = fopen(fileName, &quot;r&quot;);</span><br><span class="line">FILE *out2 = fopen(outFileName2, &quot;w&quot;);</span><br><span class="line">while (!feof(in)) &#123;</span><br><span class="line">    index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; &quot;进度=&quot; &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fscanf(in, &quot;%d\t%s\n&quot;, &amp;node, &amp;attr);</span><br><span class="line">fprintf(out2, &quot;%d\t&quot;, node);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">string str = string(attr);</span><br><span class="line">if (str.size() == 0) continue;</span><br><span class="line">SplitString(str, vec, &quot;,&quot;);</span><br><span class="line">bool flag = true;</span><br><span class="line">for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                fprintf(out2, &quot;%d&quot;, attribute_index[vec[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            else fprintf(out2, &quot;,%d&quot;, attribute_index[vec[i]]);</span><br><span class="line">&#125;</span><br><span class="line">fprintf(out2, &quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fclose(in);</span><br><span class="line">fclose(out1);</span><br><span class="line">fclose(out2);</span><br><span class="line">fclose(attributeF);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;string, int&gt; psi;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, const psi&amp; p) &#123;</span><br><span class="line">  return out &lt;&lt; p.first &lt;&lt; &quot;\t&quot; &lt;&lt; p.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(psi a, psi b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Debug(const char* inFileName, const char* outFileName)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">FILE *in = fopen(inFileName, &quot;r&quot;);</span><br><span class="line">FILE *out = fopen(outFileName, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">while (!feof(in)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fgets(attr, 20005, in);</span><br><span class="line">//cout &lt;&lt; attr &lt;&lt; &apos; &apos; &lt;&lt; strlen(attr) &lt;&lt; endl;  // 长度包含空格和换行符</span><br><span class="line">if (strlen(attr) &gt; 9) &#123;   // 本身顶点长度为7，空格，换行符</span><br><span class="line">            fputs(attr, out);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">            cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(in);</span><br><span class="line">fclose(out);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 去掉无属性的顶点</span><br><span class="line">    //const char* fileName1 = &quot;dblp_nltk_attributes.txt&quot;;</span><br><span class="line">    //const char* fileName2 = &quot;out.txt&quot;;</span><br><span class="line">    //Debug(fileName1, fileName2);</span><br><span class="line">    //return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    const char* fileName = &quot;dblp_nltk_attributes.txt&quot;;</span><br><span class="line">    const char* outFileName = &quot;dblp_attributes.txt&quot;;</span><br><span class="line">    const char* freFileName = &quot;frequency.txt&quot;;</span><br><span class="line">    const char* transFileName1 = &quot;dblp_String2Int.txt&quot;;</span><br><span class="line">    const char* transFileName2 = &quot;dblp_attributes_int.txt&quot;;</span><br><span class="line">    Vertex_Attribute(fileName, outFileName);   // 自建字典检查s、ed、ing（20190623注意要去重复）</span><br><span class="line">    ComputeFrequency(outFileName, freFileName);   // 计算顶点属性频繁性</span><br><span class="line">    Transform2Int(outFileName, transFileName1, transFileName2);  // 转换int</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>出现文件读不完情况？？？居然是有个顶点没有一个属性造成的。<br>使用fgets和fputs判断字符长度不超过9的删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Debug(const char* inFileName, const char* outFileName)</span><br><span class="line">&#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">FILE *in = fopen(inFileName, &quot;r&quot;);</span><br><span class="line">FILE *out = fopen(outFileName, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">while (!feof(in)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        if (index % 10000 == 0) cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int node;</span><br><span class="line">char attr[20005];</span><br><span class="line">fgets(attr, 20005, in);</span><br><span class="line">//cout &lt;&lt; attr &lt;&lt; &apos; &apos; &lt;&lt; strlen(attr) &lt;&lt; endl;  // 长度包含空格和换行符</span><br><span class="line">if (strlen(attr) &gt; 9) &#123;   // 本身顶点长度为7，空格，换行符</span><br><span class="line">            fputs(attr, out);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">            cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(in);</span><br><span class="line">fclose(out);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进度=2070000</span><br><span class="line">进度=2080000</span><br><span class="line"></span><br><span class="line">Process returned 0 (0x0)   execution time : 414.761 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure><p>发现一个顶点有重复的属性在自建字典词形还原的时候出现这种情况。但处理的还不是完美，应该在python词形还原的时候不应该取前20，在这里取前20。时间紧迫，python处理大概需要半小时。</p><h2 id="运行，建立超图和属性关键字索引"><a href="#运行，建立超图和属性关键字索引" class="headerlink" title="运行，建立超图和属性关键字索引"></a>运行，建立超图和属性关键字索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">[hejian@sklse ETAttriOnLinux]$ ./main_by_hejian </span><br><span class="line">HanKin.build: 16:16:09, Jun 23 2019. Time: 16:16:29 [Dec 13 2017]</span><br><span class="line">=================================================================</span><br><span class="line">usage: main_by_hejian</span><br><span class="line"></span><br><span class="line">&lt;&lt;紧密子图查询(基于k-truss的属性网络社区发现和搜索)&gt;&gt;</span><br><span class="line"></span><br><span class="line">###选择数据集###:</span><br><span class="line"> 1.dblp</span><br><span class="line"> 2.dbpedia</span><br><span class="line"> 3.yago</span><br><span class="line"> 4.tencent</span><br><span class="line"> 5.test </span><br><span class="line"></span><br><span class="line">请输入: 1</span><br><span class="line">*************预处理*************</span><br><span class="line">1、计算数据集的顶点平均度</span><br><span class="line">2、随机生成数据集的查询点</span><br><span class="line">3、随机生成数据集的顶点伸缩性</span><br><span class="line">4、随机生成数据集的属性伸缩性</span><br><span class="line">5、查看图数据信息</span><br><span class="line">6、其他(跳过)</span><br><span class="line">请输入: 23</span><br><span class="line">aRate =     1.00 vRate =     0.20</span><br><span class="line"> attrNumMax =          5 kValue = 6 </span><br><span class="line"></span><br><span class="line">请输入点占的范围比例(0-100):100</span><br><span class="line"></span><br><span class="line">==========1.Read Local Data File（建图）==========</span><br><span class="line">DataSet: ./DataSets/Graph/dblp100%_vertices.txt</span><br><span class="line">nodes = 1981567</span><br><span class="line">edges = 9735108</span><br><span class="line">Run Time:5.020000 s</span><br><span class="line"></span><br><span class="line">==========Start EquiTrussIndex==========</span><br><span class="line">==========2.Compute the Support of Edges==========</span><br><span class="line">Run Time:48.290000 s</span><br><span class="line"></span><br><span class="line">==========3.Compute the Trussness of Edges==========</span><br><span class="line">kMax = 287</span><br><span class="line">Node = 2 287</span><br><span class="line">Edge = 2 287</span><br><span class="line">Run Time:169.820000 s</span><br><span class="line"></span><br><span class="line">==========4.Index Construction for EquiTruss==========</span><br><span class="line">superNode&apos;s size:972699</span><br><span class="line">超点存储到本地完成！！！</span><br><span class="line">superEdge&apos;s size:1461225</span><br><span class="line">超边存储到本地完成！！！</span><br><span class="line">全局trussness存储到本地完成!!!</span><br><span class="line">超图点数 = 972699</span><br><span class="line">超图边数 = 1461225</span><br><span class="line">EquiTruss索引创建时间:359.810000 s</span><br><span class="line"></span><br><span class="line">顶点包含在超点映射时间:367.950000 s</span><br><span class="line"></span><br><span class="line">==========5.Community Search Based on AttributeSearch（准备搜索）==========</span><br><span class="line">==========5-1.Read Attribute Dataset File（读取属性到内存）==========</span><br><span class="line">DataSet: ./DataSets/Attribute/dblp_attributes_int.txt</span><br><span class="line">Run Time:585.270000 s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========5-2start find attribute truss（建立属性索引）...=====</span><br><span class="line">attr_max_id = 259969</span><br><span class="line">time = 2548.5s</span><br><span class="line"></span><br><span class="line">属性索引创建时间:2548.500000 s</span><br></pre></td></tr></table></figure><p>#<br>难受，以前因为没有后面的两种方法，所以选取设计的ATCImprove方法进行比较，想改缺没有时间了，就这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数据集出现一个顶点有重复属性：词形还原后没有去重&lt;/li&gt;
&lt;li&gt;异常的home和pag：查看xml发现会有作者的home p
      
    
    </summary>
    
      <category term="C/C++" scheme="https://hankin2015.github.io/categories/C-C/"/>
    
    
      <category term="C" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2019“锐捷网络杯”华中区高校研究生程序设计大赛</title>
    <link href="https://hankin2015.github.io/2019/06/03/ruijie2019/"/>
    <id>https://hankin2015.github.io/2019/06/03/ruijie2019/</id>
    <published>2019-06-03T08:47:41.000Z</published>
    <updated>2019-06-04T08:00:38.433Z</updated>
    
    <content type="html"><![CDATA[<p>毕业前最后的一次比赛，”锐捷网络杯“参加了三次，前两次均是三等奖。2018年因为自己没有理解到题意，错失了二等奖，得了三等奖中的第一名。这次比赛最终获得了第六名，还是不错吧（800，800，1500）。<br>一开始大家都在做第一道A题，题意很简单，但却是较最难的一道题，我最终在3个小时的时候才开始AC第一道题，还是12点钟临时加的（整体难度较大，添加2道简单的）。据说本次获奖的还能去福州公司参观，现场发证书和奖金，最快的一次。</p><a id="more"></a><p>赛后题目链接：<br><a href="http://acm.whu.edu.cn/olive/arena/6#/" target="_blank" rel="noopener">2017年第六届湖北省研究生程序设计竞赛</a><br><a href="https://acm.whu.edu.cn:8080/oj/woj/contest/23da2mgxnjyds2yi" target="_blank" rel="noopener">Eming Cup 2018</a><br><a href="https://acm.whu.edu.cn:8080/oj/woj/contest/23db4nbywcuaasfy" target="_blank" rel="noopener">2019研究生大赛</a><br>website:  <a href="http://hbppc.contest.codeforces.com" target="_blank" rel="noopener">http://hbppc.contest.codeforces.com</a><br>login:  hbppcteam063<br>password:   jRDh8p0g</p><h1 id="K-A-good-game"><a href="#K-A-good-game" class="headerlink" title="K. A good game"></a>K. A good game</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, m;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    for (int cnt = 1; cnt &lt;= T; cnt++) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        int arr[100005];</span><br><span class="line">        long long sum[100005];</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            //cin &gt;&gt; arr[i];</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;arr[i]);</span><br><span class="line">            sum[i] += arr[i] + sum[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        int tmp[100005];</span><br><span class="line">        for (long long i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            //cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            tmp[i] = sum[b] - sum[a - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp, tmp + m);</span><br><span class="line">        for (long long i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            ans = ans + tmp[i - 1] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Sequence"><a href="#F-Sequence" class="headerlink" title="F. Sequence"></a>F. Sequence</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, m;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    for (int cnt = 1; cnt &lt;= T; cnt++) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; cnt &lt;&lt; &apos;:&apos; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        int arr[100005];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i];</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            int x, y , z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            if (x == 0) &#123;</span><br><span class="line">                arr[y] = z;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                int ans = 0;</span><br><span class="line">                int tmp = z - y + 1;</span><br><span class="line">                if (tmp &amp; 1) &#123;</span><br><span class="line">                    int hj = 1;</span><br><span class="line">                    for (int j = y; j &lt;= z; j++) &#123;</span><br><span class="line">                        if (hj &amp; 1) ans = ans ^ arr[j];</span><br><span class="line">                        hj++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-Prefix"><a href="#J-Prefix" class="headerlink" title="J. Prefix"></a>J. Prefix</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    int d[26];</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) cin  &gt;&gt; d[i];</span><br><span class="line">    int maxn = 200005;</span><br><span class="line">    long long q[maxn];</span><br><span class="line">    map&lt;string, int&gt; COUNT, VALUE;</span><br><span class="line">    string s[100005];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        int len = s[i].size();</span><br><span class="line">        long long tmp = 1;</span><br><span class="line">        string str = &quot;&quot;;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            str += s[i][j];</span><br><span class="line">            tmp = (tmp * d[s[i][j] - &apos;a&apos;]) % m;</span><br><span class="line">            COUNT[str]++;</span><br><span class="line">            VALUE[str] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int len = s[i].size();</span><br><span class="line">        string str = &quot;&quot;;</span><br><span class="line">        for (int j = 0; j &lt; len - 1; j++) &#123;</span><br><span class="line">            str += s[i][j];</span><br><span class="line">            if (VALUE[str] &gt; q[i]) ans += COUNT[str];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-Winer"><a href="#G-Winer" class="headerlink" title="G. Winer"></a>G. Winer</h1><p>这道题也算是比较简单的一道题，然鹅一开始一直没有发现坑点，后来知道了，发现也没有时间了，建立DAG（有向五环图），然后进行搜索遍历。下面的代码是超时的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int number, value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">    return x.value &gt; y.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N, Q, tmp;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">    set&lt;int&gt; lose[100005];</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        node P[100005];</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            P[j].number = j + 1;</span><br><span class="line">            P[j].value = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(P, P + N, cmp);</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            for (int k = j + 1; k &lt; N; k++) &#123;</span><br><span class="line">                if (P[j].value != P[k].value) &#123;</span><br><span class="line">                    lose[P[j].number].insert(P[k].number);</span><br><span class="line">                    for (set&lt;int&gt;::iterator hj = lose[P[k].number].begin(); hj != lose[P[k].number].end(); hj++) &#123;</span><br><span class="line">                        lose[P[j].number].insert(*hj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; Q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        //cout &lt;&lt; lose[tmp].size() &lt;&lt; endl;</span><br><span class="line">        if (lose[tmp].size() &gt;= N - 1) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">3 3</span><br><span class="line">1 4 3</span><br><span class="line">2 1 5</span><br><span class="line">2 2 9</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><h1 id="A-A-Easy-Math-Problem"><a href="#A-A-Easy-Math-Problem" class="headerlink" title="A. A Easy Math Problem"></a>A. A Easy Math Problem</h1><p><a href="https://acm.whu.edu.cn:8080/oj/woj/contest/23db4nbywcuaasfy/problem/A" target="_blank" rel="noopener">https://acm.whu.edu.cn:8080/oj/woj/contest/23db4nbywcuaasfy/problem/A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕业前最后的一次比赛，”锐捷网络杯“参加了三次，前两次均是三等奖。2018年因为自己没有理解到题意，错失了二等奖，得了三等奖中的第一名。这次比赛最终获得了第六名，还是不错吧（800，800，1500）。&lt;br&gt;一开始大家都在做第一道A题，题意很简单，但却是较最难的一道题，我最终在3个小时的时候才开始AC第一道题，还是12点钟临时加的（整体难度较大，添加2道简单的）。据说本次获奖的还能去福州公司参观，现场发证书和奖金，最快的一次。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://hankin2015.github.io/categories/C-C/"/>
    
    
      <category term="C" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅的机器学习笔记</title>
    <link href="https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/"/>
    <id>https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/</id>
    <published>2019-04-21T02:47:41.000Z</published>
    <updated>2018-08-12T17:35:33.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html" target="_blank" rel="noopener">李宏毅机器学习深度学习资料</a><br><a href="https://www.bilibili.com/video/av10590361?from=search&amp;seid=8971112424275201304" target="_blank" rel="noopener">李宏毅2017机器学习视频</a><br><a href="https://www.52ml.net/" target="_blank" rel="noopener">我爱机器学习</a><br><a href="https://www.lintcode.com/" target="_blank" rel="noopener">周sir推荐lintcode</a><br><a href="https://www.jiqizhixin.com/articles/02111" target="_blank" rel="noopener">邓miss推荐李沫动手学深度学习</a></p><h1 id="1、Introduction-of-this-course"><a href="#1、Introduction-of-this-course" class="headerlink" title="1、Introduction of this course"></a>1、Introduction of this course</h1><p>人工智慧目标-》机器学习手段-》深度学习方法<br>之前的智慧：人类设定好的天生本能</p><ul><li>河狸生物的本能筑水坝</li><li>Chat_bot和漫画智能机器人多个if调侃AI<a id="more"></a><h2 id="3步Machine-Learning-is-so-simple-……"><a href="#3步Machine-Learning-is-so-simple-……" class="headerlink" title="3步Machine Learning is so simple ……"></a>3步Machine Learning is so simple ……</h2>Step 1: define a set of function<br>Step 2: goodness of function<br>Step 3: pick the best function<br>就好像吧大象放进冰箱……</li></ul><h2 id="Learning-Map-scenario-task-method"><a href="#Learning-Map-scenario-task-method" class="headerlink" title="Learning Map: scenario task method"></a>Learning Map: scenario task method</h2><ul><li>Supervised Learning<ul><li>Regression</li><li>Classification<ul><li>Linear Model</li><li>Non-linear Model<ul><li>Deep Learning</li><li>SVM, decision tree, K-NN …</li></ul></li></ul></li><li>Structured Learning</li></ul></li><li>Semi-supervised Learning</li><li>Transfer Learning</li><li>Unsupervised Learning</li><li>Reinforcement Learning</li></ul><h1 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h1><p>saddle point鞍点<br>local minima极点</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅机器学习深度学习资料&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.bilibili.com/video/av10590361?from=search&amp;amp;seid=8971112424275201304&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅2017机器学习视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.52ml.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我爱机器学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.lintcode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;周sir推荐lintcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/02111&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;邓miss推荐李沫动手学深度学习&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、Introduction-of-this-course&quot;&gt;&lt;a href=&quot;#1、Introduction-of-this-course&quot; class=&quot;headerlink&quot; title=&quot;1、Introduction of this course&quot;&gt;&lt;/a&gt;1、Introduction of this course&lt;/h1&gt;&lt;p&gt;人工智慧目标-》机器学习手段-》深度学习方法&lt;br&gt;之前的智慧：人类设定好的天生本能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;河狸生物的本能筑水坝&lt;/li&gt;
&lt;li&gt;Chat_bot和漫画智能机器人多个if调侃AI
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>小米 OJ 编程比赛 03 月常规赛</title>
    <link href="https://hankin2015.github.io/2019/04/02/20190402miOJ03/"/>
    <id>https://hankin2015.github.io/2019/04/02/20190402miOJ03/</id>
    <published>2019-04-02T02:47:41.000Z</published>
    <updated>2019-04-09T12:37:03.046Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.mi.com/contest/list/view?id=9" target="_blank" rel="noopener">小米 OJ 编程比赛 03 月常规赛</a></p><p>&lt;–more–&gt;</p><h1 id="1、数学等式"><a href="#1、数学等式" class="headerlink" title="1、数学等式"></a>1、数学等式</h1><p>给出5个系数，求等式的另外5个未知数，问有多少解？<br>巧枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">//#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cal(int n)</span><br><span class="line">&#123;</span><br><span class="line">return n * n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a, b, c, d, e;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;</span><br><span class="line">map&lt;int, int&gt; cnt;</span><br><span class="line">for (int i = -50; i &lt;= 50; i++) &#123;</span><br><span class="line">for (int j = -50; j &lt;= 50; j++) &#123;</span><br><span class="line">for (int k = -50; k &lt;= 50; k++) &#123;</span><br><span class="line">if (i * k * j != 0) &#123;</span><br><span class="line">int tmp = cal(i) * a + cal(j) * b + cal(k) * c;</span><br><span class="line">cnt[tmp]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">long long ans = 0;</span><br><span class="line">for (int i = -50; i &lt;= 50; i++) &#123;</span><br><span class="line">for (int j = -50; j &lt;= 50; j++) &#123;</span><br><span class="line">if (i * j != 0) &#123;</span><br><span class="line">int tmp = cal(i) * d + cal(j) * e;</span><br><span class="line">ans += cnt[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2、贪吃的细胞"><a href="#2、贪吃的细胞" class="headerlink" title="2、贪吃的细胞"></a>2、贪吃的细胞</h1><p>多点宽搜BFS，但是不明白哪里错了，自己感觉没有问题，错的也莫名其妙（后来终于有解答了）。<br>下面是别人AC的代码，感觉小米这个oj能看别人的代码这个功能不错。</p><p>针对 03 月 29 日晚「三月常规赛」第二题“贪吃的细胞”出错的情况，现给出如下说明：</p><p>由于题目“贪吃的细胞”出题、审题人及我们团队的疏忽，此题的数据及标程出现问题却未被发现，导致「三月常规赛」中第二题无法 AC，严重影响比赛体验。</p><p>在此，我们向所有参赛同学真诚道歉。我们深知，本次事件的原因在于尚不完善的志愿者机制及录题流程；我们将重新审视此机制，并尽我们最大努力保证题目的正确性及质量。</p><p>作为补偿，对于比赛期间已提交过第二题的同学，我们将补偿一定数量的 OJ 币，同时比赛奖品将正常发出，锦鲤奖也将按流程抽取。</p><p>最后，再次向同学们表示歉意。</p><p>小米 Online Judge 团队<br>2019 年 04 月 09 日<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入、输出结果中的换行符，已使用 &quot;;&quot; 代替</span><br><span class="line"></span><br><span class="line">用例输入: &quot;40;7 31;5.#s#.6..#1.#.#..85#1#..17#4##8;9##.76##8.#.5.2##9.##3###.67.9.;#14.#1.##...8#8...8.###.#.#....&quot;</span><br><span class="line">期望输出: &quot;-1;-1;3476;-1;-1;-1;-1;-1;-1;-1;-1;763;-1;-1;-1;-1;-1;-1;-1;-1;-1;405;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;...&quot;</span><br><span class="line">你的输出: &quot;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;-...&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">struct Node &#123;</span><br><span class="line">int x, y;</span><br><span class="line">Node(int a=0, int b=0) : x(a), y(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">第三题打个表输出 第n个数对应的斐波那契数列的下标 2 3 5 13 89 分别对应3 4 5 7 11 除了4 后面都是连续的素数 然后矩阵快速幂就可以了</span><br><span class="line"></span><br><span class="line">https://www.flyai.com/?s=pmgO8ng7J</span><br><span class="line">http://latex.91maths.com/</span><br><span class="line">*/</span><br><span class="line">typedef pair&lt;int, int&gt; Node;</span><br><span class="line">int maxn = 1e8;</span><br><span class="line">bool visited[105][105];</span><br><span class="line">map&lt;Node, Node&gt; befor;</span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;</span><br><span class="line">int n, m;</span><br><span class="line">char mat[105][105];</span><br><span class="line">int dis[105][105];</span><br><span class="line">int cell[105][105];</span><br><span class="line">int ans;</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">while (!Q.empty()) &#123;</span><br><span class="line">Node cur = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">int next_x = cur.first + dir[i][0], next_y = cur.second + dir[i][1];</span><br><span class="line">if (next_x &gt;= 0 &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; m &amp;&amp; next_x &lt; n &amp;&amp; !visited[next_x][next_y] &amp;&amp; mat[next_x][next_y] != &apos;#&apos;) &#123;</span><br><span class="line">Q.push(make_pair(next_x, next_y));</span><br><span class="line">visited[next_x][next_y] = 1;</span><br><span class="line">if (dis[next_x][next_y] &gt; dis[cur.first][cur.second] + 1) &#123;</span><br><span class="line">dis[next_x][next_y] = dis[cur.first][cur.second] + 1;</span><br><span class="line">befor[make_pair(next_x, next_y)] = befor[cur];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int x, y, d = maxn;</span><br><span class="line">//cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            //cout &lt;&lt; mat[i][j];</span><br><span class="line">if (mat[i][j] &gt;= &apos;0&apos; &amp;&amp; mat[i][j] &lt;= &apos;9&apos;) &#123;   // 当前有培养液</span><br><span class="line">if (dis[i][j] &lt; d) &#123;</span><br><span class="line">d = dis[i][j];</span><br><span class="line">x = i;</span><br><span class="line">y = j;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cout &lt;&lt; cell[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; &apos; &apos; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">*/</span><br><span class="line">if (d == maxn) return false;</span><br><span class="line">ans += d;</span><br><span class="line">int xx = befor[Node(x, y)].first, yy = befor[Node(x, y)].second;</span><br><span class="line">cell[xx][yy]--;</span><br><span class="line">cell[x][y] += mat[x][y] - &apos;0&apos; + 1;</span><br><span class="line">mat[x][y] = &apos;.&apos;;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while (T--) &#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">ans = 0;</span><br><span class="line">int liquid_cnt = 0;</span><br><span class="line">memset(cell, 0, sizeof(cell));</span><br><span class="line">memset(mat, 0, sizeof(mat));</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">cin &gt;&gt; mat[i][j];</span><br><span class="line">if (mat[i][j] &gt;= &apos;0&apos; &amp;&amp; mat[i][j] &lt;= &apos;9&apos;) liquid_cnt++;</span><br><span class="line">if (mat[i][j] == &apos;S&apos;) &#123;</span><br><span class="line">cell[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; liquid_cnt; i++) &#123;</span><br><span class="line">memset(visited, 0, sizeof(visited));</span><br><span class="line">befor.clear();</span><br><span class="line">for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">for (int k = 0; k &lt; m; k++) &#123;</span><br><span class="line">                    dis[j][k] = maxn;</span><br><span class="line">if (cell[j][k] &gt; 0) &#123;</span><br><span class="line">Q.push(Node(j, k));</span><br><span class="line">visited[j][k] = 1;</span><br><span class="line">dis[j][k] = 0;</span><br><span class="line">befor[Node(j, k)] = Node(j, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool flag = bfs();</span><br><span class="line">if (!flag) &#123;</span><br><span class="line">ans = -1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//pair&lt;int, int&gt;(2, 3) == make_pair(2, 3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1</span><br><span class="line">7 10</span><br><span class="line">2342312323</span><br><span class="line">..........</span><br><span class="line">S#########</span><br><span class="line">..........</span><br><span class="line">123.......</span><br><span class="line">..........</span><br><span class="line">123.......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 </span><br><span class="line">5 3 </span><br><span class="line">#1# </span><br><span class="line">1S1 </span><br><span class="line">#.# </span><br><span class="line">#.# </span><br><span class="line">#1#</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define max(a,b) (a&gt;b?a:b)</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=250005;</span><br><span class="line">struct node &#123;</span><br><span class="line">    int x,y,l;</span><br><span class="line">&#125;k[maxn];</span><br><span class="line">int t,m,n,lm,d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;</span><br><span class="line">char mm[105][105];</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">    k[lm].x=u;</span><br><span class="line">    k[lm].y=v;</span><br><span class="line">    k[lm].l=w;</span><br><span class="line">    lm++;</span><br><span class="line">&#125;</span><br><span class="line">void bfs(int s,int x,int y)&#123;</span><br><span class="line">    node a,b;</span><br><span class="line">    a.x=x,a.y=y,a.l=0;</span><br><span class="line">    int vis[105][105]=&#123;0&#125;;</span><br><span class="line">    vis[a.x][a.y]=1;</span><br><span class="line">    queue&lt;node&gt;qu;</span><br><span class="line">    qu.push(a);</span><br><span class="line">    while(!qu.empty())&#123;</span><br><span class="line">        a=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        if((mm[a.x][a.y]&gt;=&apos;1&apos;&amp;&amp;mm[a.x][a.y]&lt;=&apos;9&apos;)||mm[a.x][a.y]==&apos;S&apos;)&#123;</span><br><span class="line">            if(a.l)add(s,a.x*100+a.y,a.l);</span><br><span class="line">        &#125;</span><br><span class="line">        b.l=a.l+1;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            b.x=a.x+d[i][0];</span><br><span class="line">            b.y=a.y+d[i][1];</span><br><span class="line">            if(b.x&gt;=0&amp;&amp;b.x&lt;n&amp;&amp;b.y&gt;=0&amp;&amp;b.y&lt;m&amp;&amp;!vis[b.x][b.y]&amp;&amp;mm[b.x][b.y]!=&apos;#&apos;)&#123;</span><br><span class="line">                vis[b.x][b.y]=1;</span><br><span class="line">                qu.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void make_adge()&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            if(mm[i][j]!=&apos;#&apos;&amp;&amp;mm[i][j]!=&apos;.&apos;)</span><br><span class="line">                bfs(i*100+j,i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int r[10005];</span><br><span class="line">int fi(int n)&#123;</span><br><span class="line">    return r[n]=r[n]==n?n:fi(r[n]);</span><br><span class="line">&#125;</span><br><span class="line">int cmp(node x,node y)&#123;</span><br><span class="line">    return x.l&lt;y.l;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int vis[10005];</span><br><span class="line">    for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">        r[i]=i;</span><br><span class="line">        vis[i]=0;</span><br><span class="line">if(mm[i / 100][i % 100] == &apos;S&apos;) mm[i / 100][i % 100] = 47;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(k,k+lm,cmp);</span><br><span class="line">    int out=0;</span><br><span class="line">    for(int i=0;i&lt;lm;i++)&#123;</span><br><span class="line">        int fx=fi(k[i].x);</span><br><span class="line">        int fy=fi(k[i].y);</span><br><span class="line">        if((mm[k[i].x/100][k[i].x%100]-&apos;0&apos;)+2==vis[k[i].x])continue ;</span><br><span class="line">        if((mm[k[i].y/100][k[i].y%100]-&apos;0&apos;)+2==vis[k[i].y])continue ;</span><br><span class="line">        if(fx!=fy)&#123;</span><br><span class="line">            r[fx]=fy;</span><br><span class="line">            vis[k[i].x]++;</span><br><span class="line">            vis[k[i].y]++;</span><br><span class="line">//printf(&quot;[%d,%d] -&gt; [%d,%d]\n&quot;, k[i].x / 100, k[i].x % 100, k[i].y / 100, k[i].y % 100);</span><br><span class="line">            out+=k[i].l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">        if((mm[i/100][i%100]&gt;=&apos;1&apos;&amp;&amp;mm[i/100][i%100]&lt;=&apos;9&apos;)||mm[i/100][i%100]==47)&#123;</span><br><span class="line">            if(fi(i)==i)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans!=1)out=-1;</span><br><span class="line">    cout&lt;&lt;out&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen(&quot;test0.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">  //  freopen(&quot;test0.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        memset(mm,0,sizeof(mm));</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,mm[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        lm=0;</span><br><span class="line">        make_adge();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、小爱密码-2-0"><a href="#3、小爱密码-2-0" class="headerlink" title="3、小爱密码 2.0"></a>3、小爱密码 2.0</h1><p>不明白什么斐波那契质数应该做不出来。<br>还需要求出第n个质数，需要埃拉托斯特尼筛法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci质数的定义：</span><br><span class="line"></span><br><span class="line">若某Fibonacci数与任何比它小的Fibonacci数互质，那么它就是Fibonacci质数。</span><br><span class="line">1</span><br><span class="line">这里有一个结论是：</span><br><span class="line">1.F(3)和F(4)是Fibonacci质数；从F(5)开始，某项为Fibonacci质数当且仅当它的项数为质数</span><br><span class="line">2.第k小的Fibonacci质数是以质数数列中的第k个数为项数的Fibonacci数( 除F(3)和F(4)之外 )</span><br><span class="line">证明戳这里：https://www.cnblogs.com/allensun/archive/2011/01/27/1946282.html</span><br><span class="line">问题就变成了求第n个质数p，然后求F( p )/3 模m的结果，因为3和m互质，所以可以扩展欧几里得求出3的逆元，矩阵快速幂求出F( p )，就得到答案了。</span><br><span class="line">--------------------- </span><br><span class="line">作者：_ 泛白 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/qq_43202683/article/details/88903027 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://code.mi.com/contest/list/view?id=9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小米 OJ 编程比赛 03 月常规赛&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;–more–&amp;gt;&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="C/C++" scheme="https://hankin2015.github.io/categories/C-C/"/>
    
    
      <category term="C" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hiho一下 第241周 区间价值</title>
    <link href="https://hankin2015.github.io/2019/03/01/20190301hiho241/"/>
    <id>https://hankin2015.github.io/2019/03/01/20190301hiho241/</id>
    <published>2019-03-01T13:48:41.000Z</published>
    <updated>2019-03-27T08:55:26.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-区间价值"><a href="#题目-区间价值" class="headerlink" title="题目: 区间价值"></a>题目: 区间价值</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定n个数A1…An，小Ho想了解AL..AR中有多少对元素值相同。小Ho把这个数目定义为区间[L,R]的价值，用v[L,R]表示。</p><p>例如1 1 1 2 2这五个数所组成的区间的价值为4。</p><p>现在小Ho想知道在所有的的v<a href="1 &lt;= L &lt;= R &lt;= n">L,R</a>中，第k小的值是多少。<br><a id="more"></a></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数T(T&lt;=10)，表示数据组数。</p><p>对于每一组数据：</p><p>第一行两个数n，k（1&lt;=n&lt;=200,000,1&lt;=k&lt;=n*(n+1)/2）</p><p>第二行n个数A1…An(1&lt;=Ai&lt;=1,000,000,000)</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>一个数表示答案。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote><p>2<br>4 7<br>1 1 2 3<br>3 6<br>100 100 100</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>0<br>3</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>暴力枚举求出n*(n+1)/2区间不同的值，然后排序求第k小的值，明显TLE。<br>我们先分析发现区间越大，价值肯定越大，并且呈单调性。我们就可以用二分去查找第k小的值。<br>对于每次二分的check，这里利用尺取的思想，尺取从左往右扫一遍最大区间[L,R]里的价值都是小于二分的mid,O(n)时间内在n个数里求出比mid价值小的区间个数。<br>总的时间复杂度就变成O(nlogn)。</p><p>消费排行榜：少女》小孩、老人、狗》男人</p><p>11<br>好基友可以基到什么程度?</p><p>“该发生的都发生了不该发生的都尽力了”</p><p>“真正的兄弟是在对方需要女人的时候.<br>做他的女人”</p><p>ob1 = ‘abc’<br>ob2 = iter(‘abc’)<br>ob3 = iter(‘abc’)</p><p>for i in ob1:<br>    print(i, end=’,’)<br>》a,b,c,</p><p>ob1.<strong>next</strong>()  # AttributeError: ‘str’ object has no attribute ‘<strong>next</strong>‘</p><p>for i in ob2:<br>    print(i, end=’ ‘)    # a b c<br>ob2.<strong>next</strong>()  # StopIteration: </p><p>ob3.<strong>next</strong>()  # a<br>ob3.<strong>next</strong>()  # b<br>ob3.<strong>next</strong>()  # c<br>ob3.<strong>next</strong>()  #  StopIteration: </p><p>通过_上述例子可看出，迭代器的优势在于支持自遍历，同时，它的特点是单向非循环的，一旦完成遍历，再次调用就会报错。</p><p>男上加男<br>迎男而上<br>强人锁男<br>左右为男<br>在劫男逃<br>男终羞涩<br>一女男求</p><p>世界上有两种人有话不直说，一种是中国人，一种是女人。我们面对的是中国女人。</p><p>“昨天他给我讲他小时候的故事，讲到一半突然不讲了，他说：“你嫁给我吧让我妈妈给你讲”。</p><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。<br>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：<br>原数据：1,999,100000,15；处理后：1,3,4,2；<br>原数据：{100,200}，{20,50000}，{1,400}；<br>处理后：{3,4}，{2,6}，{1,5}；</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>不解释</p><h1 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h1><p>顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。</p><p>使用尺取法时应清楚以下四点：</p><ul><li>1、什么情况下能使用尺取法?  </li><li>2、何时推进区间的端点？ </li><li>3、如何推进区间的端点？ </li><li>4、何时结束区间的枚举？</li></ul><p>尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>1、  Poj3061<br>题意：给定一个序列，使得其和大于或等于S，求最短的子序列长度。<br>输入：n=10, S=15, array={5,1,3,5,10,7,4,9,2,8}</p><p>个人理解：设置两个指针，首先右指针不断的+1向右，直到满足条件。如果到结尾了就没有答案。否则就停止右指针进行左指针+1，首先判断当前是否满足条件，满足就继续左指针，不满足就右指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100005  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">LL a[<span class="number">100010</span>];  </span><br><span class="line"><span class="keyword">int</span> n, t, ans = INF;  </span><br><span class="line">LL sum, s;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);  </span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %I64d"</span>, &amp;n, &amp;s);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, a+i);  </span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">0</span>, en = <span class="number">0</span>;  </span><br><span class="line">        ans = INF; sum = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="keyword">while</span> (en&lt;n &amp;&amp; sum&lt;s) sum += a[en++];  </span><br><span class="line">            <span class="keyword">if</span> (sum &lt; s) <span class="keyword">break</span>;  </span><br><span class="line">            ans = min(ans, en-st);  </span><br><span class="line">            sum -= a[st++];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (ans == INF) ans = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p># </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-区间价值&quot;&gt;&lt;a href=&quot;#题目-区间价值&quot; class=&quot;headerlink&quot; title=&quot;题目: 区间价值&quot;&gt;&lt;/a&gt;题目: 区间价值&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给定n个数A1…An，小Ho想了解AL..AR中有多少对元素值相同。小Ho把这个数目定义为区间[L,R]的价值，用v[L,R]表示。&lt;/p&gt;
&lt;p&gt;例如1 1 1 2 2这五个数所组成的区间的价值为4。&lt;/p&gt;
&lt;p&gt;现在小Ho想知道在所有的的v&lt;a href=&quot;1 &amp;lt;= L &amp;lt;= R &amp;lt;= n&quot;&gt;L,R&lt;/a&gt;中，第k小的值是多少。&lt;br&gt;
    
    </summary>
    
      <category term="hihoCoder" scheme="https://hankin2015.github.io/categories/hihoCoder/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="Hiho" scheme="https://hankin2015.github.io/tags/Hiho/"/>
    
      <category term="二分" scheme="https://hankin2015.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="区间" scheme="https://hankin2015.github.io/tags/%E5%8C%BA%E9%97%B4/"/>
    
      <category term="尺取法" scheme="https://hankin2015.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++的读取文件内容和python启动另一个py文件</title>
    <link href="https://hankin2015.github.io/2019/02/23/20190223ReadFileByC++/"/>
    <id>https://hankin2015.github.io/2019/02/23/20190223ReadFileByC++/</id>
    <published>2019-02-23T13:48:41.000Z</published>
    <updated>2019-03-27T08:38:13.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言的文件操作"><a href="#C语言的文件操作" class="headerlink" title="C语言的文件操作"></a>C语言的文件操作</h1><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:left">打开一个已有的文本文件，允许读取文件。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文本文件，允许读写文件。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p><blockquote><p>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”</p></blockquote><h1 id="C-的文件操作"><a href="#C-的文件操作" class="headerlink" title="C++的文件操作"></a>C++的文件操作</h1><p>参考地址：<a href="https://www.cnblogs.com/yongpan/p/8026489.html" target="_blank" rel="noopener">https://www.cnblogs.com/yongpan/p/8026489.html</a></p><table><thead><tr><th style="text-align:left">格式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">ios::in</td><td style="text-align:left">以输入方式打开文件</td></tr><tr><td style="text-align:left">ios::out</td><td style="text-align:left">以输出方式打开文件，如果文件不存在则新建，如果文件存在就将其原有内容全部清空</td></tr><tr><td style="text-align:left">ios::app</td><td style="text-align:left">输出的数据追加到文件末尾</td></tr><tr><td style="text-align:left">ios::ate</td><td style="text-align:left">打开一个文件，并将指针定位到文件末尾</td></tr><tr><td style="text-align:left">ios::trunc</td><td style="text-align:left">打开一个文件，如果文件不存在则新建，如果存在，则清空原有文件中的内容</td></tr><tr><td style="text-align:left">ios::binary</td><td style="text-align:left">以二进制方式打开文件，如果不指定则默认采用文本方式打开文件</td></tr><tr><td style="text-align:left">ios::in</td><td style="text-align:left">ios::out</td><td>以输出和输入方式打开文件</td></tr><tr><td style="text-align:left">ios::in</td><td style="text-align:left">ios::binary</td><td>以输入方式打开一个二进制文件</td></tr><tr><td style="text-align:left">ios::out</td><td style="text-align:left">ios::binary</td><td>以输出方式打开一个二进制文件</td></tr></tbody></table><h1 id="python启动另一个py文件"><a href="#python启动另一个py文件" class="headerlink" title="python启动另一个py文件"></a>python启动另一个py文件</h1><p>最简单的方法：</p><p>import os<br>os.system(“python filename”)<br>filename最好是全路径+文件名；</p><p>其他方法：</p><p>execfile(‘xx.py’)，括号内为py文件路径；</p><p>如果需要传参数，就用os.system()那种方法；</p><p>如果还想获得这个文件的输出，那就得用os.popen（）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">#os.system(&apos;python testB.py&apos;)</span><br><span class="line">#os.system(&apos;python testC.py&apos;)</span><br><span class="line">#execfile(&apos;./testB.py&apos;)  python3中淘汰</span><br><span class="line">exec(open(&apos;./testB.py&apos;, encoding = &apos;utf-8&apos;).read())</span><br><span class="line">exec(open(&apos;./testC.py&apos;, encoding = &apos;utf-8&apos;).read())</span><br></pre></td></tr></table></figure><p><a href="https://tianchi.aliyun.com/notebook-ai/?spm=5176.12281988.0.0.30674dd1bSompw" target="_blank" rel="noopener">https://tianchi.aliyun.com/notebook-ai/?spm=5176.12281988.0.0.30674dd1bSompw</a><br><a href="https://tianchi.aliyun.com/forum/postDetail?spm=5176.12281988.0.0.30674dd1bSompw&amp;postId=3192" target="_blank" rel="noopener">https://tianchi.aliyun.com/forum/postDetail?spm=5176.12281988.0.0.30674dd1bSompw&amp;postId=3192</a><br><a href="https://blog.csdn.net/ArrowYL/article/details/81094837" target="_blank" rel="noopener">https://blog.csdn.net/ArrowYL/article/details/81094837</a><br>gcc, g++编译时消除特定警告的方法](<a href="https://blog.csdn.net/li_wen01/article/details/71171413" target="_blank" rel="noopener">https://blog.csdn.net/li_wen01/article/details/71171413</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言的文件操作&quot;&gt;&lt;a href=&quot;#C语言的文件操作&quot; class=&quot;headerlink&quot; title=&quot;C语言的文件操作&quot;&gt;&lt;/a&gt;C语言的文件操作&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;
      
    
    </summary>
    
      <category term="园园工作室" scheme="https://hankin2015.github.io/categories/%E5%9B%AD%E5%9B%AD%E5%B7%A5%E4%BD%9C%E5%AE%A4/"/>
    
    
      <category term="数据集" scheme="https://hankin2015.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
      <category term="DBLP" scheme="https://hankin2015.github.io/tags/DBLP/"/>
    
  </entry>
  
  <entry>
    <title>python画图之雪花</title>
    <link href="https://hankin2015.github.io/2019/02/21/20190221SnowByPython/"/>
    <id>https://hankin2015.github.io/2019/02/21/20190221SnowByPython/</id>
    <published>2019-02-21T12:48:41.000Z</published>
    <updated>2019-03-20T06:46:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="科赫曲线"><a href="#科赫曲线" class="headerlink" title="科赫曲线"></a>科赫曲线</h1><p>科赫曲线是一种像雪花的几何曲线，所以又称为雪花曲线，它是de Rham曲线的特例。科赫曲线是出现在海里格·冯·科赫的论文中，是分形曲线中的一种。</p><p>正整数n代表科赫曲线的阶数，表示生成科赫曲线过程的操作次数。科赫曲线初始化阶数为0，表示一个长度为L的直线。对于直线L将其等分为3段，中间一段用边长为L/3的等边三角形的两个边替代，得到1阶科赫曲线，它包含4条线段。进一步对每条线段重复同样的操作后得到的2阶科赫曲线。重复操作N次可以得到N阶科赫曲线。<br>&lt;–more–&gt;</p><h1 id="turtle"><a href="#turtle" class="headerlink" title="turtle"></a>turtle</h1><p>turtle 是 python 内置的一个比较有趣味的模块，俗称 海龟绘图，它是基于 tkinter 模块打造，提供一些简单的绘图工具。<br>官方文档：<a href="https://docs.python.org/3/library/turtle.html" target="_blank" rel="noopener">https://docs.python.org/3/library/turtle.html</a></p><p><a href="https://mp.weixin.qq.com/s/RqY6vL36HkI6OWOHVnpDWg" target="_blank" rel="noopener">骚操作：用Python来一场人工造雪</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Feb 21 21:08:54 2019</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: HanKin</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">koch</span><span class="params">(size,n)</span>:</span>  <span class="comment"># 科赫曲线</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        turtle.fd(size)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> angle <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">60</span>, <span class="number">-120</span>, <span class="number">60</span>]:</span><br><span class="line">            turtle.left(angle)</span><br><span class="line">            koch(size/<span class="number">3</span>, n<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    turtle.setup(<span class="number">600</span>, <span class="number">600</span>)</span><br><span class="line">    turtle.pen(speed = <span class="number">0</span>, pencolor = <span class="string">'blue'</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.goto(<span class="number">-200</span>, <span class="number">100</span>)</span><br><span class="line">    turtle.pendown()</span><br><span class="line">    turtle.pensize(<span class="number">1</span>)</span><br><span class="line">    level = <span class="number">5</span>   <span class="comment"># 阶数</span></span><br><span class="line">    </span><br><span class="line">    koch(<span class="number">400</span>, level)</span><br><span class="line">    turtle.right(<span class="number">120</span>)  <span class="comment"># 向右旋转120°</span></span><br><span class="line">    koch(<span class="number">400</span>, level)</span><br><span class="line">    turtle.right(<span class="number">120</span>)</span><br><span class="line">    koch(<span class="number">400</span>, level)</span><br><span class="line">    </span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    done()  <span class="comment"># turtle.done()用来停止画笔绘制，但绘图窗体不关闭</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./images/1550805143573.png" alt="enter description here" title="">                </div>                <div class="image-caption">enter description here</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./images/20190222115629.jpg" alt="enter description here" title="20190222115629">                </div>                <div class="image-caption">20190222115629</div>            </figure><h1 id="小猪佩奇"><a href="#小猪佩奇" class="headerlink" title="小猪佩奇"></a>小猪佩奇</h1><p><a href="https://mp.weixin.qq.com/s/xUte5wKpYrO8PpoXXITSdA" target="_blank" rel="noopener">Python20秒画完小猪佩奇“社会人”，程序猿的手法是你想不到的独特</a></p><figure class="highlight plain"><figcaption><span>-*- coding: utf-8 -*-</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Thu Feb 21 22:08:12 2019</span><br><span class="line"></span><br><span class="line">@author: HanKin</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from turtle import*</span><br><span class="line"></span><br><span class="line">def nose(x,y):#鼻子</span><br><span class="line">   penup()#提起笔</span><br><span class="line">   goto(x,y)#定位</span><br><span class="line">   pendown()#落笔，开始画</span><br><span class="line">   setheading(-30)#将乌龟的方向设置为to_angle/为数字（0-东、90-北、180-西、270-南）</span><br><span class="line">   begin_fill()#准备开始填充图形</span><br><span class="line">   a=0.4</span><br><span class="line">   for i in range(120):</span><br><span class="line">       if 0&lt;=i&lt;30 or 60&lt;=i&lt;90:</span><br><span class="line">           a=a+0.08</span><br><span class="line">           left(3) #向左转3度</span><br><span class="line">           forward(a) #向前走a的步长</span><br><span class="line">       else:</span><br><span class="line">           a=a-0.08</span><br><span class="line">           left(3)</span><br><span class="line">           forward(a)</span><br><span class="line">   end_fill()#填充完成</span><br><span class="line"></span><br><span class="line">   penup()</span><br><span class="line">   setheading(90)</span><br><span class="line">   forward(25)</span><br><span class="line">   setheading(0)</span><br><span class="line">   forward(10)</span><br><span class="line">   pendown()</span><br><span class="line">   pencolor(255,155,192)#画笔颜色</span><br><span class="line">   setheading(10)</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(5)</span><br><span class="line">   color(160,82,45)#返回或设置pencolor和fillcolor</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">   penup()</span><br><span class="line">   setheading(0)</span><br><span class="line">   forward(20)</span><br><span class="line">   pendown()</span><br><span class="line">   pencolor(255,155,192)</span><br><span class="line">   setheading(10)</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(5)</span><br><span class="line">   color(160,82,45)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">def head(x,y):#头</span><br><span class="line">   color((255,155,192),&quot;pink&quot;)</span><br><span class="line">   penup()</span><br><span class="line">   goto(x,y)</span><br><span class="line">   setheading(0)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   setheading(180)</span><br><span class="line">   circle(300,-30)</span><br><span class="line">   circle(100,-60)</span><br><span class="line">   circle(80,-100)</span><br><span class="line">   circle(150,-20)</span><br><span class="line">   circle(60,-95)</span><br><span class="line">   setheading(161)</span><br><span class="line">   circle(-300,15)</span><br><span class="line">   penup()</span><br><span class="line">   goto(-100,100)</span><br><span class="line">   pendown()</span><br><span class="line">   setheading(-30)</span><br><span class="line">   a=0.4</span><br><span class="line">   for i in range(60):</span><br><span class="line">       if 0&lt;=i&lt;30 or 60&lt;=i&lt;90:</span><br><span class="line">           a=a+0.08</span><br><span class="line">           lt(3) #向左转3度</span><br><span class="line">           fd(a) #向前走a的步长</span><br><span class="line">       else:</span><br><span class="line">           a=a-0.08</span><br><span class="line">           lt(3)</span><br><span class="line">           fd(a)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">def ears(x,y): #耳朵</span><br><span class="line">   color((255,155,192),&quot;pink&quot;)</span><br><span class="line">   penup()</span><br><span class="line">   goto(x,y)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   setheading(100)</span><br><span class="line">   circle(-50,50)</span><br><span class="line">   circle(-10,120)</span><br><span class="line">   circle(-50,54)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">   penup()</span><br><span class="line">   setheading(90)</span><br><span class="line">   forward(-12)</span><br><span class="line">   setheading(0)</span><br><span class="line">   forward(30)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   setheading(100)</span><br><span class="line">   circle(-50,50)</span><br><span class="line">   circle(-10,120)</span><br><span class="line">   circle(-50,56)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">def eyes(x,y):#眼睛</span><br><span class="line">   color((255,155,192),&quot;white&quot;)</span><br><span class="line">   penup()</span><br><span class="line">   setheading(90)</span><br><span class="line">   forward(-20)</span><br><span class="line">   setheading(0)</span><br><span class="line">   forward(-95)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(15)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">   color(&quot;black&quot;)</span><br><span class="line">   penup()</span><br><span class="line">   setheading(90)</span><br><span class="line">   forward(12)</span><br><span class="line">   setheading(0)</span><br><span class="line">   forward(-3)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(3)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">   color((255,155,192),&quot;white&quot;)</span><br><span class="line">   penup()</span><br><span class="line">   seth(90)</span><br><span class="line">   forward(-25)</span><br><span class="line">   seth(0)</span><br><span class="line">   forward(40)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(15)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">   color(&quot;black&quot;)</span><br><span class="line">   penup()</span><br><span class="line">   setheading(90)</span><br><span class="line">   forward(12)</span><br><span class="line">   setheading(0)</span><br><span class="line">   forward(-3)</span><br><span class="line">   pendown()</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(3)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">def cheek(x,y):#腮</span><br><span class="line">   color((255,155,192))</span><br><span class="line">   penup()</span><br><span class="line">   goto(x,y)</span><br><span class="line">   pendown()</span><br><span class="line">   setheading(0)</span><br><span class="line">   begin_fill()</span><br><span class="line">   circle(30)</span><br><span class="line">   end_fill()</span><br><span class="line"></span><br><span class="line">def mouth(x,y): #嘴</span><br><span class="line">   color(239,69,19)</span><br><span class="line">   penup()</span><br><span class="line">   goto(x,y)</span><br><span class="line">   pendown()</span><br><span class="line">   setheading(-80)</span><br><span class="line">   circle(30,40)</span><br><span class="line">   circle(40,80)</span><br><span class="line"></span><br><span class="line">def setting():          #参数设置</span><br><span class="line">   pensize(4)</span><br><span class="line">   hideturtle()        #使乌龟无形（隐藏）</span><br><span class="line">   colormode(255)      #将其设置为1.0或255.随后 颜色三元组的r，g，b值必须在0 .. cmode范围内</span><br><span class="line">   color((255,155,192),&quot;pink&quot;)</span><br><span class="line">   setup(840,500)</span><br><span class="line">   speed(10)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">   setting()           #画布、画笔设置</span><br><span class="line">   nose(-100,100)      #鼻子</span><br><span class="line">   head(-69,167)       #头</span><br><span class="line">   ears(0,160)         #耳朵</span><br><span class="line">   eyes(0,140)         #眼睛</span><br><span class="line">   cheek(80,10)        #腮</span><br><span class="line">   mouth(-20,30)       #嘴</span><br><span class="line">   done()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;科赫曲线&quot;&gt;&lt;a href=&quot;#科赫曲线&quot; class=&quot;headerlink&quot; title=&quot;科赫曲线&quot;&gt;&lt;/a&gt;科赫曲线&lt;/h1&gt;&lt;p&gt;科赫曲线是一种像雪花的几何曲线，所以又称为雪花曲线，它是de Rham曲线的特例。科赫曲线是出现在海里格·冯·科赫的论文中，
      
    
    </summary>
    
      <category term="随记" scheme="https://hankin2015.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="Turtle" scheme="https://hankin2015.github.io/tags/Turtle/"/>
    
      <category term="科赫曲线" scheme="https://hankin2015.github.io/tags/%E7%A7%91%E8%B5%AB%E6%9B%B2%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>新技能GET--emplace_back函数</title>
    <link href="https://hankin2015.github.io/2019/01/17/20190117emplace_back/"/>
    <id>https://hankin2015.github.io/2019/01/17/20190117emplace_back/</id>
    <published>2019-01-17T05:48:41.000Z</published>
    <updated>2019-03-20T06:48:08.939Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/fengbingchun/article/details/78670376" target="_blank" rel="noopener">C++11容器中新增加的emplace相关函数的使用</a><br>C++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。<br>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。<br>emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。<br>其它容器中，std::forward_list中的emplace_after、emplace_front函数，std::map/std::multimap中的emplace、emplace_hint函数，std::set/std::multiset中的emplace、emplace_hint，std::stack中的emplace函数，等emplace相似函数操作也均是构造而不是拷贝元素。<br>emplace相关函数可以减少内存拷贝和移动。当插入rvalue，它节约了一次move构造，当插入lvalue，它节约了一次copy构造。<br><a id="more"></a></p><h1 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h1><p>不断的发现以前的自己是个傻逼，这就是人生。<br>人这一生，其实都在不断找借口好让自己心安理得地活下去。<br>我出门代步用A8，旅游一般开jeep，但是我最喜欢的还是开玩笑</p><h1 id="map按key排序"><a href="#map按key排序" class="headerlink" title="map按key排序"></a>map按key排序</h1><p>在下面的代码里实现。</p><h1 id="map按value排序"><a href="#map按value排序" class="headerlink" title="map按value排序"></a>map按value排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;hash_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">由于hash_map定义在__gnu_cxx命名空间中，故你必须在使用时限定名字空间__gnu_cxx::hash_map，</span><br><span class="line">或者使用using关键字加一个  using namespace __gnu_cxx;</span><br><span class="line">*/</span><br><span class="line">using namespace __gnu_cxx;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;  // auto不能修饰参数</span><br><span class="line">void DISPLAY(T m)</span><br><span class="line">&#123;</span><br><span class="line">    for (auto i : m) &#123;</span><br><span class="line">        cout &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// hash_*系列例如hash_map,hash_set 等已经被废弃了，C++11用unordered_map，unordered_set等来替代</span><br><span class="line">void HASH_MAP()</span><br><span class="line">&#123;</span><br><span class="line">    hash_map&lt;int, string&gt; m;</span><br><span class="line">    m[23] = &quot;helu&quot;;</span><br><span class="line">    m[520] = &quot;chengqiqi&quot;;</span><br><span class="line">    m[12] = &quot;hejian&quot;;</span><br><span class="line">    DISPLAY(m);   // 可以看出默认按照key排序输出</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SORT_KEY()</span><br><span class="line">&#123;</span><br><span class="line">    map&lt;int, string, greater&lt;int&gt; &gt; m;  // 默认是less</span><br><span class="line">    m[23] = &quot;helu&quot;;</span><br><span class="line">    m[520] = &quot;chengqiqi&quot;;</span><br><span class="line">    m[12] = &quot;hejian&quot;;</span><br><span class="line">    DISPLAY(m);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">基本思路就是：想直接用sort排序是做不到的，sort只支持数组、vetctor等的排序，所以我们可以先把map装</span><br><span class="line">进pair里，然后再放入vector，自定义sort实现排序。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HASH_MAP();</span><br><span class="line">    SORT_KEY();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锤子定律非常简单，可以概括为一句话：当你的脑子里有一个锤子的时候，你会满世界找钉子。</p><h1 id="C-保留两位小数"><a href="#C-保留两位小数" class="headerlink" title="C++保留两位小数"></a>C++保留两位小数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;  //不要忘了头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::fixed);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fengbingchun/article/details/78670376&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++11容器中新增加的emplace相关函数的使用&lt;/a&gt;&lt;br&gt;C++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。&lt;br&gt;当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。&lt;br&gt;emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。&lt;br&gt;其它容器中，std::forward_list中的emplace_after、emplace_front函数，std::map/std::multimap中的emplace、emplace_hint函数，std::set/std::multiset中的emplace、emplace_hint，std::stack中的emplace函数，等emplace相似函数操作也均是构造而不是拷贝元素。&lt;br&gt;emplace相关函数可以减少内存拷贝和移动。当插入rvalue，它节约了一次move构造，当插入lvalue，它节约了一次copy构造。&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://hankin2015.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="容器" scheme="https://hankin2015.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Vector" scheme="https://hankin2015.github.io/tags/Vector/"/>
    
      <category term="Emplace_back" scheme="https://hankin2015.github.io/tags/Emplace-back/"/>
    
      <category term="Map" scheme="https://hankin2015.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习笔记</title>
    <link href="https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/"/>
    <id>https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/</id>
    <published>2019-01-15T02:47:41.000Z</published>
    <updated>2018-09-25T01:53:46.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="http://zh.gluon.ai/index.html#" target="_blank" rel="noopener">动手学深度学习</a><br>这是一个深度学习的教学项目。我们将使用 Apache MXNet (incubating) 的最新 gluon 接口来演示如何从0开始实现深度学习的各个算法。我们的将利用 Jupyter notebook 能将文档，代码，公式和图形统一在一起的优势，提供一个交互式的学习体验。这个项目可以作为一本书，上课用的材料，现场演示的案例，和一个可以尽情拷贝的代码库。据我们所知，目前并没有哪个项目能既覆盖全面深度学习，又提供交互式的可执行代码。我们将尝试弥补这个空白。</p><p>第一季十九课视频汇总<br>可打印的PDF版本在这里<br>课程源代码在Github （亲，给个好评加颗星）<br>请使用 <a href="http://discuss.gluon.ai/" target="_blank" rel="noopener">http://discuss.gluon.ai/</a> 来进行讨论</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="主要符号一览"><a href="#主要符号一览" class="headerlink" title="主要符号一览"></a>主要符号一览</h2><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><h3 id="1、用代码编程和用数据编程"><a href="#1、用代码编程和用数据编程" class="headerlink" title="1、用代码编程和用数据编程"></a>1、用代码编程和用数据编程</h3><p>这个例子灵感来自 Joel Grus 的一次 应聘面试. 面试官让他写个程序来玩Fizz Buzz. 这是一个小孩子游戏。玩家从1数到100，如果数字被3整除，那么喊’fizz’，如果被5整除就喊’buzz’，如果两个都满足就喊’fizzbuzz’，不然就直接说数字。这个游戏玩起来就像是：</p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 …</p></blockquote><p>传统的实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [1]:</span><br><span class="line">res = []</span><br><span class="line">for i in range(1, 101):</span><br><span class="line">    if i % 15 == 0:</span><br><span class="line">        res.append(&apos;fizzbuzz&apos;)</span><br><span class="line">    elif i % 3 == 0:</span><br><span class="line">        res.append(&apos;fizz&apos;)</span><br><span class="line">    elif i % 5 == 0:</span><br><span class="line">        res.append(&apos;buzz&apos;)</span><br><span class="line">    else:</span><br><span class="line">        res.append(str(i))</span><br><span class="line">print(&apos; &apos;.join(res))</span><br></pre></td></tr></table></figure></p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz b</p></blockquote><p>对于经验丰富的程序员来说这个太不够一颗赛艇了。所以Joel尝试用机器学习来实现这个。为了让程序能学，他需要准备下面这个数据集：</p><ul><li>数据 X [1, 2, 3, 4, …] 和标注Y [‘fizz’, ‘buzz’, ‘fizzbuzz’, identity]</li><li>训练数据，也就是系统输入输出的实例。例如 [(2, 2), (6, fizz), (15, fizzbuzz), (23, 23), (40, buzz)]</li><li>从输入数据中抽取的特征，例如 x -&gt; [(x % 3), (x % 5), (x % 15)].</li></ul><p>有了这些，Jeol利用TensorFlow写了一个分类器。对于不按常理出牌的Jeol，面试官一脸黑线。而且这个分类器不是总是对的。</p><h3 id="2、机器学习最简要素"><a href="#2、机器学习最简要素" class="headerlink" title="2、机器学习最简要素"></a>2、机器学习最简要素</h3><p>成功的机器学习有四个要素：数据、转换数据的模型、衡量模型好坏的损失函数和一个调整模型权重来最小化损失函数的算法。</p><h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><h4 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h4><ul><li>训练误差（training error）：这是模型在用于训练的数据集上的误差。类似于考试前我们在模拟试卷上拿到的分数。有一定的指向性，但不一定保证真实考试分数。</li><li>测试误差（test error）：这是模型在没见过的新数据上的误差，可能会跟训练误差很不一样（统计上称之为过拟合）。类似于考前模考次次拿高分，但实际考起来却失误了。</li></ul><h4 id="Optimization-Algorithms"><a href="#Optimization-Algorithms" class="headerlink" title="Optimization Algorithms"></a>Optimization Algorithms</h4><h3 id="3、Supervised-Learning"><a href="#3、Supervised-Learning" class="headerlink" title="3、Supervised Learning"></a>3、Supervised Learning</h3><p>简单概括，学习过程看起来是这样的：在一大组数据中随机地选择样本输入，并获得其真实（ground-truth）的标注（label）；这些输入和标注（即期望的结果）构成了训练集（training set）。我们把训练集放入一个监督学习算法（supervised learning algorithm）。算法的输入是训练集，输出则是学得模型（learned model）。基于这个学得模型，我们输入之前未见过的测试数据，并预测相应的标注。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zh.gluon.ai/_images/supervised-learning.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="3-1、Regression"><a href="#3-1、Regression" class="headerlink" title="3-1、Regression"></a>3-1、Regression</h4><p>在该项任务里，输入是任意离散或连续的、单一或多个的变量，而输出是连续的数值。</p><p>一条经验就是，问题中如果包含“多少？”，这类问题一般是回归问题。“这次手术需要几个小时？”……回归分析。“这张照片里有几只狗？”……回归分析。不过，如果问题能够转化为“这是一个<em>__</em>吗？”，那这很有可能是一个分类，或者属于其余我们将会谈及的问题。</p><p>如果我们把模型预测的输出值和真实的输出值之间的差别定义为残差，常见的回归分析的损失函数包括训练数据的残差的平方和或者绝对值的和。机器学习的任务是找到一组模型参数使得损失函数最小化。</p><h4 id="3-2、Classification"><a href="#3-2、Classification" class="headerlink" title="3-2、Classification"></a>3-2、Classification</h4><p>回归分析所关注的预测可以解答输出为连续数值 的问题。当预测的输出是离散的 类别时，这个监督学习任务就叫做分类。</p><h2 id="使用NDArray来处理数据"><a href="#使用NDArray来处理数据" class="headerlink" title="使用NDArray来处理数据"></a>使用NDArray来处理数据</h2><p>使用autograd来自动求导<br>深度学习模型基础<br>线性回归——从零开始<br>线性回归——使用Gluon<br>多类逻辑回归——从零开始<br>多类逻辑回归——使用Gluon<br>多层感知机——从零开始<br>多层感知机——使用Gluon<br>欠拟合和过拟合<br>正则化——从零开始<br>正则化——使用Gluon<br>丢弃法（Dropout）——从零开始<br>丢弃法（Dropout）——使用Gluon<br>正向传播和反向传播<br>实战Kaggle比赛——使用Gluon预测房价和K折交叉验证<br>深度学习计算基础<br>模型构造<br>模型参数<br>自定义层<br>读取和存储<br>GPU计算<br>卷积神经网络<br>卷积神经网络 — 从0开始<br>卷积神经网络 — 使用Gluon<br>批量归一化 — 从0开始<br>批量归一化 — 使用Gluon<br>深度卷积神经网络和AlexNet<br>VGG：使用重复元素的非常深的网络<br>网络中的网络<br>更深的卷积神经网络：GoogLeNet<br>ResNet：深度残差网络<br>DenseNet：稠密连接的卷积神经网络<br>循环神经网络<br>循环神经网络 — 从0开始<br>通过时间反向传播<br>门控循环单元（GRU）— 从0开始<br>长短期记忆（LSTM）— 从0开始<br>循环神经网络 — 使用Gluon<br>优化算法<br>优化算法概述<br>梯度下降和随机梯度下降——从零开始<br>梯度下降和随机梯度下降——使用Gluon<br>动量法——从零开始<br>动量法——使用Gluon<br>Adagrad——从零开始<br>Adagrad——使用Gluon<br>RMSProp——从零开始<br>RMSProp——使用Gluon<br>Adadelta——从零开始<br>Adadelta——使用Gluon<br>Adam——从零开始<br>Adam——使用Gluon<br>计算性能<br>命令式和符号式混合编程<br>惰性计算<br>自动并行计算<br>多GPU训练模型——从零开始<br>多GPU训练模型——使用Gluon<br>计算机视觉<br>图片增广<br>Fine-tuning: 通过微调来迁移学习<br>使用卷积神经网络的物体检测<br>SSD — 使用Gluon<br>YOLO — 使用Gluon<br>语义分割：FCN<br>样式迁移<br>实战Kaggle比赛——使用Gluon对原始图像文件分类（CIFAR-10）<br>实战Kaggle比赛——使用Gluon识别120种狗 (ImageNet Dogs)<br>自然语言处理<br>词向量 — word2vec<br>词向量 — GloVe和fastText<br>使用预训练的词向量<br>编码器—解码器（seq2seq）和注意力机制<br>神经机器翻译<br>附录<br>安装和使用<br>GPU购买指南<br>在AWS上运行教程<br>数学基础<br>本教程的英文版本 （注意：中文版本根据社区的反馈做了比较大的更改，我们还在努力的将改动同步到英文版）</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
  <entry>
    <title>EOJ Monthly 2018.12</title>
    <link href="https://hankin2015.github.io/2018/12/08/20181208EOJ201812/"/>
    <id>https://hankin2015.github.io/2018/12/08/20181208EOJ201812/</id>
    <published>2018-12-08T03:48:41.000Z</published>
    <updated>2018-12-18T07:59:31.131Z</updated>
    
    <content type="html"><![CDATA[<p>比赛地址：<a href="https://acm.ecnu.edu.cn/contest/125/" target="_blank" rel="noopener">https://acm.ecnu.edu.cn/contest/125/</a></p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li>新的运行时间认识，1E8？</li><li>随机数题</li><li>蒙特卡洛模拟算法</li><li>多次询问记得避免重复计算</li></ul><a id="more"></a><h2 id="A-仰望星空"><a href="#A-仰望星空" class="headerlink" title="A. 仰望星空"></a>A. 仰望星空</h2><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>你就这样静坐在草地上，离我稍远的地方。<br>我用眼角瞅着你，你什么话也别说。<br>语言是误会的根源。<br>但是，每天，你可以坐得离我近一些……</p><p>你和她一起仰头仰望着布满星辰的天空。你的星星对她而言只不过是众星中的一颗。</p><p>她会喜欢仰望天际所有的繁星，他们都会是她的朋友。但你深信你不会是万众中一颗毫不起眼的星星。</p><p>于是你默默地记录着每天你们仰望星空时的距离，你发现每天你们的距离或许减少、或许不变，但一定不会增加。</p><p>可是你们在一起仰望星空的日子太长了，长到你只记得你们第一天在星空下的距离。</p><p>今天，你们的距离是 A；你们又在一起仰望星空了。你却突然想知道一起仰望星空 N 天来，你们之间的距离之和。</p><p>由于你已经不记得每天的距离，只能依稀记起第一天的距离是 B，所以你只想知道你们这么多天来的距离之和有多少种不同的可能性。</p><p>输入<br>输入数据包含一行，包含三个整数 N,A,B (2≤N≤109,1≤A≤B≤109)，分别表示你们一起仰望星空的天数、今天你们之间的距离以及第一天你们之间的距离。</p><p>输出<br>输出数据包含一行一个整数，表示不同可能和的个数。</p><p>样例<br>input<br>3 1 2<br>output<br>2<br>提示<br>对于样例有以下几种不同的距离情况：{2,1,1},{2,2,1}；他们的和分别是 4 和 5，所以有两种不同的和。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>已知最大的和最小的，那么和最大的情况一定是除了一个最小的，其余全部是最大的；相反地，和最小的情况一定是除了一个最大的，其余全部都是最小的。<br>显然，我们可以通过一些调整，取到从和的最小到最大这整个区间里所有的数。</p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">#define maxn 10005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    LL N, A, B;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    LL maxSum = B * (N - 1) + A;</span><br><span class="line">    LL minSum = A * (N - 1) + B;</span><br><span class="line">    cout &lt;&lt; maxSum - minSum + 1 &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-清点星辰"><a href="#B-清点星辰" class="headerlink" title="B. 清点星辰"></a>B. 清点星辰</h2><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>“夜里，<br>你要抬头仰望满天的星星。<br>我那颗实在太小了，<br>我都没法指给你看它在哪儿。”</p><p>这样倒也好，我的星星，对你来说就是满天星星中的一颗。</p><p>所以，你会爱这满天的星星…所有的星星都会是你的朋友。</p><p>即使只能通过狭小的洞口，在楼宇的夹缝中仰望布满星辰的天空，你还是无法割舍对它的期待。</p><p>星星数不胜数，但你还是不厌其烦地清点他们。日复一日，终于在今天，你把他们都数清楚了。</p><p>于是你又开始找别的事情做了。你开始计算他们两两之间的最近距离。</p><p>你仰望星空的洞口是一个 1×1 的正方形，每天，星辰的位置都会发生变化，具体地说，每天都会有 n 个星辰随机地散落在这个正方形内的某个坐标上（每个点横纵坐标满足独立同分布 U(0,1)）。</p><p>每天的距离都在变化，所以现在你只想知道他们两两之间最近距离的期望是多少。</p><p>输入<br>输入一个整数 n (2≤n≤109) ，表示星辰的数量。</p><p>输出<br>一行一个小数，输出答案。绝对误差在 10−3 内会被视为正确。</p><p>样例<br>input<br>2<br>output<br>0.521405<br>input<br>3<br>output<br>0.3055302430</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>蒙特卡洛模拟算法。<br>精度要求只有 10−3，显然大的时候可以直接输出 0。<br>对不是 0 的部分，显然 n 越大答案的方差越小，所以 n 越大需要的生成次数就越小，所以可以直接控制复杂度 1E8 或者运行时间。<br>那么 n 要多大才可以输出 0 了呢？可以试一试：好像 700 多一点点就可以输出 0 了……</p><p>第一次WA了1发，在测试样例的时候误差也超出了1E3的范围，尽量把单次的运行时间卡在边缘，即n越小的时候要模拟次数越多。</p><h3 id="AC-1"><a href="#AC-1" class="headerlink" title="AC"></a>AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int seed = time(0);</span><br><span class="line">    srand(seed);</span><br><span class="line">    int n;</span><br><span class="line">    const double eps = 1e-3;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    if (n &gt; 900) &#123;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double sumDis = 0;</span><br><span class="line">    int cnt = 1e8 / (n * n);</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        double x[1005], y[1005];</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            x[j] = rand() / (RAND_MAX + 1.0);;</span><br><span class="line">            y[j] = rand() / (RAND_MAX + 1.0);;</span><br><span class="line">            //cout &lt;&lt; x[j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        double minDis = 100;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            for (int k = j + 1; k &lt; n; k++) &#123;</span><br><span class="line">                double dis = sqrt((x[j] - x[k]) * (x[j] - x[k]) + (y[j] - y[k]) * (y[j] - y[k]));</span><br><span class="line">                if (dis &lt; minDis) minDis = dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sumDis += minDis;</span><br><span class="line">    &#125;</span><br><span class="line">    sumDis /= cnt;</span><br><span class="line">    cout &lt;&lt; sumDis &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-她的名字"><a href="#C-她的名字" class="headerlink" title="C. 她的名字"></a>C. 她的名字</h2><p>单测试点时限: 4.0 秒</p><p>内存限制: 512 MB</p><p>“他走过一个又一个星球，<br>却始终放不下对她的思念。“<br>”深情终究是一趟孤独的旅程，<br>她是他永远的牵绊。”</p><p>我们每个人心中都有一只小狐狸。我们渴望被自己喜欢的人驯服。</p><p>爱情是彼此之间至为甜蜜的臣服。我们都是傻痴痴的小狐狸，徒具一副精明的外表。</p><p>就像你走到哪都挂念着她，想把她写进自己的歌里，成为你们共同的记忆。</p><p>你想从她全部由数字构成的名字里取出其中的 N 个数字，维持原来的顺序，组成结尾为数字 XY 的新词。</p><p>你自然希望自己的歌能够很长很长，歌词的每一句都能饱含甜蜜。</p><p>所以你想知道，她的名字能够组成多少个长度为 N 且结尾为数字 XY 的新词（如果从她名字中取出的任意一个数字位置不同，两个词就被认为是不同的）。</p><p>输入<br>第一行包含一个由数字构成的字符串 S (1≤|S|≤2 000)。</p><p>第二行包含一个整数 Q (1≤Q≤5⋅105)，表示需要选择的不同结尾数量。</p><p>接下来的 Q 行，每行包含了一个整数 N (1≤N≤5⋅105) 和两个数字 XY，用空格隔开，表示需要选择的歌词的长度和结尾。</p><p>输出<br>对于每一个询问，输出一个整数，表示答案。</p><p>答案可能会很大，你只需要输出对于 109+7 取模后的结果。</p><p>样例<br>input<br>312121<br>4<br>2 21<br>3 31<br>4 22<br>3 22<br>output<br>3<br>0<br>1<br>2<br>提示<br>样例中第一个询问：312121, 312121, 312121.</p><p>第二个询问：无。</p><p>第三个询问：312121.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>可以发现，询问很多，但是主串 S 的长度并不长。考虑预处理所有的结尾情况。<br>我们可以枚举第一个位置 X ，预处理出 X 后面分别接 10 个数字的时候，可以组成字符串的数量。<br>假设当前枚举到的一个位置 i 满足 Si=X 。题目需要组成新字符串的长度为 N ，假设位置 i 后面有 Ay 个 Y ，则他对答案的贡献就是 (i−1n−2)Ay 。<br>显然，Ay 是可以先处理掉的，然后再继续暴力预处理所有结尾情况下新字符串的数量。<br>预处理完成以后，对于所有的询问都可以 O(1) 出结果。<br>但是我们发现询问给出的 N 很大，但可以显然地发现，当 N&gt;|S| 很大的时候是没有解的。</p><p>暴力时间复杂度：2000×2000×100<br>但还是卡了TLE，首先一直错找不出原因，花了一天多才发现是组合数算错了。然后TLE，优化<code>避免重复的询问</code>，存储答案。</p><h3 id="AC-2"><a href="#AC-2" class="headerlink" title="AC"></a>AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    LL cnt[10][10][2005];   // 两个位置形成末尾共有多少的前缀</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line"></span><br><span class="line">    int len = str.size();</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            int head = str[i] - &apos;0&apos;;</span><br><span class="line">            int tail = str[j] - &apos;0&apos;;</span><br><span class="line">            cnt[head][tail][i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static LL C[2005][2005];  // 组合数</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        C[i][i] = C[i][0] = 1;</span><br><span class="line">        for(int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];</span><br><span class="line">            C[i][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Q, N, X, Y;</span><br><span class="line">    char A, B;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    // 优化</span><br><span class="line">    static LL ret[10][10][2005]; // 存储结果，如果是相同的询问避免重复计算</span><br><span class="line">    bool vis[10][10][2005];</span><br><span class="line">    while (Q--) &#123;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;  // 不能写成一个数的输入，可能有前缀0</span><br><span class="line">        //cout &lt;&lt; A &lt;&lt; B &lt;&lt; endl;</span><br><span class="line">        X = A - &apos;0&apos;;</span><br><span class="line">        Y = B - &apos;0&apos;;</span><br><span class="line">        LL ans = 0;</span><br><span class="line">        if (N &gt; 1 &amp;&amp; N &lt;= len) &#123;</span><br><span class="line">            if (vis[X][Y][N]) ans = ret[X][Y][N];</span><br><span class="line">            else &#123;</span><br><span class="line">                int M = N - 2;</span><br><span class="line">                for (int i = 0; i &lt; len; i++) &#123;  // 时间复杂度O(5*10^5*10^3=10^8)</span><br><span class="line">                    if (cnt[X][Y][i] &amp;&amp; i &gt;= M) &#123; // 一定要满足组合数条件</span><br><span class="line">                        ans += C[i][M] * cnt[X][Y][i];</span><br><span class="line">                        ans %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[X][Y][N] = ans;</span><br><span class="line">                vis[X][Y][N] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入：</span><br><span class="line">312121</span><br><span class="line">4</span><br><span class="line">2 21</span><br><span class="line">3 31</span><br><span class="line">4 22</span><br><span class="line">3 22</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提交WA了9次，提交AC了才能看别人的代码。</span><br><span class="line"></span><br><span class="line">居然是组合数求错了。。。。。</span><br><span class="line">不可能啊。。。。。。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入：</span><br><span class="line">312121</span><br><span class="line">4</span><br><span class="line">2 21</span><br><span class="line">3 31</span><br><span class="line">4 22</span><br><span class="line">3 22</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提交WA了9次，提交AC了才能看别人的代码。</span><br><span class="line">居然是组合数求错了。。。。。</span><br><span class="line">不可能啊。。。。。。</span><br><span class="line"></span><br><span class="line">原来是没有计算C(0,0)=1。而是写成了默认值C(0,0)=0。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛地址：&lt;a href=&quot;https://acm.ecnu.edu.cn/contest/125/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://acm.ecnu.edu.cn/contest/125/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;新的运行时间认识，1E8？&lt;/li&gt;
&lt;li&gt;随机数题&lt;/li&gt;
&lt;li&gt;蒙特卡洛模拟算法&lt;/li&gt;
&lt;li&gt;多次询问记得避免重复计算&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://hankin2015.github.io/categories/ACM/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="EOJ" scheme="https://hankin2015.github.io/tags/EOJ/"/>
    
      <category term="月赛" scheme="https://hankin2015.github.io/tags/%E6%9C%88%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>使用指定照片生成二维码和文件整理分类</title>
    <link href="https://hankin2015.github.io/2018/11/23/20181123QR/"/>
    <id>https://hankin2015.github.io/2018/11/23/20181123QR/</id>
    <published>2018-11-23T03:48:41.000Z</published>
    <updated>2018-12-31T08:28:55.456Z</updated>
    
    <content type="html"><![CDATA[<p>二维码（QR code）<br>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ</a></li><li><a href="https://blog.csdn.net/qq_40949713/article/details/80512339" target="_blank" rel="noopener">https://blog.csdn.net/qq_40949713/article/details/80512339</a> </li></ul><a id="more"></a><h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><p>pip install qrcode  #方法多，体量小<br>pip install myqr    #操作简单，功能强大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from MyQR import myqr  # 注意在python中的调用方式</span><br><span class="line">help(myqr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myqr.run(</span><br><span class="line">    words=&apos;Hello world&apos;,         #在命令后输入链接或者句子作为参数，然后在程序的当前目录中产生相应的二维码图片文件，默认命名为” qrcode.png“</span><br><span class="line">    version=1,                   #设置容错率为最高默认边长是取决于你输入的信息的长度和使用的纠错等级；而默认纠错等级是最高级的H</span><br><span class="line">    level=&apos;H&apos;,                   #控制纠错水平，范围是L、M、Q、H，从左到右依次升高</span><br><span class="line">    picture=&apos;WChat.png&apos;,         #用来将QR二维码图像与一张同目录下的图片相结合，产生一张黑白图片</span><br><span class="line">    colorized=True,              #可以使产生的图片由黑白(False)变为彩色(True)的</span><br><span class="line">    contrast=1.0,                #用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。</span><br><span class="line">    brightness=1.0,              #用来调节图片的亮度，其余用法和取值与 -con 相同</span><br><span class="line">    save_name=&apos;test.png&apos;,        #控制文件名，格式可以是 .jpg， .png ，.bmp ，.gif ；</span><br><span class="line">    save_dir=os.getcwd()         #控制位置。</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="可以使用简写控制参数（命令行）"><a href="#可以使用简写控制参数（命令行）" class="headerlink" title="可以使用简写控制参数（命令行）"></a>可以使用简写控制参数（命令行）</h1><p>需要注意字符串不能指定中文，否则会抛出 ValueError(‘Wrong words! Make sure the characters are supported!’) 的异常。<br>1、使用 -d 可以控制输出的文件路径；<br>2、使用 -n 控制文件名称，格式可以是 .jpg、.png、.bmp、.gif；<br>3、使用 -l 可以控制二维码的纠错等级，范围是L、M、Q、H，从左到右依次升高；<br>4、使用 -v 控制二维码的边长，范围是 1 至 40，数字越大边长越大。<br>5、使用 -p 参数指定图片，将二维码与该图片结合在一起。<br>6、想要生成彩色的，可以加上参数 -c。<br>7、可以使用参数 -con 控制图片对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为 1.0；<br>8、使用参数 -bri 用来调节图片的亮度，其余用法和取值与 -con 相同。<br>9、还可以使用动态图片gif。</p><blockquote><p>myqr “I love you” -p p.jpg -c -l M</p></blockquote><h1 id="文件整理分类"><a href="#文件整理分类" class="headerlink" title="文件整理分类"></a>文件整理分类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">path = &apos;./&apos;</span><br><span class="line">files = os.listdir(path)</span><br><span class="line"></span><br><span class="line">for file in files:</span><br><span class="line">folderName = &apos;./&apos; + file.split(&apos;.&apos;)[-1]</span><br><span class="line">if not os.path.exists(folderName):</span><br><span class="line">os.makedirs(folderName)</span><br><span class="line">shutil.move(file, folderName)</span><br><span class="line"></span><br><span class="line">print(&apos;done&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二维码（QR code）&lt;br&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40949713/article/details/80512339&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_40949713/article/details/80512339&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="二维码" scheme="https://hankin2015.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="文件" scheme="https://hankin2015.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理</title>
    <link href="https://hankin2015.github.io/2018/11/10/20181110Principle/"/>
    <id>https://hankin2015.github.io/2018/11/10/20181110Principle/</id>
    <published>2018-11-10T14:47:41.000Z</published>
    <updated>2018-11-10T13:30:41.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。<br><a href="https://www.cnblogs.com/rhythmic/p/5503272.html" target="_blank" rel="noopener">《程序设计中的组合数学》——容斥定理</a><br><a href="http://blog.csdn.net/han_kin/article/details/47662801" target="_blank" rel="noopener">容斥定理</a><br><a id="more"></a></p><p>韦恩图能够鲜明的解释这个原理。</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>时间复杂度：2^n （n集合个数）<br>总共就2^n种组合（子串），然后判断每种可能中有多少集合来判断正负。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int solve (int n, int r)</span><br><span class="line">&#123;</span><br><span class="line">    /*求质数*/</span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            p.push_back (i);</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) p.push_back (n);</span><br><span class="line"></span><br><span class="line">    int sum = 0;   // 非互质的个数</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; (int)p.size()); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int mult = 1, bits = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; (int)p.size(); ++i) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ++bits;</span><br><span class="line">                mult *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = r / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) sum += cur;</span><br><span class="line">        else sum -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return r - sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="两个同一个问题"><a href="#两个同一个问题" class="headerlink" title="两个同一个问题"></a>两个同一个问题</h1><ol><li>给出整数n和r。求区间[1;r]中与n互素的数的个数。</li><li>给定一个区间[A,B],找出在这个区间内与给定的n互质的整数的个数。</li></ol><p>两个问题解决方案一样，去解决它的逆问题，求不与n互素的数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 求n的质因数</span><br><span class="line">void FindPrimeFactor(int n, int a[], int &amp;cnt)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            a[cnt++] = i;</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) a[cnt++] = n;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 复杂度也是2^k</span><br><span class="line">LL Solve2(LL n, int a[], int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    int t = 1, que[1005] = &#123; -1&#125;; // 依据容斥原理，que[0]的值是-1</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;  // 比如2 3 4，形成-1 2 3 -6 4 -8 -12 24</span><br><span class="line">        int k = t;</span><br><span class="line">        for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">            que[t++] = que[j] * a[i] * (-1);  // 难点</span><br><span class="line">            /*乘以-1和-1^k是一样的效果</span><br><span class="line">            重点在第一个for循环，新加进去的数和前面形成组合子串*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;t = &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    for (int i = 1; i &lt; t; i++) &#123;</span><br><span class="line">        cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line">        res += n / que[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve (int n, int r)</span><br><span class="line">&#123;</span><br><span class="line">    /*求质数*/</span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            p.push_back (i);</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) p.push_back (n);</span><br><span class="line"></span><br><span class="line">    int sum = 0;   // 非互质的个数</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; (int)p.size()); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int mult = 1, bits = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; (int)p.size(); ++i) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ++bits;</span><br><span class="line">                mult *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = r / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) sum += cur;</span><br><span class="line">        else sum -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return r - sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">题目：给定一个区间[A,B],找出在这个区间内与给定的N互质的整数的个数。</span><br><span class="line">T(0 &lt; T &lt;= 100)the number of test cases</span><br><span class="line">each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;= 10^15) and (1 &lt;=N &lt;= 10^9).</span><br><span class="line"></span><br><span class="line">直接求互质复杂度高，可以用素数筛选法求非互质的数。</span><br><span class="line">求[1,B]-[1,A-1]。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 直接算一定有错误，必须使用容斥原理</span><br><span class="line">LL Solve(LL n, int a[], int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        for (int j = 1; ; j++) &#123;</span><br><span class="line">            if (j * a[i] &gt; n) &#123;</span><br><span class="line">                res += j - 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">N = 12 --- 2 3</span><br><span class="line">18  2 4 6 8 10 12 14 16 18</span><br><span class="line">    3 6 9 12 15 18</span><br><span class="line">会返回结果为15.</span><br><span class="line">正确答案是12.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int maxn = 1005;</span><br><span class="line">    int a[maxn] = &#123;2, 3, 4&#125;, cnt = 3;</span><br><span class="line">    //FindPrimeFactor(12, a, cnt);</span><br><span class="line">    //cout &lt;&lt; Solve2(18, a, cnt) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; solve(12, 18) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    __int64 i, T, x, y, n, sum;</span><br><span class="line">    while(scanf(&quot;%I64d&quot;, &amp;T) != EOF) &#123;</span><br><span class="line">        for(i = 1; i &lt;= T; i++) &#123;</span><br><span class="line">            scanf(&quot;%I64d%I64d%I64d&quot;, &amp;x, &amp;y, &amp;n);</span><br><span class="line">            //sum = y - haha(y) - (x - 1 - haha(x - 1)); //由于区间是[x,y],求出[1,y]的互质个数，再减去[1,x-1]的互质个数</span><br><span class="line">            printf(&quot;Case #%I64d: &quot;, i);</span><br><span class="line">            printf(&quot;%I64d\n&quot;, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="另外一个缠绕我很久的问题，居然是容斥原理"><a href="#另外一个缠绕我很久的问题，居然是容斥原理" class="headerlink" title="另外一个缠绕我很久的问题，居然是容斥原理"></a>另外一个缠绕我很久的问题，居然是容斥原理</h1><p><a href="https://hankin2015.github.io/2017/12/18/20171218NEUQ1021/">NEUQ1027：谷学长的童年（概率问题）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;容斥原理&quot;&gt;&lt;a href=&quot;#容斥原理&quot; class=&quot;headerlink&quot; title=&quot;容斥原理&quot;&gt;&lt;/a&gt;容斥原理&lt;/h1&gt;&lt;p&gt;在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/rhythmic/p/5503272.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《程序设计中的组合数学》——容斥定理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/han_kin/article/details/47662801&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;容斥定理&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algrithm" scheme="https://hankin2015.github.io/categories/Algrithm/"/>
    
    
      <category term="容斥原理" scheme="https://hankin2015.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NEUQ1027：谷学长的童年（概率问题）</title>
    <link href="https://hankin2015.github.io/2018/11/09/20181109NEUQ1021/"/>
    <id>https://hankin2015.github.io/2018/11/09/20181109NEUQ1021/</id>
    <published>2018-11-09T02:47:41.000Z</published>
    <updated>2018-11-10T13:35:24.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="http://newoj.acmclub.cn/problems/1021" target="_blank" rel="noopener">题目描述</a></h1><p>小时候，谷学长买了很多干脆面，因为一旦集齐所有类型的卡片就有大奖可拿。<br>谷学长很聪明的意识到要想集齐全套卡片就得买相当多的干脆面，为了尽可能的省钱，他想计算出每种类型卡片均获得一张应买干脆面的期望数目。</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>每个测试用例的第一行包含一个N(1 &lt;= N &lt;= 20), 表示干脆面里可能放置N种类型的卡片，第二行有N个数p1, p2, …, pN, (p1 + p2 + … + pN &lt;= 1), 表示中到对应类型卡片的概率。<br>注意每袋干脆面最多只有一张卡片。<br><a id="more"></a></p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>对于每组测试用例，输出集齐N张不同类型的卡片所买干脆面的期望数目。结果保留三位有效数字。</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><pre><code>10.120.1 0.4</code></pre><h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><pre><code>10.00010.500</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>花了我很久很久的时间来解决这道题。。。</p><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。<br>需要注意的是，期望值并不一定等同于常识中的“期望”——“期望值”也许与每一个结果都不相等。期望值是该变量输出值的平均数。期望值并不一定包含于变量的输出值集合里。<br>大数定律规定，随着重复次数接近无穷大，数值的算术平均值几乎肯定地收敛于期望值。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>设C为一个常数，X和Y是两个随机变量。以下是数学期望的重要性质：[2] </p><ol><li>E(C) = C</li><li>E(CX) = CE(X)</li><li>E(X + Y) = E(X) + E(Y)<br>4.当X和Y相互独立时， E(XY) = E(X)E(Y)<br>性质3和性质4可以推到到任意有限个相互独立的随机变量之和或之积的情况。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/63691292" target="_blank" rel="noopener">如何计算不等概率的抽卡次数期望？</a><br><a href="https://www.zybang.com/question/dc33d975f38865257ab9a8d3d35a49d0.html" target="_blank" rel="noopener">为什么说A+B多算的这一块,是他?</a><br><a href="http://blog.sciencenet.cn/blog-752541-995651.html" target="_blank" rel="noopener">为了集齐小浣熊干脆面108将卡,得吃多少袋干脆面？</a><br><a href="https://www.zhihu.com/question/20930350" target="_blank" rel="noopener">假设小浣熊随机赠送的卡片共有 100 种（出现概率相同），那么集齐所有卡片所需购买小浣熊包数的数学期望是多少？</a><br><a href="https://en.wikipedia.org/wiki/Coupon_collector&#39;s_problem" target="_blank" rel="noopener">Coupon collector’s problem</a><br><a href="https://www.guokr.com/question/477410/" target="_blank" rel="noopener">干脆面大家都吃过，里头往往会有一张卡，一共几十种，集齐送奖品。假设只有三种卡，那么集齐卡片需要买的方便面包数X的期望是多少？如果是N种卡，期望又怎么算？</a><br><a href="http://blog.csdn.net/q1w2e3r4470/article/details/60331703" target="_blank" rel="noopener">50个概率题</a><br><a href="https://www.cnblogs.com/no-tears-girl/p/7476175.html" target="_blank" rel="noopener">试题1—经典概率问题：优惠券收集问题</a><br><a href="http://blog.csdn.net/xyb890826/article/details/41829627" target="_blank" rel="noopener">模拟要得到四张不同花色的牌所需要的选取次数，然后显示选中的四张牌（有可能一张牌被选了两次）。</a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>就是使用容斥原理即可，困难我很久的问题终于解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double Solve(int N, double p[])</span><br><span class="line">&#123;</span><br><span class="line">    double ans = 0;</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; N); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int bits = 0;</span><br><span class="line">        double mult = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">                mult += p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double cur = 1 / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) ans += cur;</span><br><span class="line">        else ans -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    double p[25];</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        for (int i = 0; i &lt; N; i++) cin &gt;&gt; p[i];</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; Solve(N, p) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://newoj.acmclub.cn/problems/1021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目描述&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;小时候，谷学长买了很多干脆面，因为一旦集齐所有类型的卡片就有大奖可拿。&lt;br&gt;谷学长很聪明的意识到要想集齐全套卡片就得买相当多的干脆面，为了尽可能的省钱，他想计算出每种类型卡片均获得一张应买干脆面的期望数目。&lt;/p&gt;
&lt;h1 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h1&gt;&lt;p&gt;每个测试用例的第一行包含一个N(1 &amp;lt;= N &amp;lt;= 20), 表示干脆面里可能放置N种类型的卡片，第二行有N个数p1, p2, …, pN, (p1 + p2 + … + pN &amp;lt;= 1), 表示中到对应类型卡片的概率。&lt;br&gt;注意每袋干脆面最多只有一张卡片。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://hankin2015.github.io/categories/ACM/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="NEUQ" scheme="https://hankin2015.github.io/tags/NEUQ/"/>
    
  </entry>
  
  <entry>
    <title>一款好玩的游戏：饥荒</title>
    <link href="https://hankin2015.github.io/2018/11/08/20181108DontStarve/"/>
    <id>https://hankin2015.github.io/2018/11/08/20181108DontStarve/</id>
    <published>2018-11-08T11:48:41.000Z</published>
    <updated>2018-11-26T14:26:11.678Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=3c76e13a20f5e0fefa1581533d095fcd/a71ea8d3fd1f41345b63eb5d281f95cad1c85eb9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="饥荒-（2013年Klei-Entertainment出品单机游戏）"><a href="#饥荒-（2013年Klei-Entertainment出品单机游戏）" class="headerlink" title="饥荒 （2013年Klei Entertainment出品单机游戏）"></a>饥荒 （2013年Klei Entertainment出品单机游戏）</h1><p>《饥荒》是由Klei Entertainment开发的一款动作冒险类求生游戏，于2013年4月23日在PC上发行，2015年7月9日在iOS发布口袋版。<br>游戏讲述的是关于一名科学家被恶魔传送到了一个神秘的世界，玩家将在这个异世界生存并逃出这个异世界的故事。</p><p>Don’t Starve不要饿死<br>The Forge熔炉</p><a id="more"></a><h1 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h1><p>上帝模式，顾名思义是给小学生用的。<br>上帝模式：一般情况下不掉血，不掉脑残，不掉饥饿。<br>方法一：c_godmode()<br>方法二：GetPlayer().components.health:SetInvincible(true) </p><p>关闭：GetPlayer().components.health:SetInvincible(false)<br>跳虫洞、重进游戏都会关闭。</p><h1 id="复活石代码"><a href="#复活石代码" class="headerlink" title="复活石代码"></a>复活石代码</h1><p>似乎只能是房主的复活石有用。<br>c_spawn(“resurrectionstone”,1)</p><h1 id="饥荒移动手杖代码"><a href="#饥荒移动手杖代码" class="headerlink" title="饥荒移动手杖代码"></a>饥荒移动手杖代码</h1><p>c_give(“cane”,1)</p><h1 id="取企鹅蛋"><a href="#取企鹅蛋" class="headerlink" title="取企鹅蛋"></a>取企鹅蛋</h1><p>烧树火攻、晚上取蛋。</p><h1 id="存档"><a href="#存档" class="headerlink" title="存档"></a><a href="https://jingyan.baidu.com/article/5d368d1ef62fd33f60c05788.html" target="_blank" rel="noopener">存档</a></h1><p>C:\Users\用户名\Documents（win7以上）在里面找到Klei文件夹。<br>在Klei文件夹中，会有两个文件 DoNotStarve 和 DoNotStarveTogether 联机版的名称是DoNotStarveTogether</p><h1 id="植物患病"><a href="#植物患病" class="headerlink" title="植物患病"></a>植物患病</h1><p>铲掉，不然会传染。</p><h1 id="冒险模式"><a href="#冒险模式" class="headerlink" title="冒险模式"></a>冒险模式</h1><p>饥荒联机版没有冒险模式，冒险模式作用是来解锁人物的，联机版全解锁。</p><h1 id="羚羊、鬣狗、秃鹫和龙蝇"><a href="#羚羊、鬣狗、秃鹫和龙蝇" class="headerlink" title="羚羊、鬣狗、秃鹫和龙蝇"></a>羚羊、鬣狗、秃鹫和龙蝇</h1><p>羚羊：逼墙角或者晚上生火击杀。<br>秃鹫：丢肉吸引击杀。<br>龙蝇：龙蝇是游戏中拥有最高DPS 的生物。如果你在龙蝇愤怒时退出游戏，重新进入游戏时龙蝇会立即猛击地面。　多人版饥荒中，龙蝇有27500生命，是游戏中血量最高的生物。这使得即使多名玩家协力也难以杀死她。</p><h1 id="可疑的大理石"><a href="#可疑的大理石" class="headerlink" title="可疑的大理石"></a>可疑的大理石</h1><p>用铁镐敲雕像可以得到图纸和大理石块。一些雕像敲完就没有了，最终会留下3个雕像。没错这三个雕像分别是发条主教，发条骑士和发条战车。主教和骑士的头丢了，战车鼻子丢了，必须修复它。<br>可疑的大理石就是材料，直接背移动很慢，可疑骑牛，然后修补雕像，月圆之夜敲碎会复活。</p><h1 id="图纸的作用"><a href="#图纸的作用" class="headerlink" title="图纸的作用"></a>图纸的作用</h1><p>给制图。</p><h1 id="可疑的土堆"><a href="#可疑的土堆" class="headerlink" title="可疑的土堆"></a>可疑的土堆</h1><p>在饥荒游戏中，可疑土堆只有一个作用，那就是追踪无尾象啦。在主世界中，土堆会随机出现，如果我们不管它，这些土堆的位置还会改变。如果是有用的土堆，调查后会发现无尾象的脚印，而无尾象的位置就可以通过脚印来判断了，脚趾方向就是无尾象前进的方向了。这时候我们如果继续跟着脚印调查，大概两个满屏地图那么大，就可以找到无尾象了。<br>当我们调查到最后一个可以土堆的时候，游戏中会有角色对话，说该动物就在附近。玩家如果想顺利找到无尾象，就必须每个可疑土堆都调查一下，每次的土堆最少六个，最多有十二个。玩家调查过的交易会在一分钟后消失，如果没有找到下一个线索，就会追丢无尾象了。<br>当然了，有时就算我们调查了线索也不一定可以找到无尾象，因为有时调查的可疑土堆会提示这并不是无尾象的脚印哦。</p><p>持续8-10个会找到，分两种：夏象和冬象。<br>攻击一下拉仇恨，然后跑到圈里面。</p><h1 id="草蜥蜴"><a href="#草蜥蜴" class="headerlink" title="草蜥蜴"></a>草蜥蜴</h1><p>草会变异，然后变成四处乱跑的草蜥蜴，所以建议大家在新版联机种植的时候把草用墙围起来，没必要去花时间杀草蜥蜴，因为草蜥蜴受到惊吓就会掉落草，感觉比等草自己长大效率还高些额。</p><h1 id="养牛"><a href="#养牛" class="headerlink" title="养牛"></a>养牛</h1><p>杀牦牛，得牛角，吹牛角。</p><h1 id="夏季BOSS蚁狮"><a href="#夏季BOSS蚁狮" class="headerlink" title="夏季BOSS蚁狮"></a>夏季BOSS蚁狮</h1><p>会产生地震。准备保暖石击杀。<br><a href="https://www.gamersky.com/handbook/201704/889517.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201704/889517.shtml</a></p><h1 id="大理石种植"><a href="#大理石种植" class="headerlink" title="大理石种植"></a>大理石种植</h1><p>一个大理石合成一个大理石豌豆。</p><h1 id="驯牛"><a href="#驯牛" class="headerlink" title="驯牛"></a>驯牛</h1><p><a href="https://jingyan.baidu.com/article/3c343ff7ca50ab0d36796349.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/3c343ff7ca50ab0d36796349.html</a><br>1、使用新物品猫尾鞭<br>2、喂食，可以选择草，树枝（这个都吃）,蔬菜</p><p>永久。</p><h1 id="《饥荒》多肉的球茎怎么用"><a href="#《饥荒》多肉的球茎怎么用" class="headerlink" title="《饥荒》多肉的球茎怎么用?"></a>《饥荒》多肉的球茎怎么用?</h1><p>答：可以当种子种在地上，等长大了就可以刷肉，或者当狗牙陷阱一样当陷阱。</p><h1 id="舞台之饰"><a href="#舞台之饰" class="headerlink" title="舞台之饰"></a>舞台之饰</h1><p>天黑带灯引走，最好引到以后不太去的角落，不过我挺喜欢这个茶几的，花瓶里的花枯萎后可以用花瓣换上鲜花，每次还回5点精神，每次花瓶的的花也会不太一样。</p><h1 id="雪球发射器"><a href="#雪球发射器" class="headerlink" title="雪球发射器"></a>雪球发射器</h1><p>夏季必备。防止东西被烧毁。</p><p>雪球发射器没油解决方法介绍：加燃料，木头草树枝大便腐烂食物草根树苗木板绳子各种。</p><h1 id="发光的物品"><a href="#发光的物品" class="headerlink" title="发光的物品"></a>发光的物品</h1><p>在洞穴里有。</p><h1 id="蜂箱、种植花"><a href="#蜂箱、种植花" class="headerlink" title="蜂箱、种植花"></a>蜂箱、种植花</h1><p>每天能收蜂蜜，捕蝴蝶种植成花。</p><h1 id="如何杀海象"><a href="#如何杀海象" class="headerlink" title="如何杀海象"></a>如何杀海象</h1><h1 id="宝石来源"><a href="#宝石来源" class="headerlink" title="宝石来源"></a>宝石来源</h1><p>红宝石啊 有两种方法获得：第一：挖坟最简单了，准备一把铲子，去森林什么地方（坟多的）挖，很容易挖到。也有蓝宝石和紫宝石（齿轮，什么遗物什么的）。第二：打着火的那种（地狱狗）也有几率获得红宝石，如果要蓝宝石白色的（冰冻狗）获得蓝宝石，打发条教主死了会掉落紫宝石（远程攻击小心，我被他打死过几次）和齿轮。（齿轮可做冰箱）</p><h1 id="升级切斯特"><a href="#升级切斯特" class="headerlink" title="升级切斯特"></a>升级切斯特</h1><p>准备条件：9个蓝宝石（冰箱）或9个噩梦燃料（大宝箱）。<br>天时：月圆之夜。</p><h1 id="好用的mod"><a href="#好用的mod" class="headerlink" title="好用的mod"></a>好用的mod</h1><ul><li>minimap：小地图</li><li>fast travel：路标</li><li>建筑几何学：</li><li>show me：显示物品属性</li></ul><h1 id="《饥荒》熔炉模式人物能力介绍及打法攻略-饥荒熔炉模式怎么玩"><a href="#《饥荒》熔炉模式人物能力介绍及打法攻略-饥荒熔炉模式怎么玩" class="headerlink" title="《饥荒》熔炉模式人物能力介绍及打法攻略 饥荒熔炉模式怎么玩"></a>《饥荒》熔炉模式人物能力介绍及打法攻略 饥荒熔炉模式怎么玩</h1><p><a href="https://www.gamersky.com/handbook/201710/972043.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201710/972043.shtml</a></p><h1 id="地图卷轴"><a href="#地图卷轴" class="headerlink" title="地图卷轴"></a>地图卷轴</h1><p>羽毛笔+纸。个人感觉好像把自己的地图视野给其他小伙伴共享。</p><h1 id="老奶奶"><a href="#老奶奶" class="headerlink" title="老奶奶"></a>老奶奶</h1><p>老奶奶的优势在于自带2级科技，前期可以不用担心科技问题，而且只要地点合适就可以安家。而她携带的几种书籍，入睡觉书配合触手书与雷电书清怪效果很不错。<br>但是缺点同样明显，使用书籍需要消耗精神，可是不能睡觉，也就无法就地补充精神值，这也导致很容易出现精神过低的情况。同时由于血量低以及伤害偏低，所以打怪时间比较长。<br>总体老说最需要注意的就是脑残值，必须随时关注。脑残值建议带高帽，这比脑残片靠谱，当然其他各种食物什么的都可以备着。</p><p>老奶奶有失眠症，她的特点就是失眠，不能睡觉。<br>老奶奶不睡觉怎么补充精神<br>以试试这样恢复精神：<br>高礼帽+ 狗牙小背心，<br>贝雷帽效果更好，<br>不行就和二师兄做朋友，<br>吃烤熟的绿蘑菇和太妃糖加的精神也很多。</p><h1 id="完全正常的树"><a href="#完全正常的树" class="headerlink" title="完全正常的树"></a>完全正常的树</h1><p><a href="http://zh.dontstarve.wikia.com/wiki/%E6%A8%B9/%E5%AE%8C%E5%85%A8%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%A8%B9" target="_blank" rel="noopener">http://zh.dontstarve.wikia.com/wiki/%E6%A8%B9/%E5%AE%8C%E5%85%A8%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%A8%B9</a><br>不清楚添加三个什么东西可以装饰，但可以砍伐得活木。</p><h1 id="饥荒眼骨死了怎么办"><a href="#饥荒眼骨死了怎么办" class="headerlink" title="饥荒眼骨死了怎么办"></a>饥荒眼骨死了怎么办</h1><p>饥荒游戏中眼骨就是斯切特，它有复活功能，一般在死后过个两天左右，在它死时的原地方就可以发现它。然后重新捡起来即可使用。</p><h1 id="饥荒独立服务器搭建"><a href="#饥荒独立服务器搭建" class="headerlink" title="饥荒独立服务器搭建"></a>饥荒独立服务器搭建</h1><p><a href="http://lebi.github.io/2016/06/14/%E9%A5%A5%E8%8D%92%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">http://lebi.github.io/2016/06/14/%E9%A5%A5%E8%8D%92%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</a><br><a href="https://www.jianshu.com/p/440d64cd3ac4" target="_blank" rel="noopener">https://www.jianshu.com/p/440d64cd3ac4</a></p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>月圆之夜：采集花<br>科学机器<br>Y-发消息<br>M-地图<br>~-代码模式<br>tab-查看队友信息</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　可用Ctrl+F查询所需物品名称（大部分代码名称已修改成联机中文MOD翻译）。</p><p>　　进入游戏后按“～”键调出控制台</p><p>　　输入c_give(“代码名称“，数量）——物品会按所输数量出现在物品栏，假若包裹放不下，会自动掉落在地上。此代码最方便，甚至还可以在鼠标指针处直接放置建筑类物品。</p><p>　　c_spawn(“XX”，数量)——放鼠标指针指示的地上</p><p>　　上帝模式：c_godmode()</p><p>　　饥饿值上限：GetPlayer().components.hunger:SetMax(500)</p><p>　　精神值上限：GetPlayer().components.sanity:SetMax(500)</p><p>　　生命值上限：GetPlayer().components.health:SetMaxHealth(300)</p><p>　　全物品直接制造：GetPlayer().components.builder:GiveAllRecipes()</p><p>　　删除物品：TheInput:GetWorldEntityUnderMouse():Remove()</p><p>　　传送：GetPlayer().Transform:SetPosition(坐标，例：0,0,0)</p><p>　　此列表已剔除一些对于联机无效的代码，测试过真实有效。</p><h1 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h1><p>　　割下的草：cutgrass</p><p>　　树枝：twigs</p><p>　　木头：log</p><p>　　木炭：charcoal</p><p>　　灰：ash</p><p>　　采集的芦苇：cutreeds</p><p>　　花瓣：petals</p><p>　　噩梦花瓣：petals_evil</p><p>　　活木头：livinglog</p><p>　　叶子：foliage</p><p>　　荧光果：lightbulb</p><p>　　发光浆果：wormlight</p><p>　　冰：ice</p><p>　　燧石：flint</p><p>　　硝石：nitre</p><p>　　岩石：rocks</p><p>　　大理石：marble</p><p>　　月之石：moonrocknugget</p><p>　　黄金：goldnugget</p><p>　　铥矿石：thulecite</p><p>　　铥矿石碎片：thulecite_pieces</p><p>　　红宝石：redgem</p><p>　　蓝宝石：bluegem</p><p>　　紫宝石：purplegem</p><p>　　绿宝石：greengem</p><p>　　橙宝石：orangegem</p><p>　　黄宝石：yellowgem</p><p>　　彩色宝石：opalpreciousgem</p><p>　　绳子：rope</p><p>　　木板：boards</p><p>　　石砖：cutstone</p><p>　　莎草纸：papyrus</p><p>　　噩梦燃料：nightmarefuel</p><p>　　蜂蜡：beeswax</p><p>　　蜡纸：waxpaper</p><p>　　电器元件：transistor</p><p>　　狗牙：houndstooth</p><p>　　蜘蛛丝：silk</p><p>　　蜘蛛腺体：spidergland</p><p>　　胡子：beardhair</p><p>　　牛毛：beefalowool</p><p>　　牛角：hornm</p><p>　　猫尾：coontail</p><p>　　海象牙：walrus_tusk</p><p>　　胡须：beardhair</p><p>　　烂鸡蛋：rottenegg</p><p>　　乌鸦羽毛：feather_crow</p><p>　　红雀羽毛：feather_robin</p><p>　　雪雀羽毛：feather_robin_winter</p><p>　　金丝雀羽毛：feather_canary</p><p>　　鸟粪：guano</p><p>　　触手皮：tentaclespots</p><p>　　粘滑含糊虫（黏糊虫粘液）：slurtleslime</p><p>　　破碎的背壳：slurtle_shellpieces</p><p>　　蚊子血袋：mosquitosack</p><p>　　缀食者皮：slurper_pelt</p><p>　　远古守护者角：minotaurhorn</p><p>　　掉落的羽毛：goose_feather</p><p>　　鳞片：dragon_scales</p><p>　　厚皮毛：bearger_fur</p><p>　　巨鹿眼球：deerclops_eyeball</p><p>　　毒蕈皮：shroom_skin</p><p>　　闪电羊角：lightninggoathorn</p><p>　　格罗门翅膀：glommerwings</p><p>　　格罗门花（花瞬间死亡）：glommerflower</p><p>　　格罗门燃料：glommerfuel</p><p>　　冷冻虫卵：lavae_cocoon</p><p>　　暗影之心：shadowheart</p><p>　　鹿茸：deer_antler</p><p>　　克劳斯钥匙：klaussackkey</p><p>　　齿轮：gears</p><p>　　骨片：boneshard</p><p>　　化石碎片（据说多种实际上只出一种）：fossil_piece</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>　　斧头：axe</p><p>　　金斧头：goldenaxe</p><p>　　露西斧：lucy</p><p>　　鹤嘴锄：pickaxe</p><p>　　黄金鹤嘴锄：goldenpickaxe</p><p>　　铁铲：shovel</p><p>　　黄金铁铲（讲真黄金做的还能叫铁铲）：goldenshovel</p><p>　　镐斧：multitool_axe_pickaxe</p><p>　　锤子：hammer</p><p>　　草叉：pitchfork</p><p>　　剃刀：razor</p><p>　　捕虫网：bugnet</p><p>　　鱼竿：fishingrod</p><p>　　陷阱：trap</p><p>　　鸟陷阱：birdtrap</p><p>　　南瓜灯：pumpkin_lantern</p><p>　　提灯：lantern</p><p>　　漂亮太阳伞：grass_umbrella</p><p>　　雨伞：umbrella</p><p>　　保温石：heatrock</p><p>　　水球：waterballoon</p><p>　　指南针：compass</p><p>　　空包裹：bundlewrap</p><p>　　彩纸：giftwrap</p><p>　　稻草卷：bedroll_straw</p><p>　　毛皮铺盖：bedroll_furry</p><p>　　鹅毛扇：featherfan</p><p>　　狗牙陷阱：trap_teeth</p><p>　　麦斯威尔的利齿陷阱：trap_teeth_maxwell</p><p>　　背包：backpack</p><p>　　猪皮包：piggyback</p><p>　　隔热包：icepack</p><p>　　坎普斯背包：krampus_sack</p><p>　　糖果袋：candybag</p><p>　　羽毛笔：featherpencil</p><p>　　便便蓝：fertilizer</p><p>　　取鞍器：saddlehorn</p><p>　　鞍：saddle_basic</p><p>　　浴血战鞍：saddle_war</p><p>　　闪亮之鞍：saddle_race</p><p>　　刷子：brush</p><p>　　舐盐器：saltlick</p><p>武器</p><p>　　长矛：spear</p><p>　　瓦丝格雷斯矛：spear_wathgrithr</p><p>　　气球（吹好的，可以装饰自己的窝~）：balloon</p><p>　　火腿球棒：hambat</p><p>　　触手尖刺：tentaclespike</p><p>　　晨星：nightstick</p><p>　　三脚猫的教诲：whip</p><p>　　暗影剑：nightsword</p><p>　　蝙蝠斧棍：batbat</p><p>　　铥矿棒：ruins_bat</p><p>　　冰魔杖（蓝）：icestaff</p><p>　　火魔杖（红）：firestaff</p><p>　　传送魔杖（紫）：telestaff</p><p>　　懒惰的探索者（橙）：orangestaff</p><p>　　星星呼唤者（黄）：yellowstaff</p><p>　　毁灭权杖（绿）：greenstaff</p><p>　　魔杖（单机用来找零件那个）：diviningrod</p><p>　　呼月者权杖：opalstaff</p><p>　　回旋镖：boomerang</p><p>　　吹箭：blowdart_pipe</p><p>　　燃烧吹箭：blowdart_fire</p><p>　　麻醉吹箭：blowdart_sleep</p><p>　　电磁吹箭：blowdart_yellow</p><p>　　旋风：staff_tornado</p><p>　　排箫：panflute</p><p>　　独奏乐器:onemanband</p><p>　　火药：gunpowder</p><p>　　蜜蜂地雷：beemine</p><p>　　恒迪尤斯·舒提尤斯（眼睛炮塔）：eyeturret</p><p>　　可放置的眼睛炮塔：eyeturret_item</p><p><a href="https://www.gamersky.com/handbook/201701/859832.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201701/859832.shtml</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=3c76e13a20f5e0fefa1581533d095fcd/a71ea8d3fd1f41345b63eb5d281f95cad1c85eb9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;h1 id=&quot;饥荒-（2013年Klei-Entertainment出品单机游戏）&quot;&gt;&lt;a href=&quot;#饥荒-（2013年Klei-Entertainment出品单机游戏）&quot; class=&quot;headerlink&quot; title=&quot;饥荒 （2013年Klei Entertainment出品单机游戏）&quot;&gt;&lt;/a&gt;饥荒 （2013年Klei Entertainment出品单机游戏）&lt;/h1&gt;&lt;p&gt;《饥荒》是由Klei Entertainment开发的一款动作冒险类求生游戏，于2013年4月23日在PC上发行，2015年7月9日在iOS发布口袋版。&lt;br&gt;游戏讲述的是关于一名科学家被恶魔传送到了一个神秘的世界，玩家将在这个异世界生存并逃出这个异世界的故事。&lt;/p&gt;
&lt;p&gt;Don’t Starve不要饿死&lt;br&gt;The Forge熔炉&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://hankin2015.github.io/categories/Others/"/>
    
    
      <category term="Game" scheme="https://hankin2015.github.io/tags/Game/"/>
    
      <category term="饥荒" scheme="https://hankin2015.github.io/tags/%E9%A5%A5%E8%8D%92/"/>
    
  </entry>
  
  <entry>
    <title>判断一个点是否在一个多边形内</title>
    <link href="https://hankin2015.github.io/2018/11/03/20181103poly/"/>
    <id>https://hankin2015.github.io/2018/11/03/20181103poly/</id>
    <published>2018-11-03T03:48:41.000Z</published>
    <updated>2018-11-03T11:54:27.313Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。</p><a id="more"></a><h1 id="简单的特例：三角形"><a href="#简单的特例：三角形" class="headerlink" title="简单的特例：三角形"></a>简单的特例：三角形</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>比较常用的算法是射线法，以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。<br>若有偶数个交点则在形外，否则在形内。<br>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>面积法：海伦公式、向量公式</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>向量法</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://hihocoder.com/contest/hiho225/problem/1" target="_blank" rel="noopener">http://hihocoder.com/contest/hiho225/problem/1</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">在三角形内部的点形成的都是钝角三角形</span><br><span class="line">点在x,y的中间并不能判断</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long double</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">LL Heron(LL a, LL b, LL c)</span><br><span class="line">&#123;</span><br><span class="line">    return 0.25 * sqrt((a + b + c) * (a + b - c) * (a + c - b) * (b + c - a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Distance(LL x1, LL y1, LL x2, LL y2)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        LL x[4], y[4];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        LL s = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; 4; j++) &#123;</span><br><span class="line">                LL a = Distance(x[0], y[0], x[i], y[i]), b = Distance(x[0], y[0], x[j], y[j]), c = Distance(x[i], y[i], x[j], y[j]);</span><br><span class="line">                s += Heron(a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Distance(x[1], y[1], x[2], y[2]), b = Distance(x[1], y[1], x[3], y[3]), c = Distance(x[2], y[2], x[3], y[3]);</span><br><span class="line">        //cout &lt;&lt; s &lt;&lt; &apos; &apos; &lt;&lt; Heron(a, b, c) &lt;&lt; endl;</span><br><span class="line">        if (abs(s - Heron(a, b, c)) &lt; eps) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入的都是整数，三角形面积计算s=0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">所有面积里都有这个0.5，去掉这个0.5对结果不影响，于是面积计算出来就是整数，没有精度问题了。</span><br><span class="line">向量法求面积。</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">LL area(LL x1,LL y1,LL x2,LL y2,LL x3,LL y3)</span><br><span class="line">&#123;</span><br><span class="line">    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LL Px, Py, Ax, Ay, Bx, By, Cx, Cy;</span><br><span class="line">    LL S, S1, S2, S3;</span><br><span class="line">    LL t;</span><br><span class="line">    for(cin&gt;&gt;t;t&gt;0;t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;Px&gt;&gt;Py&gt;&gt;Ax&gt;&gt;Ay&gt;&gt;Bx&gt;&gt;By&gt;&gt;Cx&gt;&gt;Cy;</span><br><span class="line">        S  = area(Ax, Ay, Bx, By, Cx, Cy);</span><br><span class="line">        S1 = area(Px, Py, Ax, Ay, Bx, By);</span><br><span class="line">        S2 = area(Px, Py, Ax, Ay, Cx, Cy);</span><br><span class="line">        S3 = area(Px, Py, Bx, By, Cx, Cy);</span><br><span class="line">        if(S1+S2+S3&lt;=S)cout&lt;&lt;&quot;YES\n&quot;;else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">还有个简单的方法，判断三条边的向量与P跟三个点连接的向量的叉积，如果三个叉积值同正负，则在三角形内。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define G(v,_) scanf(&quot;%ld&quot;,&amp;v),v-=_;</span><br><span class="line">main(T)&#123;long p,P,a,A,b,B,c,C,x,y,z;for(G(T,0)T--;puts(((-x|-y|-z)&amp;(x|y|z))&lt;0?&quot;NO&quot;:&quot;YES&quot;))&#123;G(p,0)G(P,0)G(a,p)G(A,P)G(b,p)G(B,P)G(c,p)G(C,P)x=a*B-b*A;y=b*C-c*B;z=c*A-a*C;&#125;return 0;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四边形特例：矩形"><a href="#四边形特例：矩形" class="headerlink" title="四边形特例：矩形"></a>四边形特例：矩形</h1><p>（1）面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。<br>（2）夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。<br>（3）引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</p><p><a href="https://blog.csdn.net/u283056051/article/details/53980832" target="_blank" rel="noopener">https://blog.csdn.net/u283056051/article/details/53980832</a><br>1、射线法理论：从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。<br>2、特殊情况特殊处理：</p><pre><code>1. 点在多边形的边上 ：判断点与边端点连线斜率是否相同。2. 点和多边形的顶点重合 ：直接hash。3. 射线经过多边形顶点：只需要规定被射线穿越的点都算作其中一侧。 4. 射线刚好经过多边形的一条边：上面的特例，经过两个顶点。射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。</code></pre><h1 id="多边形代码（射线法和回转数法）"><a href="#多边形代码（射线法和回转数法）" class="headerlink" title="多边形代码（射线法和回转数法）"></a>多边形代码（射线法和回转数法）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">测试题：http://hihocoder.com/problemset/problem/1450?sid=1416458</span><br><span class="line">射线法没有过，回转数法连样例都不了，还弄不明白哪里错了。</span><br><span class="line">参考：https://blog.csdn.net/u283056051/article/details/53980832</span><br><span class="line">*/</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1e3 + 5;</span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">const double PI = atan(1) * 4;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 射线法</span><br><span class="line">string RayCasting(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey)) return &quot;on&quot;;</span><br><span class="line">        // 2、做一条水平射线，判断边两断点是否在射线两侧，并令穿过顶点的点在上端</span><br><span class="line">        if ((sy &lt; p.y &amp;&amp; ey &gt;= p.y) || (sy &gt;= p.y &amp;&amp; ey &lt; p.y)) &#123;</span><br><span class="line">            // 3、判断p点是否在多边形边上，斜率公式或者三角形比例公式（方便）</span><br><span class="line">            double x = sx + (p.y - sy) * (ex - sx) * 1.0 / (ey - sy);</span><br><span class="line">            if (abs(x - p.x) &lt; eps) return &quot;on&quot;;</span><br><span class="line">            // 水平向右作的射线，穿过一次就变换</span><br><span class="line">            if (x &gt; p.x) flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? &quot;in&quot; : &quot;out&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回转数法</span><br><span class="line">string WindingNumber(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0;  // 回转度数和</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合或在多边形边上</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey) || (p.x - sx) * (ey - sy) == (p.y - sy) * (ex - sx)) return &quot;on&quot;;</span><br><span class="line">        // 2、求夹角</span><br><span class="line">        double angle = atan((sy - p.y) * 1.0 / (sx - p.x)) - atan((ey - p.y) * 1.0 / (ex - p.x));</span><br><span class="line">        cout &lt;&lt; angle &lt;&lt; endl;</span><br><span class="line">        // 3、确保夹角不超过取值范围（-PI到PI）</span><br><span class="line">        if (angle &gt;= PI) angle -= 2 * PI;</span><br><span class="line">        else if (angle &lt;= -PI) angle += 2 * PI;</span><br><span class="line">        sum += angle;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    // 4、计算回转数</span><br><span class="line">    return round(sum / PI) == 0 ? &quot;out&quot; : &quot;in&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node p, poly[maxn];</span><br><span class="line">    int n = 3, T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        cin &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; poly[i].x &gt;&gt; poly[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        string res1 = RayCasting(p, poly, 3);</span><br><span class="line">        string res2 = WindingNumber(p, poly, 3);</span><br><span class="line">        if (res1 != res2) cout &lt;&lt; &quot;Wrong&quot; &lt;&lt; endl;</span><br><span class="line">        else if (res1 == &quot;out&quot;) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="https://hankin2015.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="凸包" scheme="https://hankin2015.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
</feed>
