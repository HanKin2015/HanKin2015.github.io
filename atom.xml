<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HanKin的博客</title>
  
  <subtitle>聪明出于勤奋，天才在于积累。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hankin2015.github.io/"/>
  <updated>2018-11-26T14:02:25.077Z</updated>
  <id>https://hankin2015.github.io/</id>
  
  <author>
    <name>HanKin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据处理常用基础操作(清洗、可视化、特征工程)[置顶]</title>
    <link href="https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/"/>
    <id>https://hankin2015.github.io/2222/11/10/22221110DataProcess_HJ/</id>
    <published>2222-11-10T13:47:41.000Z</published>
    <updated>2018-11-26T14:02:25.077Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h1 id="一、数据挖掘之pandas-DataFrame"><a href="#一、数据挖掘之pandas-DataFrame" class="headerlink" title="一、数据挖掘之pandas.DataFrame"></a>一、数据挖掘之pandas.DataFrame</h1><p><a href="http://www.jianshu.com/p/682c24aef525" target="_blank" rel="noopener">用python做数据分析4|pandas库介绍之DataFrame基本操作</a><br><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://old.sebug.net/paper/books/scipydoc/index.html#" target="_blank" rel="noopener">用Python做科学计算</a></p><p>数据地址：github.com<br>源代码地址：github.com</p><h2 id="1、jupyter-notebook显示plot图像"><a href="#1、jupyter-notebook显示plot图像" class="headerlink" title="1、jupyter notebook显示plot图像"></a>1、jupyter notebook显示plot图像</h2><blockquote><p>%matplotlib inline</p></blockquote><h2 id="2、处理excel数据"><a href="#2、处理excel数据" class="headerlink" title="2、处理excel数据"></a>2、处理excel数据</h2><p>后缀为xls或者xlsx</p><blockquote><p>import pandas as pd<br>data.to_excel(‘data.xlsx’, index=False)</p></blockquote><h2 id="3、处理csv数据"><a href="#3、处理csv数据" class="headerlink" title="3、处理csv数据"></a>3、处理csv数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_csv(‘./data.csv’, sep=’\t’)  #按照相应的间隔符读取数据，默认空格或者tab符</p></blockquote><h2 id="‘utf-8’-codec-can’t-decode-byte-0xd1-in-position-9-invalid-continuation-byte"><a href="#‘utf-8’-codec-can’t-decode-byte-0xd1-in-position-9-invalid-continuation-byte" class="headerlink" title="‘utf-8’ codec can’t decode byte 0xd1 in position 9: invalid continuation byte"></a>‘utf-8’ codec can’t decode byte 0xd1 in position 9: invalid continuation byte</h2><p>意思是utf-8编码不行，需要其他类型编码格式，默认应该是utf-8或者None。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(&apos;air_tianjin_2017.csv&apos;, engine=&apos;python&apos;, encoding=&apos;gbk&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="有中文路径问题"><a href="#有中文路径问题" class="headerlink" title="有中文路径问题"></a>有中文路径问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path = &apos;文件/data数据.csv&apos;</span><br><span class="line">path = unicode(path, &apos;utf8&apos;)</span><br><span class="line"></span><br><span class="line">pd.read_csv( &apos;文件/data数据.csv&apos;, &apos;rb&apos;)</span><br><span class="line"></span><br><span class="line">file = open(path)</span><br><span class="line">pd.read_csv(file)</span><br></pre></td></tr></table></figure><h2 id="字符串前面添加u-r-b的含义"><a href="#字符串前面添加u-r-b的含义" class="headerlink" title="字符串前面添加u,r,b的含义"></a>字符串前面添加u,r,b的含义</h2><p>u/U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf8</p><p>r/R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p><p>b:bytes<br>python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes<br>python2.x里, b前缀没什么具体意义， 只是为了兼容python3.x的这种写法</p><h2 id="4、处理txt数据"><a href="#4、处理txt数据" class="headerlink" title="4、处理txt数据"></a>4、处理txt数据</h2><blockquote><p>import pandas as pd<br>df_data = pd.read_table(‘./data.txt’)<br>data.to_csv(‘data.txt’, sep=’\t’, index=False)</p></blockquote><h2 id="5、数据可视化"><a href="#5、数据可视化" class="headerlink" title="5、数据可视化"></a>5、数据可视化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#marker为形状、s为形状大小，线条没有，c为颜色，也可以写全称size、color</span></span><br><span class="line"><span class="comment">#scatter为散点图、plot为折线图</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x轴数据, y轴数据, marker = <span class="string">'o'</span>, s=<span class="number">200</span>, c=<span class="string">'red'</span>, label=标签名) </span><br><span class="line">plt.plot(x轴数据, y轴数据, marker = <span class="string">'x'</span>, c=<span class="string">'black'</span>, label=<span class="string">'Comprehensive'</span>)</span><br><span class="line">plt.legend()  <span class="comment"># 让图例生效</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(x轴名称)</span><br><span class="line">plt.ylabel(y轴名称)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def scatter(X, Y):</span><br><span class="line">    #产生测试数据  </span><br><span class="line">    x = np.arange(1,10)  </span><br><span class="line">    y = x  </span><br><span class="line">    fig = plt.figure()  </span><br><span class="line">    ax = fig.add_subplot(111)   # 设置子图</span><br><span class="line">    #设置标题  </span><br><span class="line">    ax.set_title(&apos;Scatter Plot&apos;)  </span><br><span class="line">    #设置X轴标签  </span><br><span class="line">    plt.xlabel(&apos;X&apos;)  </span><br><span class="line">    #设置Y轴标签  </span><br><span class="line">    plt.ylabel(&apos;Y&apos;)  </span><br><span class="line">    #添加批注</span><br><span class="line">    for i in range(4):    # xy表示批注点位置，xxtext表示批注文字位置，arrowprops加箭头</span><br><span class="line">        ax.annotate(Y[i],xy=(X[i,0],X[i,1]), xytext=(X[i,0],X[i,1]), arrowprops=dict(facecolor=&apos;black&apos;, shrink=0.05))</span><br><span class="line">    #画散点图  </span><br><span class="line">    ax.scatter(X[:,0],X[:,1],s = 75,c = &apos;r&apos;,marker = &apos;o&apos;,alpha=.5)  </span><br><span class="line">    #设置图标  </span><br><span class="line">    plt.legend(&apos;X&apos;)  </span><br><span class="line">    #显示所画的图  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="画函数曲线"><a href="#画函数曲线" class="headerlink" title="画函数曲线"></a>画函数曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.arange(0, 12)</span><br><span class="line">y1 = 2 * x + 5   #直线函数</span><br><span class="line">y2 = x ** 2 + 5  #曲线函数</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1, c=&apos;yellow&apos;)</span><br><span class="line">plt.plot(x, y2, c=&apos;red&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="6、dataframe增加一行数据或者一列数据"><a href="#6、dataframe增加一行数据或者一列数据" class="headerlink" title="6、dataframe增加一行数据或者一列数据"></a>6、dataframe增加一行数据或者一列数据</h2><h3 id="增加一行"><a href="#增加一行" class="headerlink" title="增加一行"></a>增加一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(columns=[&apos;name&apos;,&apos;sex&apos;,&apos;age&apos;, &apos;other&apos;])</span><br><span class="line"># 方法1(必须加列名)  居然无效???</span><br><span class="line">df.append(&#123;&apos;name&apos;: &apos;hejian&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;age&apos;: 24, &apos;other&apos;: &apos;handsome&apos;&#125;, ignore_index=True, verify_integrity=False)</span><br><span class="line"></span><br><span class="line">#方法2</span><br><span class="line">df.loc[2] = [&apos;hejian&apos;,  &apos;man&apos;,  24, &apos;handsome&apos;]</span><br></pre></td></tr></table></figure><h2 id="7、排序"><a href="#7、排序" class="headerlink" title="7、排序"></a>7、排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sorted([5, 2, 3, 1, 4])</span><br><span class="line">a = [5, 2, 3, 1, 4]</span><br><span class="line">a.sort()</span><br><span class="line"></span><br><span class="line">sorted(res, key = lambda x:x[0])</span><br><span class="line">df.sort_values(by=)</span><br></pre></td></tr></table></figure><h2 id="8、输出格式"><a href="#8、输出格式" class="headerlink" title="8、输出格式"></a>8、输出格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = [1, 2, 3, 4]</span><br><span class="line">res = []</span><br><span class="line">for elem in ans:</span><br><span class="line">    res.append(str(elem))</span><br><span class="line">print(&apos; &apos;.join(res))  #按照空格间隔输出</span><br><span class="line">print(&apos;*&apos;.join(res))  #按照星号间隔输出</span><br></pre></td></tr></table></figure><h2 id="9、基本操作"><a href="#9、基本操作" class="headerlink" title="9、基本操作"></a>9、基本操作</h2><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randint(0,10,(4, 3)), columns=list(&apos;bde&apos;), index=range(4))</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([1, 2, 3, 4, 5], columns=[&apos;cols&apos;], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">df.index</span><br><span class="line">df.columns</span><br><span class="line">df = pd.DataFrame(np.random.randint(low=0, high=10, size=(5, 5)), columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br><span class="line">df = pd.DataFrame(data=d, dtype=np.int8)</span><br><span class="line">df = pd.DataFrame(&#123;&apos;x&apos;:x, &apos;y&apos;:y&#125;, columns=[&apos;x&apos;, &apos;y&apos;])</span><br></pre></td></tr></table></figure><h3 id="根据索引查看数据"><a href="#根据索引查看数据" class="headerlink" title="根据索引查看数据"></a>根据索引查看数据</h3><blockquote><p>df.loc[‘a’]   # 索引为ａ这一行的数据<br>df.iloc[0]      #跟上面的操作等价，一个是根据索引名，一个是根据数字索引访问数据</p></blockquote><h3 id="对每个元素乘以２"><a href="#对每个元素乘以２" class="headerlink" title="对每个元素乘以２"></a>对每个元素乘以２</h3><blockquote><p>print df.apply(lambda x:x*2)</p></blockquote><h3 id="对每个元素求平方-支持ndarray一样的向量化操作"><a href="#对每个元素求平方-支持ndarray一样的向量化操作" class="headerlink" title="对每个元素求平方(支持ndarray一样的向量化操作)"></a>对每个元素求平方(支持ndarray一样的向量化操作)</h3><blockquote><p>print df**2</p></blockquote><h3 id="默认合并之接受索引已经存在的值"><a href="#默认合并之接受索引已经存在的值" class="headerlink" title="默认合并之接受索引已经存在的值"></a>默认合并之接受索引已经存在的值</h3><p>通过指定参数 how，指定合并的方式：inner(交集)、outer(并集)</p><blockquote><p>print dfb.join(df_a,how=’inner’)   # 合并两个DataFrame对象的交集</p></blockquote><h3 id="对DataFrame对象进行列扩充"><a href="#对DataFrame对象进行列扩充" class="headerlink" title="对DataFrame对象进行列扩充"></a>对DataFrame对象进行列扩充</h3><blockquote><p>df[‘col4’] = [‘cnn’,’rnn’]      #直接添加一列数据</p></blockquote><h3 id="字段类型转换"><a href="#字段类型转换" class="headerlink" title="字段类型转换"></a>字段类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">arr = np.array([1, 2, 3])</span><br><span class="line">print(type(arr))</span><br><span class="line">print(arr.dtype)</span><br><span class="line">brr = arr.astype(np.float64)</span><br><span class="line">print(type(brr))</span><br><span class="line">print(brr.dtype)</span><br><span class="line">print(arr)</span><br><span class="line">print(brr)</span><br><span class="line">crr = arr.astype(str)</span><br><span class="line">print(type(crr))</span><br><span class="line">print(crr.dtype)</span><br><span class="line">crr</span><br></pre></td></tr></table></figure><h2 id="10、连接合并多个dataframe"><a href="#10、连接合并多个dataframe" class="headerlink" title="10、连接合并多个dataframe"></a>10、连接合并多个dataframe</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = df1.append(df2, ignore_index=True)  # 需要重新index</span><br><span class="line">df</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="11、增删改查"><a href="#11、增删改查" class="headerlink" title="11、增删改查"></a>11、增删改查</h2><p><a href="">基本操作</a></p><h1 id="二、基础的特征工程"><a href="#二、基础的特征工程" class="headerlink" title="二、基础的特征工程"></a>二、基础的特征工程</h1><h2 id="1、查看数据类型和一些值"><a href="#1、查看数据类型和一些值" class="headerlink" title="1、查看数据类型和一些值"></a>1、查看数据类型和一些值</h2><blockquote><p>df.info()<br>df.describe()</p><h2 id="2、查看是否有缺失值"><a href="#2、查看是否有缺失值" class="headerlink" title="2、查看是否有缺失值"></a>2、查看是否有缺失值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isnull</span><br><span class="line">isna</span><br><span class="line">isin(values)</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、良-恶性乳腺癌肿瘤预测实例"><a href="#3、良-恶性乳腺癌肿瘤预测实例" class="headerlink" title="3、良/恶性乳腺癌肿瘤预测实例"></a>3、良/恶性乳腺癌肿瘤预测实例</h2><p><a href="">ipython notebook分析</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 创建特征列表。</span><br><span class="line">column_names = [&apos;Sample code number&apos;, &apos;Clump Thickness&apos;, &apos;Uniformity of Cell Size&apos;, &apos;Uniformity of Cell Shape&apos;, &apos;Marginal Adhesion&apos;, &apos;Single Epithelial Cell Size&apos;, &apos;Bare Nuclei&apos;, &apos;Bland Chromatin&apos;, &apos;Normal Nucleoli&apos;, &apos;Mitoses&apos;, &apos;Class&apos;]</span><br><span class="line"></span><br><span class="line"># 使用pandas.read_csv函数从互联网读取指定数据。</span><br><span class="line">data = pd.read_csv(&apos;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&apos;, names = column_names )</span><br><span class="line"></span><br><span class="line"># 将?替换为标准缺失值表示。</span><br><span class="line">data = data.replace(to_replace=&apos;?&apos;, value=np.nan)</span><br><span class="line"># 丢弃带有缺失值的数据（只要有一个维度有缺失）。</span><br><span class="line">data = data.dropna(how=&apos;any&apos;)</span><br><span class="line"></span><br><span class="line"># 输出data的数据量和维度。</span><br><span class="line">data.shape</span><br><span class="line"></span><br><span class="line"># 使用sklearn.cross_valiation里的train_test_split模块用于分割数据。</span><br><span class="line">from sklearn.cross_validation import train_test_split</span><br><span class="line"></span><br><span class="line"># 随机采样25%的数据用于测试，剩下的75%用于构建训练集合。</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data[column_names[1:10]], data[column_names[10]], test_size=0.25, random_state=33)</span><br><span class="line"></span><br><span class="line"># 查验训练样本的数量和类别分布。</span><br><span class="line">y_train.value_counts()</span><br><span class="line"></span><br><span class="line"># 查验测试样本的数量和类别分布。</span><br><span class="line">y_test.value_counts()</span><br><span class="line"></span><br><span class="line"># 从sklearn.preprocessing里导入StandardScaler。</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"># 从sklearn.linear_model里导入LogisticRegression与SGDClassifier。</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">from sklearn.linear_model import SGDClassifier</span><br><span class="line"></span><br><span class="line"># 标准化数据，保证每个维度的特征数据方差为1，均值为0。使得预测结果不会被某些维度过大的特征值而主导。</span><br><span class="line">ss = StandardScaler()</span><br><span class="line">X_train = ss.fit_transform(X_train)</span><br><span class="line">X_test = ss.transform(X_test)</span><br><span class="line"></span><br><span class="line"># 初始化LogisticRegression与SGDClassifier。</span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">sgdc = SGDClassifier()</span><br><span class="line"></span><br><span class="line"># 调用LogisticRegression中的fit函数/模块用来训练模型参数。</span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型lr对X_test进行预测，结果储存在变量lr_y_predict中。</span><br><span class="line">lr_y_predict = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 调用SGDClassifier中的fit函数/模块用来训练模型参数。</span><br><span class="line">sgdc.fit(X_train, y_train)</span><br><span class="line"># 使用训练好的模型sgdc对X_test进行预测，结果储存在变量sgdc_y_predict中。</span><br><span class="line">sgdc_y_predict = sgdc.predict(X_test)</span><br><span class="line"></span><br><span class="line"># 从sklearn.metrics里导入classification_report模块。</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line"></span><br><span class="line"># 使用逻辑斯蒂回归模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuracy of LR Classifier:&apos;, lr.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得LogisticRegression其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, lr_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br><span class="line"></span><br><span class="line"> # 使用随机梯度下降模型自带的评分函数score获得模型在测试集上的准确性结果。</span><br><span class="line">print &apos;Accuarcy of SGD Classifier:&apos;, sgdc.score(X_test, y_test)</span><br><span class="line"># 利用classification_report模块获得SGDClassifier其他三个指标的结果。</span><br><span class="line">print classification_report(y_test, sgdc_y_predict, target_names=[&apos;Benign&apos;, &apos;Malignant&apos;])</span><br></pre></td></tr></table></figure></p><h2 id="4、召回率、精确率和F1值"><a href="#4、召回率、精确率和F1值" class="headerlink" title="4、召回率、精确率和F1值"></a>4、召回率、精确率和F1值</h2><p>假设我们手上有60个正样本，40个负样本，我们要找出所有的正样本，系统查找出50个，其中只有40个是真正的正样本，计算上述各指标。</p><p>TP: 将正类预测为正类数  40<br>FN: 将正类预测为负类数  20<br>FP: 将负类预测为正类数  10<br>TN: 将负类预测为负类数  30</p><p>准确率(accuracy) = 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN) = 70%<br>精确率(precision) = TP/(TP+FP) = 80%<br>召回率(recall) = TP/(TP+FN) = 2/3<br>F值  = 正确率 <em> 召回率 </em> 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）<br>白话：精确率就是在所有预测为正例中有多少是预测正确的，召回率就是在全部本身就是正样本中有多少预测正确。</p><h2 id="5、sklearn-model-selection-train-test-split随机划分训练集和测试集"><a href="#5、sklearn-model-selection-train-test-split随机划分训练集和测试集" class="headerlink" title="5、sklearn.model_selection.train_test_split随机划分训练集和测试集"></a>5、sklearn.model_selection.train_test_split随机划分训练集和测试集</h2><p>train_test_split是交叉验证中常用的函数，功能是从样本中随机的按比例选取train data和testdata，形式为：</p><blockquote><p>X_train,X_test, y_train, y_test =<br>cross_validation.train_test_split(train_data,train_target,test_size=0.4, random_state=0)</p></blockquote><p>参数解释：<br>train_data：所要划分的样本特征集<br>train_target：所要划分的样本结果<br>test_size：样本占比，如果是整数的话就是样本的数量<br>random_state：是随机数的种子。</p><p>随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。<br>随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：<br>种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><h1 id="三、实例篇"><a href="#三、实例篇" class="headerlink" title="三、实例篇"></a>三、实例篇</h1><p>数据文件：data.csv   data.txt  data.xlsx<br>数据内容(高中成绩)：</p><table><thead><tr><th style="text-align:center">Date</th><th style="text-align:center">Chinese</th><th style="text-align:center">Math</th><th style="text-align:center">English</th><th style="text-align:center">Comprehensive </th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">111</td><td style="text-align:center">130</td><td style="text-align:center">127</td><td style="text-align:center">269    </td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td style="text-align:center">159</td><td style="text-align:center">ok</td><td style="text-align:center">191</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">137</td><td style="text-align:center">119</td><td style="text-align:center">99</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">97</td><td style="text-align:center">149</td><td style="text-align:center">89</td><td style="text-align:center">235</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">120</td><td style="text-align:center">135</td><td style="text-align:center">116</td><td style="text-align:center">282 </td></tr></tbody></table><h2 id="1、生成数据并保存读取"><a href="#1、生成数据并保存读取" class="headerlink" title="1、生成数据并保存读取"></a>1、生成数据并保存读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    data = pd.DataFrame(columns=[&apos;Date&apos;,&apos;Chinese&apos;,&apos;Math&apos;, &apos;English&apos;, &apos;Comprehensive&apos;])</span><br><span class="line">    data.loc[0] = [7,  111, 130, 127, 269]</span><br><span class="line">    data.loc[1] = [8,  &apos;&apos;, 159, &apos;ok&apos;, 191]</span><br><span class="line">    data.loc[2] = [9, 137, 119, 99, 250]</span><br><span class="line">    data.loc[3] = [10, 97, 149, 89, 235]</span><br><span class="line">    data.loc[4] = [11, 120, 135, 116, 282]</span><br><span class="line"></span><br><span class="line">    data.to_csv(&apos;&apos;)</span><br></pre></td></tr></table></figure><h1 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h1><h2 id="去除警告"><a href="#去除警告" class="headerlink" title="去除警告"></a>去除警告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line"></span><br><span class="line">def ignore_warn(*arg, *swarg):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">warning.warn = ignore_warn</span><br></pre></td></tr></table></figure><h3 id="忽略命令行下警告错误的输出"><a href="#忽略命令行下警告错误的输出" class="headerlink" title="忽略命令行下警告错误的输出"></a>忽略命令行下警告错误的输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -W ignore yourscript.py</span><br><span class="line">with open as [for   ]</span><br></pre></td></tr></table></figure><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for i in range (len(list1)):</span><br><span class="line">    print i ,list1[i]</span><br><span class="line"></span><br><span class="line">上述方法有些累赘，利用enumerate()会更加直接和优美：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0 这</span><br><span class="line">1 是</span><br><span class="line">2 一个</span><br><span class="line">3 测试</span><br><span class="line"></span><br><span class="line">enumerate还可以接收第二个参数，用于指定索引起始值，如：</span><br><span class="line">list1 = [&quot;这&quot;, &quot;是&quot;, &quot;一个&quot;, &quot;测试&quot;]</span><br><span class="line">for index, item in enumerate(list1, 1):</span><br><span class="line">    print index, item</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">1 这</span><br><span class="line">2 是</span><br><span class="line">3 一个</span><br><span class="line">4 测试</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如果要统计文件的行数，可以这样写：</p><blockquote><p>count = len(open(filepath, ‘r’).readlines())<br>这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。</p></blockquote><p>可以利用enumerate()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">for index, line in enumerate(open(filepath,&apos;r&apos;))： </span><br><span class="line">    count += 1</span><br></pre></td></tr></table></figure></p><h2 id="python-字符串查找的4个方法"><a href="#python-字符串查找的4个方法" class="headerlink" title="python 字符串查找的4个方法"></a>python 字符串查找的4个方法</h2><h3 id="1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"><a href="#1-find-方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1" class="headerlink" title="1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1"></a>1 find()方法：查找子字符串，若找到返回从0开始的下标值，若找不到返回-1</h3><p>info = ‘abca’<br>print info.find(‘a’)##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</p><p>info = ‘abca’<br>print info.find(‘a’,1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3</p><p>info = ‘abca’<br>print info.find(‘333’)##返回-1,查找不到返回-1</p><h3 id="2-index-方法："><a href="#2-index-方法：" class="headerlink" title="2 index()方法："></a>2 index()方法：</h3><p>python 的index方法是在字符串里查找子串第一次出现的位置，类似字符串的find方法，不过比find方法更好的是，如果查找不到子串，会抛出异常，而不是返回-1</p><p>info = ‘abca’<br>print info.index(‘a’)<br>print info.index(‘33’)</p><h3 id="3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"><a href="#3-4-rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。" class="headerlink" title="3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。"></a>3 4 rfind和rindex方法用法和上面一样，只是从字符串的末尾开始查找。</h3><p>如果查找全部，可以先找到第一个，然后从当前为起点继续查找。另外一种方法就是正则表达式。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img10.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://hankin2015.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="DataFrame" scheme="https://hankin2015.github.io/tags/DataFrame/"/>
    
      <category term="Pandas" scheme="https://hankin2015.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法总结[置顶]</title>
    <link href="https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/"/>
    <id>https://hankin2015.github.io/2222/04/24/22220424Algorithm_HJ/</id>
    <published>2222-04-24T02:47:41.000Z</published>
    <updated>2018-08-11T16:42:21.942Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">参考：@移动开发小冉</a></p><blockquote><p>算法虐我千百遍，我待算法如初恋</p></blockquote><p>这里的内容是我学习算法过程的一些记录，希望能一直坚持下去。</p><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><ul><li>把所有经典算法写一遍  </li><li>看算法有关源码   </li><li>加入算法学习社区，相互鼓励学习   </li><li>看经典书籍  </li><li>刷题   </li></ul><h2 id="基本数据结构和算法"><a href="#基本数据结构和算法" class="headerlink" title="基本数据结构和算法"></a>基本数据结构和算法</h2><p>这些算法全部自己敲一遍：</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表</li><li>双向链表</li></ul><h3 id="哈希表-散列表-Hash-Table"><a href="#哈希表-散列表-Hash-Table" class="headerlink" title="哈希表/散列表 (Hash Table)"></a>哈希表/散列表 (Hash Table)</h3><ul><li>散列函数</li><li>碰撞解决</li></ul><h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><ul><li>排序</li><li>查找<ul><li>BF算法  </li><li>KMP算法  </li><li>BM算法  </li></ul></li><li>正则表达式</li><li>数据压缩</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>二叉树    </li><li>二叉查找树   </li><li>伸展树(splay tree 分裂树)   </li><li>平衡二叉树AVL    </li><li>红黑树  </li><li>B树,B+,B*  </li><li>R树  </li><li>Trie树(前缀树)  </li><li>后缀树  </li><li>最优二叉树(赫夫曼树) </li><li>二叉堆 （大根堆，小根堆）   </li><li>二项树    </li><li>二项堆  </li><li>斐波那契堆(Fibonacci Heap)   </li></ul><h3 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h3><ul><li>图的存储结构和基本操作（建立，遍历，删除节点，添加节点）   </li><li>最小生成树  </li><li>拓扑排序  </li><li>关键路径  </li><li>最短路径: Floyd,Dijkstra,bellman-ford,spfa  </li></ul><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>交换排序算法</strong></p><ul><li>冒泡排序</li><li>插入排序    </li><li>选择排序    </li><li>希尔排序</li><li>快排   </li><li>归并排序  </li><li>堆排序</li></ul><p><strong>线性排序算法</strong></p><ul><li>桶排序 </li></ul><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul><li>顺序表查找：顺序查找  </li><li>有序表查找：二分查找  </li><li>分块查找： 块内无序，块之间有序；可以先二分查找定位到块，然后再到<code>块</code>中顺序查找  </li><li>动态查找:  二叉排序树，AVL树，B- ，B+    （这里之所以叫 <code>动态查找表</code>，是因为表结构是查找的过程中动态生成的）</li><li>哈希表：  O(1)     </li></ul><h3 id="15个经典基础算法"><a href="#15个经典基础算法" class="headerlink" title="15个经典基础算法"></a>15个经典基础算法</h3><ul><li>Hash  </li><li>快速排序 </li><li>快递选择SELECT </li><li>BFS/DFS （广度/深度优先遍历）    </li><li>红黑树 （一种自平衡的<code>二叉查找树</code>）  </li><li>KMP    字符串匹配算法</li><li>DP (动态规划 dynamic programming)   </li><li>A*寻路算法： 求解最短路径 </li><li>Dijkstra：最短路径算法 （八卦下：Dijkstra是荷兰的计算机科学家,提出”信号量和PV原语“,”解决哲学家就餐问题”,”死锁“也是它提出来的） </li><li>遗传算法  </li><li>启发式搜索   </li><li>图像特征提取之SIFT算法  </li><li>傅立叶变换  </li><li>SPFA(shortest path faster algorithm)  单元最短路径算法  </li></ul><h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul><li>Hash映射/分而治之</li><li>Bitmap</li><li>Bloom filter(布隆过滤器)</li><li>Trie树</li><li>数据库索引</li><li>倒排索引(Inverted Index)</li><li>双层桶划分</li><li>外排序</li><li>simhash算法</li><li>分布处理之Mapreduce</li></ul><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ul><li>迭代法  </li><li>穷举搜索法  </li><li>递推法  </li><li>动态规划  </li><li>贪心算法  </li><li>回溯  </li><li>分治算法  </li></ul><h2 id="算法问题选编"><a href="#算法问题选编" class="headerlink" title="算法问题选编"></a>算法问题选编</h2><p>这是一个算法题目合集，题目是我从网络和书籍之中整理而来，部分题目已经做了思路整理。问题分类包括：</p><ul><li>字符串</li><li>堆和栈</li><li>链表</li><li>数值问题</li><li>数组和数列问题</li><li>矩阵问题</li><li>二叉树</li><li>图</li><li>海量数据处理</li><li>智力思维训练</li><li>系统设计</li></ul><p>还有部分来自算法网站和书籍：</p><ul><li>九度OJ</li><li>leetcode</li><li>剑指offer</li></ul><h2 id="开源项目中的算法"><a href="#开源项目中的算法" class="headerlink" title="开源项目中的算法"></a>开源项目中的算法</h2><ul><li>YYCache</li><li>cocos2d-objc</li><li>…</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="刷题必备"><a href="#刷题必备" class="headerlink" title="刷题必备"></a>刷题必备</h3><p>《剑指offer》<br>《编程之美》<br>《编程之法:面试和算法心得》<br>《算法谜题》 都是思维题 </p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>《编程珠玑》Programming Pearls<br>《编程珠玑(续)》<br>《数据结构与算法分析》<br>《Algorithms》 这本近千页的书只有6章,其中四章分别是排序，查找，图，字符串，足见介绍细致     </p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>《算法设计与分析基础》<br>《算法引论》 告诉你如何创造算法   断货<br>《Algorithm Design Manual》算法设计手册 红皮书  </p><p>《算法导论》 是一本对算法介绍比较全面的经典书籍   </p><p>《Algorithms on Strings,Trees and Sequences》<br>《Advanced Data Structures》 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树  600块    </p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>《深入理解计算机系统》<br>《TCP/IP详解三卷》<br>《UNIX网络编程二卷》<br>《UNIX环境高级编程：第2版》  </p><p>《The practice of programming》   Brian Kernighan和Rob Pike<br>《writing efficient programs》  优化<br>《The science of programming》 证明代码段的正确性   800块一本   </p><h2 id="参考链接和学习网站"><a href="#参考链接和学习网站" class="headerlink" title="参考链接和学习网站"></a>参考链接和学习网站</h2><h3 id="July-博客"><a href="#July-博客" class="headerlink" title="July 博客"></a><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">July 博客</a></h3><p>《数学建模十大经典算法》<br>《数据挖掘领域十大经典算法》<br>《十道海量数据处理面试题》<br>《数字图像处理领域的二十四个经典算法》<br>《精选微软等公司经典的算法面试100题》 </p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">The-Art-Of-Programming-By-July</a><br><a href="http://blog.csdn.net/column/details/ms100.html" target="_blank" rel="noopener">微软面试100题</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6460494" target="_blank" rel="noopener">程序员编程艺术</a>   </p><h3 id="基本算法演示"><a href="#基本算法演示" class="headerlink" title="基本算法演示"></a>基本算法演示</h3><p><a href="http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html" target="_blank" rel="noopener">http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html</a><br><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">http://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a>  </p><h3 id="编程网站"><a href="#编程网站" class="headerlink" title="编程网站"></a>编程网站</h3><p><a href="http://leetcode.com/" target="_blank" rel="noopener">leetcode</a><br><a href="http://openjudge.cn/" target="_blank" rel="noopener">openjudge</a>  开放在线程序评测平台，可以床架自己的OJ小组<br><a href="http://ac.jobdu.com/index.php" target="_blank" rel="noopener">九度OJ</a>     </p><p>这有个<a href="http://www.java3z.com/cwbwebhome/article/article19/res041.html" target="_blank" rel="noopener">ACM训练方案</a>   </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/" target="_blank" rel="noopener">高级数据结构和算法</a>  北大教授张铭老师在coursera上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie树、AVL树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然coursera上也还有很多其它算法方面的视频课程。</p><p><a href="https://class.coursera.org/algorithms-001/lecture" target="_blank" rel="noopener">算法设计与分析 Design and Analysis of Algorithms</a> 由北大教授Wanling Qu在coursera讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf文件）以便阅读和复习。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img1.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构算法" scheme="https://hankin2015.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://hankin2015.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅的机器学习笔记</title>
    <link href="https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/"/>
    <id>https://hankin2015.github.io/2019/04/21/20190421ML_HungLiLee/</id>
    <published>2019-04-21T02:47:41.000Z</published>
    <updated>2018-08-12T17:35:33.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html" target="_blank" rel="noopener">李宏毅机器学习深度学习资料</a><br><a href="https://www.bilibili.com/video/av10590361?from=search&amp;seid=8971112424275201304" target="_blank" rel="noopener">李宏毅2017机器学习视频</a><br><a href="https://www.52ml.net/" target="_blank" rel="noopener">我爱机器学习</a><br><a href="https://www.lintcode.com/" target="_blank" rel="noopener">周sir推荐lintcode</a><br><a href="https://www.jiqizhixin.com/articles/02111" target="_blank" rel="noopener">邓miss推荐李沫动手学深度学习</a></p><h1 id="1、Introduction-of-this-course"><a href="#1、Introduction-of-this-course" class="headerlink" title="1、Introduction of this course"></a>1、Introduction of this course</h1><p>人工智慧目标-》机器学习手段-》深度学习方法<br>之前的智慧：人类设定好的天生本能</p><ul><li>河狸生物的本能筑水坝</li><li>Chat_bot和漫画智能机器人多个if调侃AI<a id="more"></a><h2 id="3步Machine-Learning-is-so-simple-……"><a href="#3步Machine-Learning-is-so-simple-……" class="headerlink" title="3步Machine Learning is so simple ……"></a>3步Machine Learning is so simple ……</h2>Step 1: define a set of function<br>Step 2: goodness of function<br>Step 3: pick the best function<br>就好像吧大象放进冰箱……</li></ul><h2 id="Learning-Map-scenario-task-method"><a href="#Learning-Map-scenario-task-method" class="headerlink" title="Learning Map: scenario task method"></a>Learning Map: scenario task method</h2><ul><li>Supervised Learning<ul><li>Regression</li><li>Classification<ul><li>Linear Model</li><li>Non-linear Model<ul><li>Deep Learning</li><li>SVM, decision tree, K-NN …</li></ul></li></ul></li><li>Structured Learning</li></ul></li><li>Semi-supervised Learning</li><li>Transfer Learning</li><li>Unsupervised Learning</li><li>Reinforcement Learning</li></ul><h1 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h1><p>saddle point鞍点<br>local minima极点</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML16.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅机器学习深度学习资料&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.bilibili.com/video/av10590361?from=search&amp;amp;seid=8971112424275201304&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅2017机器学习视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.52ml.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我爱机器学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.lintcode.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;周sir推荐lintcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/02111&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;邓miss推荐李沫动手学深度学习&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1、Introduction-of-this-course&quot;&gt;&lt;a href=&quot;#1、Introduction-of-this-course&quot; class=&quot;headerlink&quot; title=&quot;1、Introduction of this course&quot;&gt;&lt;/a&gt;1、Introduction of this course&lt;/h1&gt;&lt;p&gt;人工智慧目标-》机器学习手段-》深度学习方法&lt;br&gt;之前的智慧：人类设定好的天生本能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;河狸生物的本能筑水坝&lt;/li&gt;
&lt;li&gt;Chat_bot和漫画智能机器人多个if调侃AI
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习笔记</title>
    <link href="https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/"/>
    <id>https://hankin2015.github.io/2019/01/15/20190427Deeping_ML_LiMo/</id>
    <published>2019-01-15T02:47:41.000Z</published>
    <updated>2018-09-25T01:53:46.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p><a href="http://zh.gluon.ai/index.html#" target="_blank" rel="noopener">动手学深度学习</a><br>这是一个深度学习的教学项目。我们将使用 Apache MXNet (incubating) 的最新 gluon 接口来演示如何从0开始实现深度学习的各个算法。我们的将利用 Jupyter notebook 能将文档，代码，公式和图形统一在一起的优势，提供一个交互式的学习体验。这个项目可以作为一本书，上课用的材料，现场演示的案例，和一个可以尽情拷贝的代码库。据我们所知，目前并没有哪个项目能既覆盖全面深度学习，又提供交互式的可执行代码。我们将尝试弥补这个空白。</p><p>第一季十九课视频汇总<br>可打印的PDF版本在这里<br>课程源代码在Github （亲，给个好评加颗星）<br>请使用 <a href="http://discuss.gluon.ai/" target="_blank" rel="noopener">http://discuss.gluon.ai/</a> 来进行讨论</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="主要符号一览"><a href="#主要符号一览" class="headerlink" title="主要符号一览"></a>主要符号一览</h2><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h2 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h2><h3 id="1、用代码编程和用数据编程"><a href="#1、用代码编程和用数据编程" class="headerlink" title="1、用代码编程和用数据编程"></a>1、用代码编程和用数据编程</h3><p>这个例子灵感来自 Joel Grus 的一次 应聘面试. 面试官让他写个程序来玩Fizz Buzz. 这是一个小孩子游戏。玩家从1数到100，如果数字被3整除，那么喊’fizz’，如果被5整除就喊’buzz’，如果两个都满足就喊’fizzbuzz’，不然就直接说数字。这个游戏玩起来就像是：</p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 …</p></blockquote><p>传统的实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [1]:</span><br><span class="line">res = []</span><br><span class="line">for i in range(1, 101):</span><br><span class="line">    if i % 15 == 0:</span><br><span class="line">        res.append(&apos;fizzbuzz&apos;)</span><br><span class="line">    elif i % 3 == 0:</span><br><span class="line">        res.append(&apos;fizz&apos;)</span><br><span class="line">    elif i % 5 == 0:</span><br><span class="line">        res.append(&apos;buzz&apos;)</span><br><span class="line">    else:</span><br><span class="line">        res.append(str(i))</span><br><span class="line">print(&apos; &apos;.join(res))</span><br></pre></td></tr></table></figure></p><blockquote><p>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz b</p></blockquote><p>对于经验丰富的程序员来说这个太不够一颗赛艇了。所以Joel尝试用机器学习来实现这个。为了让程序能学，他需要准备下面这个数据集：</p><ul><li>数据 X [1, 2, 3, 4, …] 和标注Y [‘fizz’, ‘buzz’, ‘fizzbuzz’, identity]</li><li>训练数据，也就是系统输入输出的实例。例如 [(2, 2), (6, fizz), (15, fizzbuzz), (23, 23), (40, buzz)]</li><li>从输入数据中抽取的特征，例如 x -&gt; [(x % 3), (x % 5), (x % 15)].</li></ul><p>有了这些，Jeol利用TensorFlow写了一个分类器。对于不按常理出牌的Jeol，面试官一脸黑线。而且这个分类器不是总是对的。</p><h3 id="2、机器学习最简要素"><a href="#2、机器学习最简要素" class="headerlink" title="2、机器学习最简要素"></a>2、机器学习最简要素</h3><p>成功的机器学习有四个要素：数据、转换数据的模型、衡量模型好坏的损失函数和一个调整模型权重来最小化损失函数的算法。</p><h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><h4 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h4><h4 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h4><ul><li>训练误差（training error）：这是模型在用于训练的数据集上的误差。类似于考试前我们在模拟试卷上拿到的分数。有一定的指向性，但不一定保证真实考试分数。</li><li>测试误差（test error）：这是模型在没见过的新数据上的误差，可能会跟训练误差很不一样（统计上称之为过拟合）。类似于考前模考次次拿高分，但实际考起来却失误了。</li></ul><h4 id="Optimization-Algorithms"><a href="#Optimization-Algorithms" class="headerlink" title="Optimization Algorithms"></a>Optimization Algorithms</h4><h3 id="3、Supervised-Learning"><a href="#3、Supervised-Learning" class="headerlink" title="3、Supervised Learning"></a>3、Supervised Learning</h3><p>简单概括，学习过程看起来是这样的：在一大组数据中随机地选择样本输入，并获得其真实（ground-truth）的标注（label）；这些输入和标注（即期望的结果）构成了训练集（training set）。我们把训练集放入一个监督学习算法（supervised learning algorithm）。算法的输入是训练集，输出则是学得模型（learned model）。基于这个学得模型，我们输入之前未见过的测试数据，并预测相应的标注。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zh.gluon.ai/_images/supervised-learning.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h4 id="3-1、Regression"><a href="#3-1、Regression" class="headerlink" title="3-1、Regression"></a>3-1、Regression</h4><p>在该项任务里，输入是任意离散或连续的、单一或多个的变量，而输出是连续的数值。</p><p>一条经验就是，问题中如果包含“多少？”，这类问题一般是回归问题。“这次手术需要几个小时？”……回归分析。“这张照片里有几只狗？”……回归分析。不过，如果问题能够转化为“这是一个<em>__</em>吗？”，那这很有可能是一个分类，或者属于其余我们将会谈及的问题。</p><p>如果我们把模型预测的输出值和真实的输出值之间的差别定义为残差，常见的回归分析的损失函数包括训练数据的残差的平方和或者绝对值的和。机器学习的任务是找到一组模型参数使得损失函数最小化。</p><h4 id="3-2、Classification"><a href="#3-2、Classification" class="headerlink" title="3-2、Classification"></a>3-2、Classification</h4><p>回归分析所关注的预测可以解答输出为连续数值 的问题。当预测的输出是离散的 类别时，这个监督学习任务就叫做分类。</p><h2 id="使用NDArray来处理数据"><a href="#使用NDArray来处理数据" class="headerlink" title="使用NDArray来处理数据"></a>使用NDArray来处理数据</h2><p>使用autograd来自动求导<br>深度学习模型基础<br>线性回归——从零开始<br>线性回归——使用Gluon<br>多类逻辑回归——从零开始<br>多类逻辑回归——使用Gluon<br>多层感知机——从零开始<br>多层感知机——使用Gluon<br>欠拟合和过拟合<br>正则化——从零开始<br>正则化——使用Gluon<br>丢弃法（Dropout）——从零开始<br>丢弃法（Dropout）——使用Gluon<br>正向传播和反向传播<br>实战Kaggle比赛——使用Gluon预测房价和K折交叉验证<br>深度学习计算基础<br>模型构造<br>模型参数<br>自定义层<br>读取和存储<br>GPU计算<br>卷积神经网络<br>卷积神经网络 — 从0开始<br>卷积神经网络 — 使用Gluon<br>批量归一化 — 从0开始<br>批量归一化 — 使用Gluon<br>深度卷积神经网络和AlexNet<br>VGG：使用重复元素的非常深的网络<br>网络中的网络<br>更深的卷积神经网络：GoogLeNet<br>ResNet：深度残差网络<br>DenseNet：稠密连接的卷积神经网络<br>循环神经网络<br>循环神经网络 — 从0开始<br>通过时间反向传播<br>门控循环单元（GRU）— 从0开始<br>长短期记忆（LSTM）— 从0开始<br>循环神经网络 — 使用Gluon<br>优化算法<br>优化算法概述<br>梯度下降和随机梯度下降——从零开始<br>梯度下降和随机梯度下降——使用Gluon<br>动量法——从零开始<br>动量法——使用Gluon<br>Adagrad——从零开始<br>Adagrad——使用Gluon<br>RMSProp——从零开始<br>RMSProp——使用Gluon<br>Adadelta——从零开始<br>Adadelta——使用Gluon<br>Adam——从零开始<br>Adam——使用Gluon<br>计算性能<br>命令式和符号式混合编程<br>惰性计算<br>自动并行计算<br>多GPU训练模型——从零开始<br>多GPU训练模型——使用Gluon<br>计算机视觉<br>图片增广<br>Fine-tuning: 通过微调来迁移学习<br>使用卷积神经网络的物体检测<br>SSD — 使用Gluon<br>YOLO — 使用Gluon<br>语义分割：FCN<br>样式迁移<br>实战Kaggle比赛——使用Gluon对原始图像文件分类（CIFAR-10）<br>实战Kaggle比赛——使用Gluon识别120种狗 (ImageNet Dogs)<br>自然语言处理<br>词向量 — word2vec<br>词向量 — GloVe和fastText<br>使用预训练的词向量<br>编码器—解码器（seq2seq）和注意力机制<br>神经机器翻译<br>附录<br>安装和使用<br>GPU购买指南<br>在AWS上运行教程<br>数学基础<br>本教程的英文版本 （注意：中文版本根据社区的反馈做了比较大的更改，我们还在努力的将改动同步到英文版）</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://github.com/HanKin2015/Storage/blob/master/img8.jpg?raw=true&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
  <entry>
    <title>EOJ Monthly 2018.12</title>
    <link href="https://hankin2015.github.io/2018/12/08/20181208EOJ201812/"/>
    <id>https://hankin2015.github.io/2018/12/08/20181208EOJ201812/</id>
    <published>2018-12-08T03:48:41.000Z</published>
    <updated>2018-12-18T07:59:31.131Z</updated>
    
    <content type="html"><![CDATA[<p>比赛地址：<a href="https://acm.ecnu.edu.cn/contest/125/" target="_blank" rel="noopener">https://acm.ecnu.edu.cn/contest/125/</a></p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li>新的运行时间认识，1E8？</li><li>随机数题</li><li>蒙特卡洛模拟算法</li><li>多次询问记得避免重复计算</li></ul><a id="more"></a><h2 id="A-仰望星空"><a href="#A-仰望星空" class="headerlink" title="A. 仰望星空"></a>A. 仰望星空</h2><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>你就这样静坐在草地上，离我稍远的地方。<br>我用眼角瞅着你，你什么话也别说。<br>语言是误会的根源。<br>但是，每天，你可以坐得离我近一些……</p><p>你和她一起仰头仰望着布满星辰的天空。你的星星对她而言只不过是众星中的一颗。</p><p>她会喜欢仰望天际所有的繁星，他们都会是她的朋友。但你深信你不会是万众中一颗毫不起眼的星星。</p><p>于是你默默地记录着每天你们仰望星空时的距离，你发现每天你们的距离或许减少、或许不变，但一定不会增加。</p><p>可是你们在一起仰望星空的日子太长了，长到你只记得你们第一天在星空下的距离。</p><p>今天，你们的距离是 A；你们又在一起仰望星空了。你却突然想知道一起仰望星空 N 天来，你们之间的距离之和。</p><p>由于你已经不记得每天的距离，只能依稀记起第一天的距离是 B，所以你只想知道你们这么多天来的距离之和有多少种不同的可能性。</p><p>输入<br>输入数据包含一行，包含三个整数 N,A,B (2≤N≤109,1≤A≤B≤109)，分别表示你们一起仰望星空的天数、今天你们之间的距离以及第一天你们之间的距离。</p><p>输出<br>输出数据包含一行一个整数，表示不同可能和的个数。</p><p>样例<br>input<br>3 1 2<br>output<br>2<br>提示<br>对于样例有以下几种不同的距离情况：{2,1,1},{2,2,1}；他们的和分别是 4 和 5，所以有两种不同的和。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>已知最大的和最小的，那么和最大的情况一定是除了一个最小的，其余全部是最大的；相反地，和最小的情况一定是除了一个最大的，其余全部都是最小的。<br>显然，我们可以通过一些调整，取到从和的最小到最大这整个区间里所有的数。</p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">#define maxn 10005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    LL N, A, B;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    LL maxSum = B * (N - 1) + A;</span><br><span class="line">    LL minSum = A * (N - 1) + B;</span><br><span class="line">    cout &lt;&lt; maxSum - minSum + 1 &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-清点星辰"><a href="#B-清点星辰" class="headerlink" title="B. 清点星辰"></a>B. 清点星辰</h2><p>单测试点时限: 2.0 秒</p><p>内存限制: 512 MB</p><p>“夜里，<br>你要抬头仰望满天的星星。<br>我那颗实在太小了，<br>我都没法指给你看它在哪儿。”</p><p>这样倒也好，我的星星，对你来说就是满天星星中的一颗。</p><p>所以，你会爱这满天的星星…所有的星星都会是你的朋友。</p><p>即使只能通过狭小的洞口，在楼宇的夹缝中仰望布满星辰的天空，你还是无法割舍对它的期待。</p><p>星星数不胜数，但你还是不厌其烦地清点他们。日复一日，终于在今天，你把他们都数清楚了。</p><p>于是你又开始找别的事情做了。你开始计算他们两两之间的最近距离。</p><p>你仰望星空的洞口是一个 1×1 的正方形，每天，星辰的位置都会发生变化，具体地说，每天都会有 n 个星辰随机地散落在这个正方形内的某个坐标上（每个点横纵坐标满足独立同分布 U(0,1)）。</p><p>每天的距离都在变化，所以现在你只想知道他们两两之间最近距离的期望是多少。</p><p>输入<br>输入一个整数 n (2≤n≤109) ，表示星辰的数量。</p><p>输出<br>一行一个小数，输出答案。绝对误差在 10−3 内会被视为正确。</p><p>样例<br>input<br>2<br>output<br>0.521405<br>input<br>3<br>output<br>0.3055302430</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>蒙特卡洛模拟算法。<br>精度要求只有 10−3，显然大的时候可以直接输出 0。<br>对不是 0 的部分，显然 n 越大答案的方差越小，所以 n 越大需要的生成次数就越小，所以可以直接控制复杂度 1E8 或者运行时间。<br>那么 n 要多大才可以输出 0 了呢？可以试一试：好像 700 多一点点就可以输出 0 了……</p><p>第一次WA了1发，在测试样例的时候误差也超出了1E3的范围，尽量把单次的运行时间卡在边缘，即n越小的时候要模拟次数越多。</p><h3 id="AC-1"><a href="#AC-1" class="headerlink" title="AC"></a>AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int seed = time(0);</span><br><span class="line">    srand(seed);</span><br><span class="line">    int n;</span><br><span class="line">    const double eps = 1e-3;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    if (n &gt; 900) &#123;</span><br><span class="line">        cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double sumDis = 0;</span><br><span class="line">    int cnt = 1e8 / (n * n);</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        double x[1005], y[1005];</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            x[j] = rand() / (RAND_MAX + 1.0);;</span><br><span class="line">            y[j] = rand() / (RAND_MAX + 1.0);;</span><br><span class="line">            //cout &lt;&lt; x[j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        double minDis = 100;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            for (int k = j + 1; k &lt; n; k++) &#123;</span><br><span class="line">                double dis = sqrt((x[j] - x[k]) * (x[j] - x[k]) + (y[j] - y[k]) * (y[j] - y[k]));</span><br><span class="line">                if (dis &lt; minDis) minDis = dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sumDis += minDis;</span><br><span class="line">    &#125;</span><br><span class="line">    sumDis /= cnt;</span><br><span class="line">    cout &lt;&lt; sumDis &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-她的名字"><a href="#C-她的名字" class="headerlink" title="C. 她的名字"></a>C. 她的名字</h2><p>单测试点时限: 4.0 秒</p><p>内存限制: 512 MB</p><p>“他走过一个又一个星球，<br>却始终放不下对她的思念。“<br>”深情终究是一趟孤独的旅程，<br>她是他永远的牵绊。”</p><p>我们每个人心中都有一只小狐狸。我们渴望被自己喜欢的人驯服。</p><p>爱情是彼此之间至为甜蜜的臣服。我们都是傻痴痴的小狐狸，徒具一副精明的外表。</p><p>就像你走到哪都挂念着她，想把她写进自己的歌里，成为你们共同的记忆。</p><p>你想从她全部由数字构成的名字里取出其中的 N 个数字，维持原来的顺序，组成结尾为数字 XY 的新词。</p><p>你自然希望自己的歌能够很长很长，歌词的每一句都能饱含甜蜜。</p><p>所以你想知道，她的名字能够组成多少个长度为 N 且结尾为数字 XY 的新词（如果从她名字中取出的任意一个数字位置不同，两个词就被认为是不同的）。</p><p>输入<br>第一行包含一个由数字构成的字符串 S (1≤|S|≤2 000)。</p><p>第二行包含一个整数 Q (1≤Q≤5⋅105)，表示需要选择的不同结尾数量。</p><p>接下来的 Q 行，每行包含了一个整数 N (1≤N≤5⋅105) 和两个数字 XY，用空格隔开，表示需要选择的歌词的长度和结尾。</p><p>输出<br>对于每一个询问，输出一个整数，表示答案。</p><p>答案可能会很大，你只需要输出对于 109+7 取模后的结果。</p><p>样例<br>input<br>312121<br>4<br>2 21<br>3 31<br>4 22<br>3 22<br>output<br>3<br>0<br>1<br>2<br>提示<br>样例中第一个询问：312121, 312121, 312121.</p><p>第二个询问：无。</p><p>第三个询问：312121.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>可以发现，询问很多，但是主串 S 的长度并不长。考虑预处理所有的结尾情况。<br>我们可以枚举第一个位置 X ，预处理出 X 后面分别接 10 个数字的时候，可以组成字符串的数量。<br>假设当前枚举到的一个位置 i 满足 Si=X 。题目需要组成新字符串的长度为 N ，假设位置 i 后面有 Ay 个 Y ，则他对答案的贡献就是 (i−1n−2)Ay 。<br>显然，Ay 是可以先处理掉的，然后再继续暴力预处理所有结尾情况下新字符串的数量。<br>预处理完成以后，对于所有的询问都可以 O(1) 出结果。<br>但是我们发现询问给出的 N 很大，但可以显然地发现，当 N&gt;|S| 很大的时候是没有解的。</p><p>暴力时间复杂度：2000×2000×100<br>但还是卡了TLE，首先一直错找不出原因，花了一天多才发现是组合数算错了。然后TLE，优化<code>避免重复的询问</code>，存储答案。</p><h3 id="AC-2"><a href="#AC-2" class="headerlink" title="AC"></a>AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    LL cnt[10][10][2005];   // 两个位置形成末尾共有多少的前缀</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line"></span><br><span class="line">    int len = str.size();</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            int head = str[i] - &apos;0&apos;;</span><br><span class="line">            int tail = str[j] - &apos;0&apos;;</span><br><span class="line">            cnt[head][tail][i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static LL C[2005][2005];  // 组合数</span><br><span class="line">    for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        C[i][i] = C[i][0] = 1;</span><br><span class="line">        for(int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];</span><br><span class="line">            C[i][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Q, N, X, Y;</span><br><span class="line">    char A, B;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    // 优化</span><br><span class="line">    static LL ret[10][10][2005]; // 存储结果，如果是相同的询问避免重复计算</span><br><span class="line">    bool vis[10][10][2005];</span><br><span class="line">    while (Q--) &#123;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;  // 不能写成一个数的输入，可能有前缀0</span><br><span class="line">        //cout &lt;&lt; A &lt;&lt; B &lt;&lt; endl;</span><br><span class="line">        X = A - &apos;0&apos;;</span><br><span class="line">        Y = B - &apos;0&apos;;</span><br><span class="line">        LL ans = 0;</span><br><span class="line">        if (N &gt; 1 &amp;&amp; N &lt;= len) &#123;</span><br><span class="line">            if (vis[X][Y][N]) ans = ret[X][Y][N];</span><br><span class="line">            else &#123;</span><br><span class="line">                int M = N - 2;</span><br><span class="line">                for (int i = 0; i &lt; len; i++) &#123;  // 时间复杂度O(5*10^5*10^3=10^8)</span><br><span class="line">                    if (cnt[X][Y][i] &amp;&amp; i &gt;= M) &#123; // 一定要满足组合数条件</span><br><span class="line">                        ans += C[i][M] * cnt[X][Y][i];</span><br><span class="line">                        ans %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[X][Y][N] = ans;</span><br><span class="line">                vis[X][Y][N] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入：</span><br><span class="line">312121</span><br><span class="line">4</span><br><span class="line">2 21</span><br><span class="line">3 31</span><br><span class="line">4 22</span><br><span class="line">3 22</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提交WA了9次，提交AC了才能看别人的代码。</span><br><span class="line"></span><br><span class="line">居然是组合数求错了。。。。。</span><br><span class="line">不可能啊。。。。。。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入：</span><br><span class="line">312121</span><br><span class="line">4</span><br><span class="line">2 21</span><br><span class="line">3 31</span><br><span class="line">4 22</span><br><span class="line">3 22</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">提交WA了9次，提交AC了才能看别人的代码。</span><br><span class="line">居然是组合数求错了。。。。。</span><br><span class="line">不可能啊。。。。。。</span><br><span class="line"></span><br><span class="line">原来是没有计算C(0,0)=1。而是写成了默认值C(0,0)=0。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛地址：&lt;a href=&quot;https://acm.ecnu.edu.cn/contest/125/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://acm.ecnu.edu.cn/contest/125/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;新的运行时间认识，1E8？&lt;/li&gt;
&lt;li&gt;随机数题&lt;/li&gt;
&lt;li&gt;蒙特卡洛模拟算法&lt;/li&gt;
&lt;li&gt;多次询问记得避免重复计算&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://hankin2015.github.io/categories/ACM/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="EOJ" scheme="https://hankin2015.github.io/tags/EOJ/"/>
    
      <category term="月赛" scheme="https://hankin2015.github.io/tags/%E6%9C%88%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>使用指定照片生成二维码和文件整理分类</title>
    <link href="https://hankin2015.github.io/2018/11/23/20181123QR/"/>
    <id>https://hankin2015.github.io/2018/11/23/20181123QR/</id>
    <published>2018-11-23T03:48:41.000Z</published>
    <updated>2018-12-31T08:28:55.456Z</updated>
    
    <content type="html"><![CDATA[<p>二维码（QR code）<br>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ</a></li><li><a href="https://blog.csdn.net/qq_40949713/article/details/80512339" target="_blank" rel="noopener">https://blog.csdn.net/qq_40949713/article/details/80512339</a> </li></ul><a id="more"></a><h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><p>pip install qrcode  #方法多，体量小<br>pip install myqr    #操作简单，功能强大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from MyQR import myqr  # 注意在python中的调用方式</span><br><span class="line">help(myqr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myqr.run(</span><br><span class="line">    words=&apos;Hello world&apos;,         #在命令后输入链接或者句子作为参数，然后在程序的当前目录中产生相应的二维码图片文件，默认命名为” qrcode.png“</span><br><span class="line">    version=1,                   #设置容错率为最高默认边长是取决于你输入的信息的长度和使用的纠错等级；而默认纠错等级是最高级的H</span><br><span class="line">    level=&apos;H&apos;,                   #控制纠错水平，范围是L、M、Q、H，从左到右依次升高</span><br><span class="line">    picture=&apos;WChat.png&apos;,         #用来将QR二维码图像与一张同目录下的图片相结合，产生一张黑白图片</span><br><span class="line">    colorized=True,              #可以使产生的图片由黑白(False)变为彩色(True)的</span><br><span class="line">    contrast=1.0,                #用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。</span><br><span class="line">    brightness=1.0,              #用来调节图片的亮度，其余用法和取值与 -con 相同</span><br><span class="line">    save_name=&apos;test.png&apos;,        #控制文件名，格式可以是 .jpg， .png ，.bmp ，.gif ；</span><br><span class="line">    save_dir=os.getcwd()         #控制位置。</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="可以使用简写控制参数（命令行）"><a href="#可以使用简写控制参数（命令行）" class="headerlink" title="可以使用简写控制参数（命令行）"></a>可以使用简写控制参数（命令行）</h1><p>需要注意字符串不能指定中文，否则会抛出 ValueError(‘Wrong words! Make sure the characters are supported!’) 的异常。<br>1、使用 -d 可以控制输出的文件路径；<br>2、使用 -n 控制文件名称，格式可以是 .jpg、.png、.bmp、.gif；<br>3、使用 -l 可以控制二维码的纠错等级，范围是L、M、Q、H，从左到右依次升高；<br>4、使用 -v 控制二维码的边长，范围是 1 至 40，数字越大边长越大。<br>5、使用 -p 参数指定图片，将二维码与该图片结合在一起。<br>6、想要生成彩色的，可以加上参数 -c。<br>7、可以使用参数 -con 控制图片对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为 1.0；<br>8、使用参数 -bri 用来调节图片的亮度，其余用法和取值与 -con 相同。<br>9、还可以使用动态图片gif。</p><blockquote><p>myqr “I love you” -p p.jpg -c -l M</p></blockquote><h1 id="文件整理分类"><a href="#文件整理分类" class="headerlink" title="文件整理分类"></a>文件整理分类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">path = &apos;./&apos;</span><br><span class="line">files = os.listdir(path)</span><br><span class="line"></span><br><span class="line">for file in files:</span><br><span class="line">folderName = &apos;./&apos; + file.split(&apos;.&apos;)[-1]</span><br><span class="line">if not os.path.exists(folderName):</span><br><span class="line">os.makedirs(folderName)</span><br><span class="line">shutil.move(file, folderName)</span><br><span class="line"></span><br><span class="line">print(&apos;done&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二维码（QR code）&lt;br&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/Spabm0PNw8rtnWFaj_9HHQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40949713/article/details/80512339&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_40949713/article/details/80512339&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="二维码" scheme="https://hankin2015.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="文件" scheme="https://hankin2015.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理</title>
    <link href="https://hankin2015.github.io/2018/11/10/20181110Principle/"/>
    <id>https://hankin2015.github.io/2018/11/10/20181110Principle/</id>
    <published>2018-11-10T14:47:41.000Z</published>
    <updated>2018-11-10T13:30:41.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。<br><a href="https://www.cnblogs.com/rhythmic/p/5503272.html" target="_blank" rel="noopener">《程序设计中的组合数学》——容斥定理</a><br><a href="http://blog.csdn.net/han_kin/article/details/47662801" target="_blank" rel="noopener">容斥定理</a><br><a id="more"></a></p><p>韦恩图能够鲜明的解释这个原理。</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>时间复杂度：2^n （n集合个数）<br>总共就2^n种组合（子串），然后判断每种可能中有多少集合来判断正负。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int solve (int n, int r)</span><br><span class="line">&#123;</span><br><span class="line">    /*求质数*/</span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            p.push_back (i);</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) p.push_back (n);</span><br><span class="line"></span><br><span class="line">    int sum = 0;   // 非互质的个数</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; (int)p.size()); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int mult = 1, bits = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; (int)p.size(); ++i) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ++bits;</span><br><span class="line">                mult *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = r / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) sum += cur;</span><br><span class="line">        else sum -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return r - sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="两个同一个问题"><a href="#两个同一个问题" class="headerlink" title="两个同一个问题"></a>两个同一个问题</h1><ol><li>给出整数n和r。求区间[1;r]中与n互素的数的个数。</li><li>给定一个区间[A,B],找出在这个区间内与给定的n互质的整数的个数。</li></ol><p>两个问题解决方案一样，去解决它的逆问题，求不与n互素的数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 求n的质因数</span><br><span class="line">void FindPrimeFactor(int n, int a[], int &amp;cnt)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            a[cnt++] = i;</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) a[cnt++] = n;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 复杂度也是2^k</span><br><span class="line">LL Solve2(LL n, int a[], int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    int t = 1, que[1005] = &#123; -1&#125;; // 依据容斥原理，que[0]的值是-1</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;  // 比如2 3 4，形成-1 2 3 -6 4 -8 -12 24</span><br><span class="line">        int k = t;</span><br><span class="line">        for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">            que[t++] = que[j] * a[i] * (-1);  // 难点</span><br><span class="line">            /*乘以-1和-1^k是一样的效果</span><br><span class="line">            重点在第一个for循环，新加进去的数和前面形成组合子串*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;t = &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    for (int i = 1; i &lt; t; i++) &#123;</span><br><span class="line">        cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line">        res += n / que[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve (int n, int r)</span><br><span class="line">&#123;</span><br><span class="line">    /*求质数*/</span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            p.push_back (i);</span><br><span class="line">            while (n % i == 0) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 1) p.push_back (n);</span><br><span class="line"></span><br><span class="line">    int sum = 0;   // 非互质的个数</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; (int)p.size()); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int mult = 1, bits = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; (int)p.size(); ++i) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ++bits;</span><br><span class="line">                mult *= p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = r / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) sum += cur;</span><br><span class="line">        else sum -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return r - sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">题目：给定一个区间[A,B],找出在这个区间内与给定的N互质的整数的个数。</span><br><span class="line">T(0 &lt; T &lt;= 100)the number of test cases</span><br><span class="line">each of the next T lines contains three integers A, B, N where (1 &lt;= A &lt;= B &lt;= 10^15) and (1 &lt;=N &lt;= 10^9).</span><br><span class="line"></span><br><span class="line">直接求互质复杂度高，可以用素数筛选法求非互质的数。</span><br><span class="line">求[1,B]-[1,A-1]。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 直接算一定有错误，必须使用容斥原理</span><br><span class="line">LL Solve(LL n, int a[], int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = 0;</span><br><span class="line">    for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        for (int j = 1; ; j++) &#123;</span><br><span class="line">            if (j * a[i] &gt; n) &#123;</span><br><span class="line">                res += j - 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">N = 12 --- 2 3</span><br><span class="line">18  2 4 6 8 10 12 14 16 18</span><br><span class="line">    3 6 9 12 15 18</span><br><span class="line">会返回结果为15.</span><br><span class="line">正确答案是12.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int maxn = 1005;</span><br><span class="line">    int a[maxn] = &#123;2, 3, 4&#125;, cnt = 3;</span><br><span class="line">    //FindPrimeFactor(12, a, cnt);</span><br><span class="line">    //cout &lt;&lt; Solve2(18, a, cnt) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; solve(12, 18) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    __int64 i, T, x, y, n, sum;</span><br><span class="line">    while(scanf(&quot;%I64d&quot;, &amp;T) != EOF) &#123;</span><br><span class="line">        for(i = 1; i &lt;= T; i++) &#123;</span><br><span class="line">            scanf(&quot;%I64d%I64d%I64d&quot;, &amp;x, &amp;y, &amp;n);</span><br><span class="line">            //sum = y - haha(y) - (x - 1 - haha(x - 1)); //由于区间是[x,y],求出[1,y]的互质个数，再减去[1,x-1]的互质个数</span><br><span class="line">            printf(&quot;Case #%I64d: &quot;, i);</span><br><span class="line">            printf(&quot;%I64d\n&quot;, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="另外一个缠绕我很久的问题，居然是容斥原理"><a href="#另外一个缠绕我很久的问题，居然是容斥原理" class="headerlink" title="另外一个缠绕我很久的问题，居然是容斥原理"></a>另外一个缠绕我很久的问题，居然是容斥原理</h1><p><a href="https://hankin2015.github.io/2017/12/18/20171218NEUQ1021/">NEUQ1027：谷学长的童年（概率问题）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;容斥原理&quot;&gt;&lt;a href=&quot;#容斥原理&quot; class=&quot;headerlink&quot; title=&quot;容斥原理&quot;&gt;&lt;/a&gt;容斥原理&lt;/h1&gt;&lt;p&gt;在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/rhythmic/p/5503272.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《程序设计中的组合数学》——容斥定理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/han_kin/article/details/47662801&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;容斥定理&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algrithm" scheme="https://hankin2015.github.io/categories/Algrithm/"/>
    
    
      <category term="容斥原理" scheme="https://hankin2015.github.io/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NEUQ1027：谷学长的童年（概率问题）</title>
    <link href="https://hankin2015.github.io/2018/11/09/20181109NEUQ1021/"/>
    <id>https://hankin2015.github.io/2018/11/09/20181109NEUQ1021/</id>
    <published>2018-11-09T02:47:41.000Z</published>
    <updated>2018-11-10T13:35:24.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="http://newoj.acmclub.cn/problems/1021" target="_blank" rel="noopener">题目描述</a></h1><p>小时候，谷学长买了很多干脆面，因为一旦集齐所有类型的卡片就有大奖可拿。<br>谷学长很聪明的意识到要想集齐全套卡片就得买相当多的干脆面，为了尽可能的省钱，他想计算出每种类型卡片均获得一张应买干脆面的期望数目。</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>每个测试用例的第一行包含一个N(1 &lt;= N &lt;= 20), 表示干脆面里可能放置N种类型的卡片，第二行有N个数p1, p2, …, pN, (p1 + p2 + … + pN &lt;= 1), 表示中到对应类型卡片的概率。<br>注意每袋干脆面最多只有一张卡片。<br><a id="more"></a></p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>对于每组测试用例，输出集齐N张不同类型的卡片所买干脆面的期望数目。结果保留三位有效数字。</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><pre><code>10.120.1 0.4</code></pre><h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><pre><code>10.00010.500</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>花了我很久很久的时间来解决这道题。。。</p><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><p>在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。<br>需要注意的是，期望值并不一定等同于常识中的“期望”——“期望值”也许与每一个结果都不相等。期望值是该变量输出值的平均数。期望值并不一定包含于变量的输出值集合里。<br>大数定律规定，随着重复次数接近无穷大，数值的算术平均值几乎肯定地收敛于期望值。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>设C为一个常数，X和Y是两个随机变量。以下是数学期望的重要性质：[2] </p><ol><li>E(C) = C</li><li>E(CX) = CE(X)</li><li>E(X + Y) = E(X) + E(Y)<br>4.当X和Y相互独立时， E(XY) = E(X)E(Y)<br>性质3和性质4可以推到到任意有限个相互独立的随机变量之和或之积的情况。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/63691292" target="_blank" rel="noopener">如何计算不等概率的抽卡次数期望？</a><br><a href="https://www.zybang.com/question/dc33d975f38865257ab9a8d3d35a49d0.html" target="_blank" rel="noopener">为什么说A+B多算的这一块,是他?</a><br><a href="http://blog.sciencenet.cn/blog-752541-995651.html" target="_blank" rel="noopener">为了集齐小浣熊干脆面108将卡,得吃多少袋干脆面？</a><br><a href="https://www.zhihu.com/question/20930350" target="_blank" rel="noopener">假设小浣熊随机赠送的卡片共有 100 种（出现概率相同），那么集齐所有卡片所需购买小浣熊包数的数学期望是多少？</a><br><a href="https://en.wikipedia.org/wiki/Coupon_collector&#39;s_problem" target="_blank" rel="noopener">Coupon collector’s problem</a><br><a href="https://www.guokr.com/question/477410/" target="_blank" rel="noopener">干脆面大家都吃过，里头往往会有一张卡，一共几十种，集齐送奖品。假设只有三种卡，那么集齐卡片需要买的方便面包数X的期望是多少？如果是N种卡，期望又怎么算？</a><br><a href="http://blog.csdn.net/q1w2e3r4470/article/details/60331703" target="_blank" rel="noopener">50个概率题</a><br><a href="https://www.cnblogs.com/no-tears-girl/p/7476175.html" target="_blank" rel="noopener">试题1—经典概率问题：优惠券收集问题</a><br><a href="http://blog.csdn.net/xyb890826/article/details/41829627" target="_blank" rel="noopener">模拟要得到四张不同花色的牌所需要的选取次数，然后显示选中的四张牌（有可能一张牌被选了两次）。</a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>就是使用容斥原理即可，困难我很久的问题终于解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double Solve(int N, double p[])</span><br><span class="line">&#123;</span><br><span class="line">    double ans = 0;</span><br><span class="line">    for (int msk = 1; msk &lt; (1 &lt;&lt; N); msk++) &#123;  // 子串有2^k种可能</span><br><span class="line">        int bits = 0;</span><br><span class="line">        double mult = 0;</span><br><span class="line">        /*每种可能用bit位表示，最多k位，然后看bit位上是否形成组合*/</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (msk &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">                mult += p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double cur = 1 / mult;</span><br><span class="line">        //cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">        if (bits % 2 == 1) ans += cur;</span><br><span class="line">        else ans -= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    double p[25];</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        for (int i = 0; i &lt; N; i++) cin &gt;&gt; p[i];</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; Solve(N, p) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://newoj.acmclub.cn/problems/1021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目描述&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;小时候，谷学长买了很多干脆面，因为一旦集齐所有类型的卡片就有大奖可拿。&lt;br&gt;谷学长很聪明的意识到要想集齐全套卡片就得买相当多的干脆面，为了尽可能的省钱，他想计算出每种类型卡片均获得一张应买干脆面的期望数目。&lt;/p&gt;
&lt;h1 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h1&gt;&lt;p&gt;每个测试用例的第一行包含一个N(1 &amp;lt;= N &amp;lt;= 20), 表示干脆面里可能放置N种类型的卡片，第二行有N个数p1, p2, …, pN, (p1 + p2 + … + pN &amp;lt;= 1), 表示中到对应类型卡片的概率。&lt;br&gt;注意每袋干脆面最多只有一张卡片。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="https://hankin2015.github.io/categories/ACM/"/>
    
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="NEUQ" scheme="https://hankin2015.github.io/tags/NEUQ/"/>
    
  </entry>
  
  <entry>
    <title>一款好玩的游戏：饥荒</title>
    <link href="https://hankin2015.github.io/2018/11/08/20181108DontStarve/"/>
    <id>https://hankin2015.github.io/2018/11/08/20181108DontStarve/</id>
    <published>2018-11-08T11:48:41.000Z</published>
    <updated>2018-11-26T14:26:11.678Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=3c76e13a20f5e0fefa1581533d095fcd/a71ea8d3fd1f41345b63eb5d281f95cad1c85eb9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="饥荒-（2013年Klei-Entertainment出品单机游戏）"><a href="#饥荒-（2013年Klei-Entertainment出品单机游戏）" class="headerlink" title="饥荒 （2013年Klei Entertainment出品单机游戏）"></a>饥荒 （2013年Klei Entertainment出品单机游戏）</h1><p>《饥荒》是由Klei Entertainment开发的一款动作冒险类求生游戏，于2013年4月23日在PC上发行，2015年7月9日在iOS发布口袋版。<br>游戏讲述的是关于一名科学家被恶魔传送到了一个神秘的世界，玩家将在这个异世界生存并逃出这个异世界的故事。</p><p>Don’t Starve不要饿死<br>The Forge熔炉</p><a id="more"></a><h1 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h1><p>上帝模式，顾名思义是给小学生用的。<br>上帝模式：一般情况下不掉血，不掉脑残，不掉饥饿。<br>方法一：c_godmode()<br>方法二：GetPlayer().components.health:SetInvincible(true) </p><p>关闭：GetPlayer().components.health:SetInvincible(false)<br>跳虫洞、重进游戏都会关闭。</p><h1 id="复活石代码"><a href="#复活石代码" class="headerlink" title="复活石代码"></a>复活石代码</h1><p>似乎只能是房主的复活石有用。<br>c_spawn(“resurrectionstone”,1)</p><h1 id="饥荒移动手杖代码"><a href="#饥荒移动手杖代码" class="headerlink" title="饥荒移动手杖代码"></a>饥荒移动手杖代码</h1><p>c_give(“cane”,1)</p><h1 id="取企鹅蛋"><a href="#取企鹅蛋" class="headerlink" title="取企鹅蛋"></a>取企鹅蛋</h1><p>烧树火攻、晚上取蛋。</p><h1 id="存档"><a href="#存档" class="headerlink" title="存档"></a><a href="https://jingyan.baidu.com/article/5d368d1ef62fd33f60c05788.html" target="_blank" rel="noopener">存档</a></h1><p>C:\Users\用户名\Documents（win7以上）在里面找到Klei文件夹。<br>在Klei文件夹中，会有两个文件 DoNotStarve 和 DoNotStarveTogether 联机版的名称是DoNotStarveTogether</p><h1 id="植物患病"><a href="#植物患病" class="headerlink" title="植物患病"></a>植物患病</h1><p>铲掉，不然会传染。</p><h1 id="冒险模式"><a href="#冒险模式" class="headerlink" title="冒险模式"></a>冒险模式</h1><p>饥荒联机版没有冒险模式，冒险模式作用是来解锁人物的，联机版全解锁。</p><h1 id="羚羊、鬣狗、秃鹫和龙蝇"><a href="#羚羊、鬣狗、秃鹫和龙蝇" class="headerlink" title="羚羊、鬣狗、秃鹫和龙蝇"></a>羚羊、鬣狗、秃鹫和龙蝇</h1><p>羚羊：逼墙角或者晚上生火击杀。<br>秃鹫：丢肉吸引击杀。<br>龙蝇：龙蝇是游戏中拥有最高DPS 的生物。如果你在龙蝇愤怒时退出游戏，重新进入游戏时龙蝇会立即猛击地面。　多人版饥荒中，龙蝇有27500生命，是游戏中血量最高的生物。这使得即使多名玩家协力也难以杀死她。</p><h1 id="可疑的大理石"><a href="#可疑的大理石" class="headerlink" title="可疑的大理石"></a>可疑的大理石</h1><p>用铁镐敲雕像可以得到图纸和大理石块。一些雕像敲完就没有了，最终会留下3个雕像。没错这三个雕像分别是发条主教，发条骑士和发条战车。主教和骑士的头丢了，战车鼻子丢了，必须修复它。<br>可疑的大理石就是材料，直接背移动很慢，可疑骑牛，然后修补雕像，月圆之夜敲碎会复活。</p><h1 id="图纸的作用"><a href="#图纸的作用" class="headerlink" title="图纸的作用"></a>图纸的作用</h1><p>给制图。</p><h1 id="可疑的土堆"><a href="#可疑的土堆" class="headerlink" title="可疑的土堆"></a>可疑的土堆</h1><p>在饥荒游戏中，可疑土堆只有一个作用，那就是追踪无尾象啦。在主世界中，土堆会随机出现，如果我们不管它，这些土堆的位置还会改变。如果是有用的土堆，调查后会发现无尾象的脚印，而无尾象的位置就可以通过脚印来判断了，脚趾方向就是无尾象前进的方向了。这时候我们如果继续跟着脚印调查，大概两个满屏地图那么大，就可以找到无尾象了。<br>当我们调查到最后一个可以土堆的时候，游戏中会有角色对话，说该动物就在附近。玩家如果想顺利找到无尾象，就必须每个可疑土堆都调查一下，每次的土堆最少六个，最多有十二个。玩家调查过的交易会在一分钟后消失，如果没有找到下一个线索，就会追丢无尾象了。<br>当然了，有时就算我们调查了线索也不一定可以找到无尾象，因为有时调查的可疑土堆会提示这并不是无尾象的脚印哦。</p><p>持续8-10个会找到，分两种：夏象和冬象。<br>攻击一下拉仇恨，然后跑到圈里面。</p><h1 id="草蜥蜴"><a href="#草蜥蜴" class="headerlink" title="草蜥蜴"></a>草蜥蜴</h1><p>草会变异，然后变成四处乱跑的草蜥蜴，所以建议大家在新版联机种植的时候把草用墙围起来，没必要去花时间杀草蜥蜴，因为草蜥蜴受到惊吓就会掉落草，感觉比等草自己长大效率还高些额。</p><h1 id="养牛"><a href="#养牛" class="headerlink" title="养牛"></a>养牛</h1><p>杀牦牛，得牛角，吹牛角。</p><h1 id="夏季BOSS蚁狮"><a href="#夏季BOSS蚁狮" class="headerlink" title="夏季BOSS蚁狮"></a>夏季BOSS蚁狮</h1><p>会产生地震。准备保暖石击杀。<br><a href="https://www.gamersky.com/handbook/201704/889517.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201704/889517.shtml</a></p><h1 id="大理石种植"><a href="#大理石种植" class="headerlink" title="大理石种植"></a>大理石种植</h1><p>一个大理石合成一个大理石豌豆。</p><h1 id="驯牛"><a href="#驯牛" class="headerlink" title="驯牛"></a>驯牛</h1><p><a href="https://jingyan.baidu.com/article/3c343ff7ca50ab0d36796349.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/3c343ff7ca50ab0d36796349.html</a><br>1、使用新物品猫尾鞭<br>2、喂食，可以选择草，树枝（这个都吃）,蔬菜</p><p>永久。</p><h1 id="《饥荒》多肉的球茎怎么用"><a href="#《饥荒》多肉的球茎怎么用" class="headerlink" title="《饥荒》多肉的球茎怎么用?"></a>《饥荒》多肉的球茎怎么用?</h1><p>答：可以当种子种在地上，等长大了就可以刷肉，或者当狗牙陷阱一样当陷阱。</p><h1 id="舞台之饰"><a href="#舞台之饰" class="headerlink" title="舞台之饰"></a>舞台之饰</h1><p>天黑带灯引走，最好引到以后不太去的角落，不过我挺喜欢这个茶几的，花瓶里的花枯萎后可以用花瓣换上鲜花，每次还回5点精神，每次花瓶的的花也会不太一样。</p><h1 id="雪球发射器"><a href="#雪球发射器" class="headerlink" title="雪球发射器"></a>雪球发射器</h1><p>夏季必备。防止东西被烧毁。</p><p>雪球发射器没油解决方法介绍：加燃料，木头草树枝大便腐烂食物草根树苗木板绳子各种。</p><h1 id="发光的物品"><a href="#发光的物品" class="headerlink" title="发光的物品"></a>发光的物品</h1><p>在洞穴里有。</p><h1 id="蜂箱、种植花"><a href="#蜂箱、种植花" class="headerlink" title="蜂箱、种植花"></a>蜂箱、种植花</h1><p>每天能收蜂蜜，捕蝴蝶种植成花。</p><h1 id="如何杀海象"><a href="#如何杀海象" class="headerlink" title="如何杀海象"></a>如何杀海象</h1><h1 id="宝石来源"><a href="#宝石来源" class="headerlink" title="宝石来源"></a>宝石来源</h1><p>红宝石啊 有两种方法获得：第一：挖坟最简单了，准备一把铲子，去森林什么地方（坟多的）挖，很容易挖到。也有蓝宝石和紫宝石（齿轮，什么遗物什么的）。第二：打着火的那种（地狱狗）也有几率获得红宝石，如果要蓝宝石白色的（冰冻狗）获得蓝宝石，打发条教主死了会掉落紫宝石（远程攻击小心，我被他打死过几次）和齿轮。（齿轮可做冰箱）</p><h1 id="升级切斯特"><a href="#升级切斯特" class="headerlink" title="升级切斯特"></a>升级切斯特</h1><p>准备条件：9个蓝宝石（冰箱）或9个噩梦燃料（大宝箱）。<br>天时：月圆之夜。</p><h1 id="好用的mod"><a href="#好用的mod" class="headerlink" title="好用的mod"></a>好用的mod</h1><ul><li>minimap：小地图</li><li>fast travel：路标</li><li>建筑几何学：</li><li>show me：显示物品属性</li></ul><h1 id="《饥荒》熔炉模式人物能力介绍及打法攻略-饥荒熔炉模式怎么玩"><a href="#《饥荒》熔炉模式人物能力介绍及打法攻略-饥荒熔炉模式怎么玩" class="headerlink" title="《饥荒》熔炉模式人物能力介绍及打法攻略 饥荒熔炉模式怎么玩"></a>《饥荒》熔炉模式人物能力介绍及打法攻略 饥荒熔炉模式怎么玩</h1><p><a href="https://www.gamersky.com/handbook/201710/972043.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201710/972043.shtml</a></p><h1 id="地图卷轴"><a href="#地图卷轴" class="headerlink" title="地图卷轴"></a>地图卷轴</h1><p>羽毛笔+纸。个人感觉好像把自己的地图视野给其他小伙伴共享。</p><h1 id="老奶奶"><a href="#老奶奶" class="headerlink" title="老奶奶"></a>老奶奶</h1><p>老奶奶的优势在于自带2级科技，前期可以不用担心科技问题，而且只要地点合适就可以安家。而她携带的几种书籍，入睡觉书配合触手书与雷电书清怪效果很不错。<br>但是缺点同样明显，使用书籍需要消耗精神，可是不能睡觉，也就无法就地补充精神值，这也导致很容易出现精神过低的情况。同时由于血量低以及伤害偏低，所以打怪时间比较长。<br>总体老说最需要注意的就是脑残值，必须随时关注。脑残值建议带高帽，这比脑残片靠谱，当然其他各种食物什么的都可以备着。</p><p>老奶奶有失眠症，她的特点就是失眠，不能睡觉。<br>老奶奶不睡觉怎么补充精神<br>以试试这样恢复精神：<br>高礼帽+ 狗牙小背心，<br>贝雷帽效果更好，<br>不行就和二师兄做朋友，<br>吃烤熟的绿蘑菇和太妃糖加的精神也很多。</p><h1 id="完全正常的树"><a href="#完全正常的树" class="headerlink" title="完全正常的树"></a>完全正常的树</h1><p><a href="http://zh.dontstarve.wikia.com/wiki/%E6%A8%B9/%E5%AE%8C%E5%85%A8%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%A8%B9" target="_blank" rel="noopener">http://zh.dontstarve.wikia.com/wiki/%E6%A8%B9/%E5%AE%8C%E5%85%A8%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%A8%B9</a><br>不清楚添加三个什么东西可以装饰，但可以砍伐得活木。</p><h1 id="饥荒眼骨死了怎么办"><a href="#饥荒眼骨死了怎么办" class="headerlink" title="饥荒眼骨死了怎么办"></a>饥荒眼骨死了怎么办</h1><p>饥荒游戏中眼骨就是斯切特，它有复活功能，一般在死后过个两天左右，在它死时的原地方就可以发现它。然后重新捡起来即可使用。</p><h1 id="饥荒独立服务器搭建"><a href="#饥荒独立服务器搭建" class="headerlink" title="饥荒独立服务器搭建"></a>饥荒独立服务器搭建</h1><p><a href="http://lebi.github.io/2016/06/14/%E9%A5%A5%E8%8D%92%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">http://lebi.github.io/2016/06/14/%E9%A5%A5%E8%8D%92%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</a><br><a href="https://www.jianshu.com/p/440d64cd3ac4" target="_blank" rel="noopener">https://www.jianshu.com/p/440d64cd3ac4</a></p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>月圆之夜：采集花<br>科学机器<br>Y-发消息<br>M-地图<br>~-代码模式<br>tab-查看队友信息</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　可用Ctrl+F查询所需物品名称（大部分代码名称已修改成联机中文MOD翻译）。</p><p>　　进入游戏后按“～”键调出控制台</p><p>　　输入c_give(“代码名称“，数量）——物品会按所输数量出现在物品栏，假若包裹放不下，会自动掉落在地上。此代码最方便，甚至还可以在鼠标指针处直接放置建筑类物品。</p><p>　　c_spawn(“XX”，数量)——放鼠标指针指示的地上</p><p>　　上帝模式：c_godmode()</p><p>　　饥饿值上限：GetPlayer().components.hunger:SetMax(500)</p><p>　　精神值上限：GetPlayer().components.sanity:SetMax(500)</p><p>　　生命值上限：GetPlayer().components.health:SetMaxHealth(300)</p><p>　　全物品直接制造：GetPlayer().components.builder:GiveAllRecipes()</p><p>　　删除物品：TheInput:GetWorldEntityUnderMouse():Remove()</p><p>　　传送：GetPlayer().Transform:SetPosition(坐标，例：0,0,0)</p><p>　　此列表已剔除一些对于联机无效的代码，测试过真实有效。</p><h1 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h1><p>　　割下的草：cutgrass</p><p>　　树枝：twigs</p><p>　　木头：log</p><p>　　木炭：charcoal</p><p>　　灰：ash</p><p>　　采集的芦苇：cutreeds</p><p>　　花瓣：petals</p><p>　　噩梦花瓣：petals_evil</p><p>　　活木头：livinglog</p><p>　　叶子：foliage</p><p>　　荧光果：lightbulb</p><p>　　发光浆果：wormlight</p><p>　　冰：ice</p><p>　　燧石：flint</p><p>　　硝石：nitre</p><p>　　岩石：rocks</p><p>　　大理石：marble</p><p>　　月之石：moonrocknugget</p><p>　　黄金：goldnugget</p><p>　　铥矿石：thulecite</p><p>　　铥矿石碎片：thulecite_pieces</p><p>　　红宝石：redgem</p><p>　　蓝宝石：bluegem</p><p>　　紫宝石：purplegem</p><p>　　绿宝石：greengem</p><p>　　橙宝石：orangegem</p><p>　　黄宝石：yellowgem</p><p>　　彩色宝石：opalpreciousgem</p><p>　　绳子：rope</p><p>　　木板：boards</p><p>　　石砖：cutstone</p><p>　　莎草纸：papyrus</p><p>　　噩梦燃料：nightmarefuel</p><p>　　蜂蜡：beeswax</p><p>　　蜡纸：waxpaper</p><p>　　电器元件：transistor</p><p>　　狗牙：houndstooth</p><p>　　蜘蛛丝：silk</p><p>　　蜘蛛腺体：spidergland</p><p>　　胡子：beardhair</p><p>　　牛毛：beefalowool</p><p>　　牛角：hornm</p><p>　　猫尾：coontail</p><p>　　海象牙：walrus_tusk</p><p>　　胡须：beardhair</p><p>　　烂鸡蛋：rottenegg</p><p>　　乌鸦羽毛：feather_crow</p><p>　　红雀羽毛：feather_robin</p><p>　　雪雀羽毛：feather_robin_winter</p><p>　　金丝雀羽毛：feather_canary</p><p>　　鸟粪：guano</p><p>　　触手皮：tentaclespots</p><p>　　粘滑含糊虫（黏糊虫粘液）：slurtleslime</p><p>　　破碎的背壳：slurtle_shellpieces</p><p>　　蚊子血袋：mosquitosack</p><p>　　缀食者皮：slurper_pelt</p><p>　　远古守护者角：minotaurhorn</p><p>　　掉落的羽毛：goose_feather</p><p>　　鳞片：dragon_scales</p><p>　　厚皮毛：bearger_fur</p><p>　　巨鹿眼球：deerclops_eyeball</p><p>　　毒蕈皮：shroom_skin</p><p>　　闪电羊角：lightninggoathorn</p><p>　　格罗门翅膀：glommerwings</p><p>　　格罗门花（花瞬间死亡）：glommerflower</p><p>　　格罗门燃料：glommerfuel</p><p>　　冷冻虫卵：lavae_cocoon</p><p>　　暗影之心：shadowheart</p><p>　　鹿茸：deer_antler</p><p>　　克劳斯钥匙：klaussackkey</p><p>　　齿轮：gears</p><p>　　骨片：boneshard</p><p>　　化石碎片（据说多种实际上只出一种）：fossil_piece</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>　　斧头：axe</p><p>　　金斧头：goldenaxe</p><p>　　露西斧：lucy</p><p>　　鹤嘴锄：pickaxe</p><p>　　黄金鹤嘴锄：goldenpickaxe</p><p>　　铁铲：shovel</p><p>　　黄金铁铲（讲真黄金做的还能叫铁铲）：goldenshovel</p><p>　　镐斧：multitool_axe_pickaxe</p><p>　　锤子：hammer</p><p>　　草叉：pitchfork</p><p>　　剃刀：razor</p><p>　　捕虫网：bugnet</p><p>　　鱼竿：fishingrod</p><p>　　陷阱：trap</p><p>　　鸟陷阱：birdtrap</p><p>　　南瓜灯：pumpkin_lantern</p><p>　　提灯：lantern</p><p>　　漂亮太阳伞：grass_umbrella</p><p>　　雨伞：umbrella</p><p>　　保温石：heatrock</p><p>　　水球：waterballoon</p><p>　　指南针：compass</p><p>　　空包裹：bundlewrap</p><p>　　彩纸：giftwrap</p><p>　　稻草卷：bedroll_straw</p><p>　　毛皮铺盖：bedroll_furry</p><p>　　鹅毛扇：featherfan</p><p>　　狗牙陷阱：trap_teeth</p><p>　　麦斯威尔的利齿陷阱：trap_teeth_maxwell</p><p>　　背包：backpack</p><p>　　猪皮包：piggyback</p><p>　　隔热包：icepack</p><p>　　坎普斯背包：krampus_sack</p><p>　　糖果袋：candybag</p><p>　　羽毛笔：featherpencil</p><p>　　便便蓝：fertilizer</p><p>　　取鞍器：saddlehorn</p><p>　　鞍：saddle_basic</p><p>　　浴血战鞍：saddle_war</p><p>　　闪亮之鞍：saddle_race</p><p>　　刷子：brush</p><p>　　舐盐器：saltlick</p><p>武器</p><p>　　长矛：spear</p><p>　　瓦丝格雷斯矛：spear_wathgrithr</p><p>　　气球（吹好的，可以装饰自己的窝~）：balloon</p><p>　　火腿球棒：hambat</p><p>　　触手尖刺：tentaclespike</p><p>　　晨星：nightstick</p><p>　　三脚猫的教诲：whip</p><p>　　暗影剑：nightsword</p><p>　　蝙蝠斧棍：batbat</p><p>　　铥矿棒：ruins_bat</p><p>　　冰魔杖（蓝）：icestaff</p><p>　　火魔杖（红）：firestaff</p><p>　　传送魔杖（紫）：telestaff</p><p>　　懒惰的探索者（橙）：orangestaff</p><p>　　星星呼唤者（黄）：yellowstaff</p><p>　　毁灭权杖（绿）：greenstaff</p><p>　　魔杖（单机用来找零件那个）：diviningrod</p><p>　　呼月者权杖：opalstaff</p><p>　　回旋镖：boomerang</p><p>　　吹箭：blowdart_pipe</p><p>　　燃烧吹箭：blowdart_fire</p><p>　　麻醉吹箭：blowdart_sleep</p><p>　　电磁吹箭：blowdart_yellow</p><p>　　旋风：staff_tornado</p><p>　　排箫：panflute</p><p>　　独奏乐器:onemanband</p><p>　　火药：gunpowder</p><p>　　蜜蜂地雷：beemine</p><p>　　恒迪尤斯·舒提尤斯（眼睛炮塔）：eyeturret</p><p>　　可放置的眼睛炮塔：eyeturret_item</p><p><a href="https://www.gamersky.com/handbook/201701/859832.shtml" target="_blank" rel="noopener">https://www.gamersky.com/handbook/201701/859832.shtml</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=3c76e13a20f5e0fefa1581533d095fcd/a71ea8d3fd1f41345b63eb5d281f95cad1c85eb9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;h1 id=&quot;饥荒-（2013年Klei-Entertainment出品单机游戏）&quot;&gt;&lt;a href=&quot;#饥荒-（2013年Klei-Entertainment出品单机游戏）&quot; class=&quot;headerlink&quot; title=&quot;饥荒 （2013年Klei Entertainment出品单机游戏）&quot;&gt;&lt;/a&gt;饥荒 （2013年Klei Entertainment出品单机游戏）&lt;/h1&gt;&lt;p&gt;《饥荒》是由Klei Entertainment开发的一款动作冒险类求生游戏，于2013年4月23日在PC上发行，2015年7月9日在iOS发布口袋版。&lt;br&gt;游戏讲述的是关于一名科学家被恶魔传送到了一个神秘的世界，玩家将在这个异世界生存并逃出这个异世界的故事。&lt;/p&gt;
&lt;p&gt;Don’t Starve不要饿死&lt;br&gt;The Forge熔炉&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://hankin2015.github.io/categories/Others/"/>
    
    
      <category term="Game" scheme="https://hankin2015.github.io/tags/Game/"/>
    
      <category term="饥荒" scheme="https://hankin2015.github.io/tags/%E9%A5%A5%E8%8D%92/"/>
    
  </entry>
  
  <entry>
    <title>判断一个点是否在一个多边形内</title>
    <link href="https://hankin2015.github.io/2018/11/03/20181103poly/"/>
    <id>https://hankin2015.github.io/2018/11/03/20181103poly/</id>
    <published>2018-11-03T03:48:41.000Z</published>
    <updated>2018-11-03T11:54:27.313Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。</p><a id="more"></a><h1 id="简单的特例：三角形"><a href="#简单的特例：三角形" class="headerlink" title="简单的特例：三角形"></a>简单的特例：三角形</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>比较常用的算法是射线法，以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。<br>若有偶数个交点则在形外，否则在形内。<br>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>面积法：海伦公式、向量公式</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>向量法</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://hihocoder.com/contest/hiho225/problem/1" target="_blank" rel="noopener">http://hihocoder.com/contest/hiho225/problem/1</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">在三角形内部的点形成的都是钝角三角形</span><br><span class="line">点在x,y的中间并不能判断</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long double</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">LL Heron(LL a, LL b, LL c)</span><br><span class="line">&#123;</span><br><span class="line">    return 0.25 * sqrt((a + b + c) * (a + b - c) * (a + c - b) * (b + c - a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL Distance(LL x1, LL y1, LL x2, LL y2)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        LL x[4], y[4];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">        LL s = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 2; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; 4; j++) &#123;</span><br><span class="line">                LL a = Distance(x[0], y[0], x[i], y[i]), b = Distance(x[0], y[0], x[j], y[j]), c = Distance(x[i], y[i], x[j], y[j]);</span><br><span class="line">                s += Heron(a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Distance(x[1], y[1], x[2], y[2]), b = Distance(x[1], y[1], x[3], y[3]), c = Distance(x[2], y[2], x[3], y[3]);</span><br><span class="line">        //cout &lt;&lt; s &lt;&lt; &apos; &apos; &lt;&lt; Heron(a, b, c) &lt;&lt; endl;</span><br><span class="line">        if (abs(s - Heron(a, b, c)) &lt; eps) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输入的都是整数，三角形面积计算s=0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">所有面积里都有这个0.5，去掉这个0.5对结果不影响，于是面积计算出来就是整数，没有精度问题了。</span><br><span class="line">向量法求面积。</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">LL area(LL x1,LL y1,LL x2,LL y2,LL x3,LL y3)</span><br><span class="line">&#123;</span><br><span class="line">    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LL Px, Py, Ax, Ay, Bx, By, Cx, Cy;</span><br><span class="line">    LL S, S1, S2, S3;</span><br><span class="line">    LL t;</span><br><span class="line">    for(cin&gt;&gt;t;t&gt;0;t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;Px&gt;&gt;Py&gt;&gt;Ax&gt;&gt;Ay&gt;&gt;Bx&gt;&gt;By&gt;&gt;Cx&gt;&gt;Cy;</span><br><span class="line">        S  = area(Ax, Ay, Bx, By, Cx, Cy);</span><br><span class="line">        S1 = area(Px, Py, Ax, Ay, Bx, By);</span><br><span class="line">        S2 = area(Px, Py, Ax, Ay, Cx, Cy);</span><br><span class="line">        S3 = area(Px, Py, Bx, By, Cx, Cy);</span><br><span class="line">        if(S1+S2+S3&lt;=S)cout&lt;&lt;&quot;YES\n&quot;;else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">还有个简单的方法，判断三条边的向量与P跟三个点连接的向量的叉积，如果三个叉积值同正负，则在三角形内。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define G(v,_) scanf(&quot;%ld&quot;,&amp;v),v-=_;</span><br><span class="line">main(T)&#123;long p,P,a,A,b,B,c,C,x,y,z;for(G(T,0)T--;puts(((-x|-y|-z)&amp;(x|y|z))&lt;0?&quot;NO&quot;:&quot;YES&quot;))&#123;G(p,0)G(P,0)G(a,p)G(A,P)G(b,p)G(B,P)G(c,p)G(C,P)x=a*B-b*A;y=b*C-c*B;z=c*A-a*C;&#125;return 0;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四边形特例：矩形"><a href="#四边形特例：矩形" class="headerlink" title="四边形特例：矩形"></a>四边形特例：矩形</h1><p>（1）面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。<br>（2）夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。<br>（3）引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</p><p><a href="https://blog.csdn.net/u283056051/article/details/53980832" target="_blank" rel="noopener">https://blog.csdn.net/u283056051/article/details/53980832</a><br>1、射线法理论：从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。<br>2、特殊情况特殊处理：</p><pre><code>1. 点在多边形的边上 ：判断点与边端点连线斜率是否相同。2. 点和多边形的顶点重合 ：直接hash。3. 射线经过多边形顶点：只需要规定被射线穿越的点都算作其中一侧。 4. 射线刚好经过多边形的一条边：上面的特例，经过两个顶点。射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。</code></pre><h1 id="多边形代码（射线法和回转数法）"><a href="#多边形代码（射线法和回转数法）" class="headerlink" title="多边形代码（射线法和回转数法）"></a>多边形代码（射线法和回转数法）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">测试题：http://hihocoder.com/problemset/problem/1450?sid=1416458</span><br><span class="line">射线法没有过，回转数法连样例都不了，还弄不明白哪里错了。</span><br><span class="line">参考：https://blog.csdn.net/u283056051/article/details/53980832</span><br><span class="line">*/</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1e3 + 5;</span><br><span class="line">const double eps = 1e-5;</span><br><span class="line">const double PI = atan(1) * 4;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 射线法</span><br><span class="line">string RayCasting(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey)) return &quot;on&quot;;</span><br><span class="line">        // 2、做一条水平射线，判断边两断点是否在射线两侧，并令穿过顶点的点在上端</span><br><span class="line">        if ((sy &lt; p.y &amp;&amp; ey &gt;= p.y) || (sy &gt;= p.y &amp;&amp; ey &lt; p.y)) &#123;</span><br><span class="line">            // 3、判断p点是否在多边形边上，斜率公式或者三角形比例公式（方便）</span><br><span class="line">            double x = sx + (p.y - sy) * (ex - sx) * 1.0 / (ey - sy);</span><br><span class="line">            if (abs(x - p.x) &lt; eps) return &quot;on&quot;;</span><br><span class="line">            // 水平向右作的射线，穿过一次就变换</span><br><span class="line">            if (x &gt; p.x) flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? &quot;in&quot; : &quot;out&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回转数法</span><br><span class="line">string WindingNumber(node p, node poly[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0;  // 回转度数和</span><br><span class="line">    // 首尾相连n条边</span><br><span class="line">    for (int i = 0, j = n - 1; i &lt; n; j = i, i++) &#123;</span><br><span class="line">        int sx = poly[i].x, sy = poly[i].y;</span><br><span class="line">        int ex = poly[j].x, ey = poly[j].y;</span><br><span class="line">        // 1、判断p点和多边形顶点是否重合或在多边形边上</span><br><span class="line">        if ((p.x == sx &amp;&amp; p.y == sy) || (p.x == ex &amp;&amp; p.y == ey) || (p.x - sx) * (ey - sy) == (p.y - sy) * (ex - sx)) return &quot;on&quot;;</span><br><span class="line">        // 2、求夹角</span><br><span class="line">        double angle = atan((sy - p.y) * 1.0 / (sx - p.x)) - atan((ey - p.y) * 1.0 / (ex - p.x));</span><br><span class="line">        cout &lt;&lt; angle &lt;&lt; endl;</span><br><span class="line">        // 3、确保夹角不超过取值范围（-PI到PI）</span><br><span class="line">        if (angle &gt;= PI) angle -= 2 * PI;</span><br><span class="line">        else if (angle &lt;= -PI) angle += 2 * PI;</span><br><span class="line">        sum += angle;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    // 4、计算回转数</span><br><span class="line">    return round(sum / PI) == 0 ? &quot;out&quot; : &quot;in&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    node p, poly[maxn];</span><br><span class="line">    int n = 3, T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        cin &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; poly[i].x &gt;&gt; poly[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        string res1 = RayCasting(p, poly, 3);</span><br><span class="line">        string res2 = WindingNumber(p, poly, 3);</span><br><span class="line">        if (res1 != res2) cout &lt;&lt; &quot;Wrong&quot; &lt;&lt; endl;</span><br><span class="line">        else if (res1 == &quot;out&quot;) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个点是不是在一个多边形内是很经典的计算几何问题。一般可以是凸多边形也可以是凹多边形。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="https://hankin2015.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="凸包" scheme="https://hankin2015.github.io/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://hankin2015.github.io/2018/10/31/20181031topo/"/>
    <id>https://hankin2015.github.io/2018/10/31/20181031topo/</id>
    <published>2018-10-31T03:48:41.000Z</published>
    <updated>2018-11-03T12:22:40.474Z</updated>
    
    <content type="html"><![CDATA[<p>Face++面试中遇到的问题，手写一个拓扑排序函数，数据按照链式存储，即每个点链表存储出度的点。<br>当时想出了一种解决方法，不过看了其他解法，感觉自己的方法有点复杂，不过时间复杂度都是O(n^2)。</p><p>我当时的想法：正序没法找到拓扑的前后顺序，但是反过来就迎刃而解。从结束点（出度为0）开始，入队列。然后将入度当前点的点加入队列中。这样就找到了反序的拓扑序列，然后利用栈的特点反转就得到答案了。<br>当时面试官还和我谈论验证这个解法，但我觉得没啥问题。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">提示：跟一般的排序不一样，这个用于有向无环图</span><br><span class="line"></span><br><span class="line">对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，</span><br><span class="line">使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。</span><br><span class="line"></span><br><span class="line">拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某</span><br><span class="line">些工程执行后才可以执行。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</span><br><span class="line">//优先队列的话，会按照数值大小有顺序的输出</span><br><span class="line">//此处为了理解，暂时就用简单队列</span><br><span class="line">int topo()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(indegree[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);  // 起点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=q.front();// 如果是优先队列，这里可以是top()</span><br><span class="line">        printf(&quot;%d-&gt;&quot;,temp);</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)// 遍历从temp出发的每一条边，入度--</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[temp][i])</span><br><span class="line">            &#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                if(indegree[i]==0)q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Face++面试中遇到的问题，手写一个拓扑排序函数，数据按照链式存储，即每个点链表存储出度的点。&lt;br&gt;当时想出了一种解决方法，不过看了其他解法，感觉自己的方法有点复杂，不过时间复杂度都是O(n^2)。&lt;/p&gt;
&lt;p&gt;我当时的想法：正序没法找到拓扑的前后顺序，但是反过来就迎刃而解。从结束点（出度为0）开始，入队列。然后将入度当前点的点加入队列中。这样就找到了反序的拓扑序列，然后利用栈的特点反转就得到答案了。&lt;br&gt;当时面试官还和我谈论验证这个解法，但我觉得没啥问题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="拓扑排序" scheme="https://hankin2015.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序" scheme="https://hankin2015.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>python中os模块</title>
    <link href="https://hankin2015.github.io/2018/10/27/20181027os/"/>
    <id>https://hankin2015.github.io/2018/10/27/20181027os/</id>
    <published>2018-10-27T03:48:41.000Z</published>
    <updated>2019-01-02T07:25:27.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判读文件和文件夹是否存在"><a href="#判读文件和文件夹是否存在" class="headerlink" title="判读文件和文件夹是否存在"></a>判读文件和文件夹是否存在</h1><p>文件能直接保存创建，但文件夹不行，需要先创建文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">if not os.path.exists(&apos;name&apos;):  # 能判断文件和文件夹</span><br><span class="line">os.mkdir(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">os.path.isfile(&apos;name&apos;)  # 只能判断文件</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>使用os.access()方法判断文件是否可进行读写操作。</p><p>语法：os.access(path, mode)</p><p>path为文件路径，mode为操作模式，有这么几种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.F_OK: 检查文件是否存在;</span><br><span class="line">os.R_OK: 检查文件是否可读;</span><br><span class="line">os.W_OK: 检查文件是否可以写入;</span><br><span class="line">os.X_OK: 检查文件是否可以执行.</span><br><span class="line"></span><br><span class="line">if not os.access(&apos;name&apos;, os.F_OK):</span><br><span class="line">os.mkdir(&apos;name&apos;)</span><br></pre></td></tr></table></figure></p><p>try语句也能，但尽量少用。<br>os.makedirs(path) 多层创建目录</p><h1 id="获取当前文件夹下所有文件"><a href="#获取当前文件夹下所有文件" class="headerlink" title="获取当前文件夹下所有文件"></a>获取当前文件夹下所有文件</h1><p>使用os.walk()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dataPath = &apos;./Unprocessed/&apos; </span><br><span class="line">def ListFile(fileDir):   </span><br><span class="line">    ret = []   </span><br><span class="line">    for root, dirs, files in os.walk(fileDir):  </span><br><span class="line">        for file in files:  </span><br><span class="line">            if os.path.splitext(file)[1] == &apos;.txt&apos;:   #其中os.path.splitext()函数将路径拆分为文件名+扩展名</span><br><span class="line">                ret.append(os.path.join(root, file))  </span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line">files = ListFile(dataPath)</span><br></pre></td></tr></table></figure></p><h1 id="使用os模块进行分类整理"><a href="#使用os模块进行分类整理" class="headerlink" title="使用os模块进行分类整理"></a>使用os模块进行分类整理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import shutil, os</span><br><span class="line"></span><br><span class="line">path = &apos;./&apos;</span><br><span class="line">files = os.listdir(path)</span><br><span class="line"></span><br><span class="line">for file in files:</span><br><span class="line">folderName = &apos;./&apos; + file.split(&apos;.&apos;)[-1]</span><br><span class="line">if not os.path.exists(folderName):</span><br><span class="line">os.makedirs(folderName)</span><br><span class="line">shutil.move(file, folderName)</span><br><span class="line"></span><br><span class="line">print(&apos;done&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判读文件和文件夹是否存在&quot;&gt;&lt;a href=&quot;#判读文件和文件夹是否存在&quot; class=&quot;headerlink&quot; title=&quot;判读文件和文件夹是否存在&quot;&gt;&lt;/a&gt;判读文件和文件夹是否存在&lt;/h1&gt;&lt;p&gt;文件能直接保存创建，但文件夹不行，需要先创建文件夹。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if not os.path.exists(&amp;apos;name&amp;apos;):  # 能判断文件和文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	os.mkdir(&amp;apos;name&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.path.isfile(&amp;apos;name&amp;apos;)  # 只能判断文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="https://hankin2015.github.io/categories/PYTHON/"/>
    
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
      <category term="Os" scheme="https://hankin2015.github.io/tags/Os/"/>
    
  </entry>
  
  <entry>
    <title>删除字符串指针中空格和统计文章中的最频繁词</title>
    <link href="https://hankin2015.github.io/2018/10/26/20181026DeleteSpace/"/>
    <id>https://hankin2015.github.io/2018/10/26/20181026DeleteSpace/</id>
    <published>2018-10-26T09:25:41.000Z</published>
    <updated>2018-10-27T02:57:37.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针函数和函数指针的区别"><a href="#指针函数和函数指针的区别" class="headerlink" title="指针函数和函数指针的区别"></a>指针函数和函数指针的区别</h1><p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p><p><a href="https://baijiahao.baidu.com/s?id=1580218358235866033&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">百度搜索特效：搜索黑洞，屏幕真的出现了黑洞一样的画面</a></p><a id="more"></a><h1 id="删除字符串指针中空格"><a href="#删除字符串指针中空格" class="headerlink" title="删除字符串指针中空格"></a>删除字符串指针中空格</h1><ul><li>原始字符串不能是指针字符串，因不能对其本身进行修改</li><li>必须需要两个指针</li><li>末尾需置”\0”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">DeleteSpace</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = str, *q = str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">while</span> (*q != <span class="string">'\0'</span>) &#123;  <span class="comment">// 指针字符串没有"\0"，但char数组有</span></span><br><span class="line">        <span class="keyword">if</span> (*q != <span class="string">' '</span>) &#123;</span><br><span class="line">            *p = *q;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char* str = "  he jian  ";   // 不能写成指针字符串，指针不能对其值进行修改</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"  he jian  "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; DeleteSpace(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="assert进行样例调试"><a href="#assert进行样例调试" class="headerlink" title="assert进行样例调试"></a>assert进行样例调试</h1><ul><li>报错会出现Assertion failed: fun(5) == 6, file C:\Users\Administrator\Desktop\腾讯.cpp, line 41</li><li>不报错正常运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    assert(fun(5) == 6);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="统计文章中的最频繁K个词"><a href="#统计文章中的最频繁K个词" class="headerlink" title="统计文章中的最频繁K个词"></a>统计文章中的最频繁K个词</h1><ul><li>hash + 优先队列</li><li>堆<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//出现次数最多的是个单词  </span><br><span class="line">void top_k_words()  </span><br><span class="line">&#123;  </span><br><span class="line">    timer t;  </span><br><span class="line">    ifstream fin;  </span><br><span class="line">    fin.open(&quot;modern c.txt&quot;);  </span><br><span class="line">    if (!fin)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;can nont open file&quot;&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    string s;  </span><br><span class="line">    hash_map&lt;string,int&gt; countwords;  </span><br><span class="line">    while (true)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fin&gt;&gt;s;  </span><br><span class="line">        if (fin.eof())  </span><br><span class="line">        &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        countwords[s]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;&quot;单词总数 （重复的不计数）:&quot;&lt;&lt;countwords.size()&lt;&lt;endl;  </span><br><span class="line">    priority_queue&lt;pair&lt;int,string&gt;,vector&lt;pair&lt;int,string&gt;&gt;,greater&lt;pair&lt;int,string&gt;&gt;&gt; countmax;  </span><br><span class="line">    for(hash_map&lt;string,int&gt;::const_iterator i=countwords.begin();  </span><br><span class="line">        i!=countwords.end();i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        countmax.push(make_pair(i-&gt;second,i-&gt;first));  </span><br><span class="line">        if (countmax.size()&gt;10)  </span><br><span class="line">        &#123;  </span><br><span class="line">            countmax.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    while(!countmax.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;countmax.top().second&lt;&lt;&quot; &quot;&lt;&lt;countmax.top().first&lt;&lt;endl;  </span><br><span class="line">        countmax.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;&quot;time elapsed &quot;&lt;&lt;t.elapsed()&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><ul><li>top</li><li>size</li><li>empty</li><li>push</li><li>pop<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">void PQueue()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;   // 按照元素从小到大的顺序出队</span><br><span class="line">    //priority_queue&lt;pair&lt;int,string&gt;,vector&lt;pair&lt;int,string&gt;&gt;,greater&lt;pair&lt;int,string&gt;&gt;&gt; countMax;</span><br><span class="line"></span><br><span class="line">    int A[] = &#123;7, 5, 2, 1, 3, 4, 6&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">        Q.push(A[i]);</span><br><span class="line">        int tmp = Q.top();</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PQueue();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针函数和函数指针的区别&quot;&gt;&lt;a href=&quot;#指针函数和函数指针的区别&quot; class=&quot;headerlink&quot; title=&quot;指针函数和函数指针的区别&quot;&gt;&lt;/a&gt;指针函数和函数指针的区别&lt;/h1&gt;&lt;p&gt;指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。&lt;br&gt;函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1580218358235866033&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度搜索特效：搜索黑洞，屏幕真的出现了黑洞一样的画面&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://hankin2015.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://hankin2015.github.io/tags/C/"/>
    
      <category term="Char" scheme="https://hankin2015.github.io/tags/Char/"/>
    
      <category term="指针" scheme="https://hankin2015.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="优先队列" scheme="https://hankin2015.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>bat和vbs脚本</title>
    <link href="https://hankin2015.github.io/2018/10/22/20181022bat_vbs/"/>
    <id>https://hankin2015.github.io/2018/10/22/20181022bat_vbs/</id>
    <published>2018-10-22T09:43:41.000Z</published>
    <updated>2018-10-27T02:56:48.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bat和vbs脚本"><a href="#bat和vbs脚本" class="headerlink" title="bat和vbs脚本"></a>bat和vbs脚本</h1><p>bat脚本是依赖于cmd命令窗口的一种脚本语言。vbs脚本是使用vbasic语言编写的脚本语言，基于wscript.exe程序来运行。两者语法上相差很大.vbs脚本功能更加地强大，他能调用dll动态库完成一些bat不能完成的功能。同时bat与vbs可以互相调用。</p><p>bat是批处文件，实际上是一条条dos命令的集合，由命令行调用。vbs是vb脚本文件，当然还有java脚本文件，vbs由vb语言写成，但他不需要vb那样的编译环境，只要是文本编辑器都可以，他由系统的脚本解释器执行，一般vbs脚本都用在网页中，用于显示一些特效或特殊的用途。<br><a id="more"></a></p><h1 id="自动关机脚本-bat"><a href="#自动关机脚本-bat" class="headerlink" title="自动关机脚本(bat)"></a>自动关机脚本(bat)</h1><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -s -t <span class="number">60</span></span><br><span class="line"></span><br><span class="line">取消 shutdown -a</span><br></pre></td></tr></table></figure><h1 id="隐藏文件-bat"><a href="#隐藏文件-bat" class="headerlink" title="隐藏文件(bat)"></a>隐藏文件(bat)</h1><p>可以将两个不同格式的文件合在一起。<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>/b 何健.jpg+皂片.rar=out.jpg</span><br></pre></td></tr></table></figure></p><h1 id="语音助手-vbs"><a href="#语音助手-vbs" class="headerlink" title="语音助手(vbs)"></a>语音助手(vbs)</h1><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateObject</span>(<span class="string">"SAPI.SpVoice"</span>).speak<span class="string">"机器学习中，如果参数过多，模型过于复杂，容易造成过拟合（overfit）。即模型在训练样本数据上表现的很好，但在实际测试样本上表现的较差，不具备良好的泛化能力。为了避免过拟合，最常用的一种方法是使用使用正则化，例如 L1 和 L2 正则化。但是，正则化项是如何得来的？其背后的数学原理是什么？L1 正则化和 L2 正则化之间有何区别？本文将给出直观的解释。"</span></span><br></pre></td></tr></table></figure><h1 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GodMode.&#123;ED7BA470-8E54-465E-825C-99712043E01C&#125;</span><br><span class="line">新建文件夹-》用上面代码重命名</span><br><span class="line"></span><br><span class="line">隐藏的一个文件夹窗口，包含几乎所有系统的设置。</span><br></pre></td></tr></table></figure><h1 id="黑客帝国中的数字雨"><a href="#黑客帝国中的数字雨" class="headerlink" title="黑客帝国中的数字雨"></a>黑客帝国中的数字雨</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/qq_36238595/article/details/56682261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">&#125;STU;</span><br><span class="line">STU st[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//出现位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hout;</span><br><span class="line">    COORD pos;</span><br><span class="line">    pos.X = x;</span><br><span class="line">    pos.Y = y;</span><br><span class="line"></span><br><span class="line">    hout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    SetConsoleCursorPosition(hout, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐藏光标*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_cursor</span><span class="params">(<span class="keyword">int</span> hide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONSOLE_CURSOR_INFO cciCursor;</span><br><span class="line">    HANDLE hout;</span><br><span class="line"></span><br><span class="line">    hout = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    <span class="keyword">if</span>(GetConsoleCursorInfo(hout, &amp;cciCursor))</span><br><span class="line">    &#123;</span><br><span class="line">        cciCursor.bVisible = hide;</span><br><span class="line">        SetConsoleCursorInfo(hout, &amp;cciCursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置颜色*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_color</span><span class="params">(<span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">show_cursor(<span class="number">0</span>);</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i].x = rand()%<span class="number">80</span>;</span><br><span class="line">st[i].y = rand()%<span class="number">20</span>;</span><br><span class="line">st[i].ch = rand()%(<span class="number">49</span><span class="number">-47</span>)+<span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">gotoxy(st[i].x,st[i].y);</span><br><span class="line">set_color(<span class="number">0x2</span>);</span><br><span class="line"><span class="built_in">putchar</span>(st[i].ch);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-5</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">st[i].y++;</span><br><span class="line">st[i].ch = rand()%(<span class="number">49</span><span class="number">-47</span>)+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">if</span> (st[i].y<span class="number">-5</span>&gt;=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-3</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">gotoxy(st[i].x,st[i].y<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st[i].y &gt; <span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">st[i].x = rand()%<span class="number">80</span>;</span><br><span class="line">st[i].y = rand()%<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">gotoxy(st[i].x,st[i].y);</span><br><span class="line">set_color(<span class="number">0xA</span>);</span><br><span class="line"><span class="built_in">putchar</span>(st[i].ch);</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;bat和vbs脚本&quot;&gt;&lt;a href=&quot;#bat和vbs脚本&quot; class=&quot;headerlink&quot; title=&quot;bat和vbs脚本&quot;&gt;&lt;/a&gt;bat和vbs脚本&lt;/h1&gt;&lt;p&gt;bat脚本是依赖于cmd命令窗口的一种脚本语言。vbs脚本是使用vbasic语言编写的脚本语言，基于wscript.exe程序来运行。两者语法上相差很大.vbs脚本功能更加地强大，他能调用dll动态库完成一些bat不能完成的功能。同时bat与vbs可以互相调用。&lt;/p&gt;
&lt;p&gt;bat是批处文件，实际上是一条条dos命令的集合，由命令行调用。vbs是vb脚本文件，当然还有java脚本文件，vbs由vb语言写成，但他不需要vb那样的编译环境，只要是文本编辑器都可以，他由系统的脚本解释器执行，一般vbs脚本都用在网页中，用于显示一些特效或特殊的用途。&lt;br&gt;
    
    </summary>
    
      <category term="OTHER" scheme="https://hankin2015.github.io/categories/OTHER/"/>
    
    
      <category term="Vbs" scheme="https://hankin2015.github.io/tags/Vbs/"/>
    
      <category term="Bat" scheme="https://hankin2015.github.io/tags/Bat/"/>
    
      <category term="抖音" scheme="https://hankin2015.github.io/tags/%E6%8A%96%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>精通Python爬虫框架Scrapy</title>
    <link href="https://hankin2015.github.io/2018/10/05/20181005Scrapy/"/>
    <id>https://hankin2015.github.io/2018/10/05/20181005Scrapy/</id>
    <published>2018-10-05T15:47:41.000Z</published>
    <updated>2018-11-23T10:03:39.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、个人曾经的爬虫"><a href="#0、个人曾经的爬虫" class="headerlink" title="0、个人曾经的爬虫"></a>0、个人曾经的爬虫</h1><p>Requests库、Beautiful Soup。<br>本科毕业设计：微博爬虫。</p><h1 id="1、Scrapy"><a href="#1、Scrapy" class="headerlink" title="1、Scrapy"></a>1、Scrapy</h1><p>&emsp;&emsp;Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。<br>&emsp;&emsp;Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。<br>&emsp;&emsp;Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。外号小刮刮。<br><a id="more"></a></p><h1 id="2、前言"><a href="#2、前言" class="headerlink" title="2、前言"></a>2、前言</h1><p>语言无关论者<br>数据格式：csv、json、xml、txt<br>数据库：mongodb、sqlalchemy、postges<br>前端：html、css、js、squery</p><p>Beautiful Soup、lxml、XPath、selectors。<br><a href="https://stackoverflow.com/questions/tagged/scrapy" target="_blank" rel="noopener">https://stackoverflow.com/questions/tagged/scrapy</a><br><a href="https://scrapy.org/community/" target="_blank" rel="noopener">https://scrapy.org/community/</a></p><p>最小可行产品(Minimum Viable Product, MVP)<br>初创公司、精益创业</p><h1 id="3、认识Scrapy"><a href="#3、认识Scrapy" class="headerlink" title="3、认识Scrapy"></a>3、认识Scrapy</h1><p>数据清晰、格式化、装饰以及存储到数据库。</p><p>XPath选择HTML元素：$x工具函数。（在浏览器console中使用）<br>使用//语法去的某一指定类型的元素。使用/语法即前一个父类下的最近子集。<br>符号@（选择属性）、text()函数、符号* 等等。</p><p>一个特殊的网站：example.com</p><h1 id="4、安装Scrapy"><a href="#4、安装Scrapy" class="headerlink" title="4、安装Scrapy"></a>4、安装Scrapy</h1><blockquote><p>pip install scrapy<br>import scrapy</p></blockquote><h1 id="5、UR2IM流程"><a href="#5、UR2IM流程" class="headerlink" title="5、UR2IM流程"></a>5、UR2IM流程</h1><p>U：URL<br>R：Request<br>R：Response<br>I：Item<br>M：More URL</p><h1 id="6、看到第三章发现真的全程用框架，放弃20181123"><a href="#6、看到第三章发现真的全程用框架，放弃20181123" class="headerlink" title="6、看到第三章发现真的全程用框架，放弃20181123"></a>6、看到第三章发现真的全程用框架，放弃20181123</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0、个人曾经的爬虫&quot;&gt;&lt;a href=&quot;#0、个人曾经的爬虫&quot; class=&quot;headerlink&quot; title=&quot;0、个人曾经的爬虫&quot;&gt;&lt;/a&gt;0、个人曾经的爬虫&lt;/h1&gt;&lt;p&gt;Requests库、Beautiful Soup。&lt;br&gt;本科毕业设计：微博爬虫。&lt;/p&gt;
&lt;h1 id=&quot;1、Scrapy&quot;&gt;&lt;a href=&quot;#1、Scrapy&quot; class=&quot;headerlink&quot; title=&quot;1、Scrapy&quot;&gt;&lt;/a&gt;1、Scrapy&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。&lt;br&gt;&amp;emsp;&amp;emsp;Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。&lt;br&gt;&amp;emsp;&amp;emsp;Scrap，是碎片的意思，这个Python的爬虫框架叫Scrapy。外号小刮刮。&lt;br&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="爬虫" scheme="https://hankin2015.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>国庆七天乐</title>
    <link href="https://hankin2015.github.io/2018/10/03/20181003GuoQin/"/>
    <id>https://hankin2015.github.io/2018/10/03/20181003GuoQin/</id>
    <published>2018-10-03T02:48:41.000Z</published>
    <updated>2018-10-23T07:24:43.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、英语单词"><a href="#0、英语单词" class="headerlink" title="0、英语单词"></a>0、英语单词</h1><p>Scaler定标器<br>ensemble（合奏）集成<br>perturb-and-combine干扰<br>interval间隔<br>tuning调参<br>estimate估计<br>bag<br>cross交叉</p><a id="more"></a><h1 id="1、学习计划"><a href="#1、学习计划" class="headerlink" title="1、学习计划"></a>1、学习计划</h1><ul><li>制作简历</li><li>数据分析</li><li>特征选择</li><li>归一化</li><li>泰坦尼克号、鸢尾花数据集、</li><li>python爬虫</li><li>GitHub提交</li><li>研究生项目管理和总结</li><li>深度学习</li><li>python刷题</li><li>隐马尔可夫模型（HMM）</li></ul><h1 id="2、ipnb展示"><a href="#2、ipnb展示" class="headerlink" title="2、ipnb展示"></a>2、ipnb展示</h1><p>先cmd到指定文件夹，然后输入jupyter notebook。或者到指定文件夹下，shift+右键打开powershell，输入jupyter notebook。</p><ul><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/模板/数据分析模板%5B泰坦尼克号%5D.ipynb" target="_blank" rel="noopener">数据分析模板</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/LintCode/泰坦尼克号/泰坦尼克号.ipynb" target="_blank" rel="noopener">泰坦尼克号</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/iris%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.ipynb" target="_blank" rel="noopener">鸢尾花数据集</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/Santander%20Customer%20Satisfaction/桑坦德客户满意度.ipynb" target="_blank" rel="noopener">桑坦德客户满意度</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Competition/Santander%20Customer%20Satisfaction/SantanderCustomerSatisfaction数据诊断.ipynb" target="_blank" rel="noopener">慕课网的Santander Customer Satisfaction数据诊断</a></li><li><a href="">IJCAI-18 阿里妈妈搜索广告转化预测</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/航空公司用户价值分析/航空公司客户价值分析.ipynb" target="_blank" rel="noopener">航空公司客户价值分析</a></li><li><a href="">印象盐城·数创未来大数据竞赛 - 乘用车零售量预测</a></li><li><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/简单的文本特征分类/简单的文本特征分类.ipynb" target="_blank" rel="noopener">简单的文本分类（字符串的拆分）</a></li></ul><h1 id="3、文章"><a href="#3、文章" class="headerlink" title="3、文章"></a>3、文章</h1><ul><li><a href="https://hankin2015.github.io/2018/09/29/20180821MyPython/">python使用中解决技巧</a></li><li><a href="https://hankin2015.github.io/2018/09/29/20180929DA-template/">数据分析之模板</a></li><li><a href="https://hankin2015.github.io/2018/09/25/20180925MXNet/">动手学深度学习【个人版】</a></li><li><a href="https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/">数据分析之数据可视化</a></li><li><a href="https://hankin2015.github.io/2018/09/23/20180923/">学习python机器学习2018.9.23</a></li><li><a href="https://hankin2015.github.io/2018/09/23/20180923DA/">python数据分析【个人版】</a></li><li><a href="https://hankin2015.github.io/2013/01/04/20130104ILoveML/">转岗算法工程师日程</a></li><li><a href="https://www.cnblogs.com/tornadomeet/p/3395593.html" target="_blank" rel="noopener">机器学习&amp;数据挖掘笔记_16（常见面试之机器学习算法思想简单梳理）</a></li><li><a href="http://lib.csdn.net/article/python/62942" target="_blank" rel="noopener">Python装饰器的通俗理解</a></li><li><a href="">python中format函数</a></li></ul><p>装饰器就是闭包。</p><h1 id="4、西瓜书"><a href="#4、西瓜书" class="headerlink" title="4、西瓜书"></a>4、西瓜书</h1><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经元、输入层、隐藏层、输出层<br>隐藏层比较多（大于2）的神经网络叫做深度神经网络。而深度学习，就是使用深层架构（比如，深度神经网络）的机器学习方法。<br>为了拟合一个函数，要么使用一个浅而宽的网络，要么使用一个深而窄的网络。而后者往往更节约资源。</p><p>深层网络也有劣势，就是它不太容易训练。简单的说，你需要大量的数据，很多的技巧才能训练好一个深层网络。这是个手艺活。</p><h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><p>神经元也叫做感知器。</p><h2 id="机器学习名字的由来"><a href="#机器学习名字的由来" class="headerlink" title="机器学习名字的由来"></a>机器学习名字的由来</h2><p>阿瑟·萨缪尔研制西洋跳棋程序。</p><p>错误率error rate<br>精度accuracy = 1-错误率<br>误差error<br>训练误差或者经验误差<br>泛化误差：新样本上的误差<br>过拟合overfitting：泛化性能下降<br>欠拟合underfitting<br>分层采样：保留类别比例的而采样方式</p><p>##<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同学您好！非常感谢您参加了华为公司2019届应届生招聘。经过我们慎重的考虑和认真的评估，非常抱歉地通知您未能通过本次面试。我们对您在面试过程中所表现出来的积极努力和认真参与，致以由衷的敬意和真诚的感谢！勇敢新世界，再次感谢您的参与！</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>hr您好！非常感谢您邀请我参加贵公司2019届应届生招聘。经过我慎重的考虑和认真的评估，非常抱歉地通知您未能通过我的筛选。我对您在面试过程中对我的认可，致以由衷的敬意和真诚的感谢！2018，再次感谢认识您！</p><p>Jaccard系数<br>Jaccard index , 又称为Jaccard相似系数（Jaccard similarity coefficient）用于比较有限样本集之间的相似性与差异性。Jaccard系数值越大，样本相似度越高。</p><p>作者：望其向北<br>链接：<a href="https://www.nowcoder.com/discuss/125413?type=0&amp;order=0&amp;pos=21&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/125413?type=0&amp;order=0&amp;pos=21&amp;page=1</a><br>来源：牛客网</p><p>二叉查找树，查找公共父节点<br>TCP，UDP<br>http报文格式，手写<br>bigdecimal大数实现加减运算<br>大学最自豪最印象深刻的事<br>向我提问，意向地(面试官介绍了武汉，南京部门)<br>还有几个问题记不清了，二面加油！😃</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0、英语单词&quot;&gt;&lt;a href=&quot;#0、英语单词&quot; class=&quot;headerlink&quot; title=&quot;0、英语单词&quot;&gt;&lt;/a&gt;0、英语单词&lt;/h1&gt;&lt;p&gt;Scaler定标器&lt;br&gt;ensemble（合奏）集成&lt;br&gt;perturb-and-combine干扰&lt;br&gt;interval间隔&lt;br&gt;tuning调参&lt;br&gt;estimate估计&lt;br&gt;bag&lt;br&gt;cross交叉&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>手记</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929Note/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929Note/</id>
    <published>2018-09-29T11:47:41.000Z</published>
    <updated>2018-10-03T02:58:13.417Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之模板</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929DA-template/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929DA-template/</id>
    <published>2018-09-29T11:43:41.000Z</published>
    <updated>2018-10-21T12:37:11.862Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.kesci.com/home/project/5b3b3ed771a61726e13833e3" target="_blank" rel="noopener">数据分析（业务向）技能总结</a></p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  # 数学</span><br><span class="line">import pandas as pd</span><br><span class="line">from sklearn import datasets  #用数据库去学习，或者把数据库放到tenserflow模块练习</span><br><span class="line">from sklearn.model_selection import train_test_split # 数据集测试集分离</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier   # 会选择邻近几个点作为他的邻居，综合临近几个点模拟出数据的预测值</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import warnings </span><br><span class="line">warnings.filterwarnings(&quot;ignore&quot;)</span><br><span class="line">import seaborn as sns</span><br><span class="line">import os</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>&lt;–!more–&gt;<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, we'll import pandas, a data processing and CSV file I/O library</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># We'll also import seaborn, a Python graphing library</span></span><br><span class="line"><span class="keyword">import</span> warnings <span class="comment"># current version of seaborn generates a bunch of warnings that we'll ignore</span></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sns.set(style=<span class="string">"white"</span>, color_codes=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Next, we'll load the Iris flower dataset, which is in the "../input/" directory</span></span><br><span class="line">iris = pd.read_csv(<span class="string">"../input/Iris.csv"</span>) <span class="comment"># the iris dataset is now a Pandas DataFrame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's see what's in the iris data - Jupyter notebooks print the result of the last thing you do</span></span><br><span class="line">iris.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Press shift+enter to execute this cell</span></span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/chennai1101/article/details/59483438/" target="_blank" rel="noopener">Python 打印语句</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.kesci.com/home/project/5b3b3ed771a61726e13833e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据分析（业务向）技能总结&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;头文件&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之数据可视化</title>
    <link href="https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/"/>
    <id>https://hankin2015.github.io/2018/09/29/20180929DA-Vasulize/</id>
    <published>2018-09-29T05:47:41.000Z</published>
    <updated>2018-10-03T02:50:21.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、数据集的来源"><a href="#1、数据集的来源" class="headerlink" title="1、数据集的来源"></a>1、数据集的来源</h1><ul><li><a href="https://blog.csdn.net/brucewong0516/article/details/79011562" target="_blank" rel="noopener">numpy之random库简单的随机数据生成</a></li><li><a href="https://blog.csdn.net/tmb8z9vdm66wh68vx1/article/details/79212888" target="_blank" rel="noopener">教你在Python中用Scikit生成测试数据集</a><a id="more"></a></li><li>1、np.random.rand(d0, d1, …, dn)<br>np.random.rand(3,2) #生成3行2列的随机数组<br>np.random.rand(3,2,2) #生产3维的随机数组</li><li>2、randn(d0, d1, …, dn)返回一个样本，具有标准正态分布。</li><li>3、randint(low[, high, size])<ul><li>返回随机整数，范围区间为[low,high），包含low，不包含high</li><li>参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int</li><li>high没有填写时，默认生成随机数的范围是[0，low)</li></ul></li><li>4、np.random.random([size])生成[0,1)之间的浮点数,与np.random.rand()功能类似</li><li>5、numpy.random.choice(a[, size, replace, p])生成一个随机样本，从一个给定的一维数组a中随机选取</li><li>6、numpy.random.seed()生成随机数的种子，使得每次生成随机数相同</li></ul><p><strong>注意</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(2) # 种子和随机函数放在一起运行才能使随机数不变</span><br><span class="line">np.random.rand(3)</span><br></pre></td></tr></table></figure></p><h1 id="2、画散点图看分布"><a href="#2、画散点图看分布" class="headerlink" title="2、画散点图看分布"></a>2、画散点图看分布</h1><h1 id="3、资料满满"><a href="#3、资料满满" class="headerlink" title="3、资料满满"></a>3、资料满满</h1><p><a href="https://blog.csdn.net/suzyu12345/article/details/69029106" target="_blank" rel="noopener">python seaborn画图</a><br><a href="https://www.cnblogs.com/gczr/p/6767175.html" target="_blank" rel="noopener">Python数据可视化-seaborn</a></p><p><a href="https://www.kaggle.com/benhamner/python-data-visualizations/notebook" target="_blank" rel="noopener">Python data visualizations on the Iris dataset</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、数据集的来源&quot;&gt;&lt;a href=&quot;#1、数据集的来源&quot; class=&quot;headerlink&quot; title=&quot;1、数据集的来源&quot;&gt;&lt;/a&gt;1、数据集的来源&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/brucewong0516/article/details/79011562&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;numpy之random库简单的随机数据生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/tmb8z9vdm66wh68vx1/article/details/79212888&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教你在Python中用Scikit生成测试数据集&lt;/a&gt;
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="Python" scheme="https://hankin2015.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>动手学深度学习[个人版]</title>
    <link href="https://hankin2015.github.io/2018/09/25/20180925MXNet/"/>
    <id>https://hankin2015.github.io/2018/09/25/20180925MXNet/</id>
    <published>2018-09-25T02:47:41.000Z</published>
    <updated>2018-10-23T02:38:06.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、学习深度须知"><a href="#1、学习深度须知" class="headerlink" title="1、学习深度须知"></a>1、学习深度须知</h1><h2 id="DL"><a href="#DL" class="headerlink" title="DL???"></a>DL???</h2><ul><li>纸上得来终觉浅，绝知此事要躬行。</li><li>通俗来说，机器学习是一门讨论各式各样适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。</li><li>裁剪平均值的雏形：去掉最高分和最低分。</li><li>绝大多数神经网络的核心原则：<ul><li>交替使用线性与非线性处理单元，经常被称为“层”。</li><li>使用链式法则（即反向传播）来更新网络的参数。<a id="more"></a></li></ul></li></ul><h2 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet???"></a>MXNet???</h2><ul><li>MXNet 是一个开源的<strong>深度学习框架</strong>。它是 AWS（亚马逊云计算服务）首选的深度学习框架，并且也许是最优秀的库【百度百科评价】。</li><li>对 Python 的支持只是其冰山一角—MXNet 同样提供了对 R、Julia、C++、Scala、Matlab，和 Javascript 的接口。</li><li>MXNet 的ndarray、autograd、gluon等模块的基础功能，所以gluon仅仅是一个模块，而不是框架。</li></ul><h2 id="GPU【图像处理器】和CPU【中央处理器】的区别"><a href="#GPU【图像处理器】和CPU【中央处理器】的区别" class="headerlink" title="GPU【图像处理器】和CPU【中央处理器】的区别"></a>GPU【图像处理器】和CPU【中央处理器】的区别</h2><ul><li>CPU擅长逻辑控制和通用类型数据运算</li><li>GPU擅长的是大规模并发计算</li></ul><p>深度学习训练通常需要大量的计算资源。GPU 目前是深度学习最常使用的计算加速硬件。相对于 CPU 来说，GPU 更便宜且计算更加密集。一方面，相同计算能力的 GPU 的价格一般是 CPU 价格的十分之一。另一方面，一台服务器通常可以搭载 8 块或者 16 块 GPU。因此，GPU 数量可以看作是衡量一台服务器的深度学习计算能力的一个标准。</p><p>目前独立 GPU 主要有 AMD 和 Nvidia 两家厂商。其中 Nvidia 在深度学习布局较早，对深度学习框架支持更好。因此，目前大家主要会选择 Nvidia 的 GPU。</p><h1 id="2、数据操作"><a href="#2、数据操作" class="headerlink" title="2、数据操作"></a>2、数据操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://zh.gluon.ai/chapter_prerequisite/install.html" target="_blank" rel="noopener">获取代码并安装运行环境</a><br>conda config –prepend channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>下载存储地址：’D:\Program Files\Anaconda\envs\gluon’</p><p>小问题：我使用anaconda安装的，首先关于python和Linux的安装都需要先升级工具为最新版本。然而gluon模块安装完成后会有jupyter notebook版本，点击后闪退无果。<br>正确的打开方式：打开cmd=》激活gluon（activate gluon）=》jupyter notebook</p><p>还可以直接安装pip install mxnet.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>NDArray 和 NumPy 的多维数组非常类似。然而，NDArray 提供 GPU 计算和自动求梯度等更多功能，这些使得 NDArray 更加适合深度学习。</p><p><a href="http://nbviewer.jupyter.org/github/HanKin2015/Machine_to_DeepingLearning/blob/master/Ipynb/MXNet1.ipynb" target="_blank" rel="noopener">mxnet的简单使用</a></p><h1 id="3、深度学习基础"><a href="#3、深度学习基础" class="headerlink" title="3、深度学习基础"></a>3、深度学习基础</h1><p>单层神经网络：线性回归和 Softmax 回归。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>权重weight、偏差bias、参数parameter。<br>预测（估计）</p><h3 id="模型训练三要素"><a href="#模型训练三要素" class="headerlink" title="模型训练三要素"></a>模型训练三要素</h3><p>训练数据：特征feature、标签label、样本sample、训练集<br>损失函数：平方误差函数也称平方损失（记得要乘以1/2，其中常数 1/2 使得对平方项求导后的常数系数为 1），然后求和后再取平均值。<br>优化算法：在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。</p><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫做解析解（analytical solution）。<br>只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫做数值解（numerical solution）。</p><p>批量大小和学习率的值是人为设定的，并不是通过模型训练学出的，因此叫做超参数（hyperparameter）。我们通常所说的“调参”指的正是调节超参数，例如通过反复试错来找到合适的超参数。少数情况下，超参数也可以通过模型训练学出。</p><p>这个网站主要还是讲的是深度学习，还是先入门机器学习为好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、学习深度须知&quot;&gt;&lt;a href=&quot;#1、学习深度须知&quot; class=&quot;headerlink&quot; title=&quot;1、学习深度须知&quot;&gt;&lt;/a&gt;1、学习深度须知&lt;/h1&gt;&lt;h2 id=&quot;DL&quot;&gt;&lt;a href=&quot;#DL&quot; class=&quot;headerlink&quot; title=&quot;DL???&quot;&gt;&lt;/a&gt;DL???&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/li&gt;
&lt;li&gt;通俗来说，机器学习是一门讨论各式各样适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。&lt;/li&gt;
&lt;li&gt;裁剪平均值的雏形：去掉最高分和最低分。&lt;/li&gt;
&lt;li&gt;绝大多数神经网络的核心原则：&lt;ul&gt;
&lt;li&gt;交替使用线性与非线性处理单元，经常被称为“层”。&lt;/li&gt;
&lt;li&gt;使用链式法则（即反向传播）来更新网络的参数。
    
    </summary>
    
      <category term="ML" scheme="https://hankin2015.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="https://hankin2015.github.io/tags/ML/"/>
    
      <category term="DeepLearning" scheme="https://hankin2015.github.io/tags/DeepLearning/"/>
    
      <category term="MXNet" scheme="https://hankin2015.github.io/tags/MXNet/"/>
    
      <category term="Glunon" scheme="https://hankin2015.github.io/tags/Glunon/"/>
    
  </entry>
  
</feed>
